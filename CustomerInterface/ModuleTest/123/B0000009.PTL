               /* PRQA S 3619 EOF */ /* << IAR-Compiler allows whitespaces>> */
               /* PRQA S 3116 EOF */ /* << pragma directives needed, compiler specific>>*/
               /*************************************************************************
                 Company : Valeo Wiper System
                 Project : RLT Sensor, RDN Sensor
                 Component : RLS_LINST.c
                 Documentation reference   : Software Requrement Specification
                 Overview of the component : LIN- Data Link layer
                 Evolution of the component : see PVCS Version control system
                               Initials   date   modification
               *************************************************************************/
               /* History                                                                    */
               /*----------------------------------------------------------------------------*/
               /* Date      VDR_Number     Description                                       */
               /* DD.MM.YY*/
               /*----------------------------------------------------------------------------*/
               /* 05.09.11 VDR_705  PCG  - Send detection of Rain Sensor at any time not only when active */
               /* 31.08.11 VDR_700  PCG  - Set Light Sensitivity "0" like LS "4". Set default to "4" instead of "0" 
                                         - Reorganize signals related to Message CEM_L8_FrP04 */
               /* 13.05.11 VDR_659  PCG  - QA-C                       */
               /* 12.05.11 VDR_634  PCG  - removed changes from 10.May.11 */
               /* 10.05.11 VDR_634  PCG  - set adapterrrainsensacrive failure when no master msg is received */
               /* 24.03.11 VDR_647  FS   - Variable name changed*/ 
               /* 18.03.11 VDR_66   PCG  - RLS_VDR_633 RLS_VOLVO_Y555 the first frame of RSM partnumber is set to 0 at startup */
               /* 17.02.11 VCO_70   PCG  - reduced low limit for WS Transmission due to Blue shade band*/
               /* 15.02.11 VDR_580  PCG  - splash bit no more depending on directmode */
               /* 17.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 04.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 11.08.10 VCO_73   PCG  - Implemented Rain Sensor Sensitivity up to 8 sensitivities. SWRS-RSM-001:Req34v1 */
               /* 06.08.10 VCO_71   PCG  - Implemented Rain Sensor Norm Value: adjust RSM sensitivity when placed on 
               *                            different vehicles. SWRS-RSM-001: Req38v1  */
               /* 06.08.10 VCO_73   PCG  - Implemented VCC Part Number: 31314540. SWRS-RSM-001:Req14v1  */
               /* 05.08.10 VCO_72   PCG  - Implemented Light Sensor Sensitivity: RainSnsrLiSnvty. SWRS-RSM-001:Req51v2  */
               /* 03.08.10 VCO_69   PCG  - Implemented new output signal RainSnsrLiMod. SWRS-RSM-001:Req39v2 */
               /* 03.08.10 VCO_66   PCG  - Implemented CarCode table values according mail 26.03.2010*/
               /* 02.08.10 VCO_67   PCG  - Implemented Rain Sensor active when Terminal_X is set regardless 
               *                            Switch Position. SWRS-RSM-001:Req31v1 */
               /* 02.08.10 VCO_68   PCG  - Implement New message CEM_L8_FrP04. SWRS-RSM-001:Req19v1 */
               /* 30.06.10 VDR_540  FS   - Butterfly Option integrated*/
               /* 10.06.10 VCO_49   FS   - Implement long EEPROM PLUS Logging Issues from 11.June --> Park Position corrected*/
               /* 10.06.10 VCO_59   FS   - Logging files --> Rework ParkPosition Evaluation*/
               /* 26.05.10  VCO_055     AL      reomve debouncing of RAM and ROM error*/
               /* 29.04.10 VDR_473  FS   - QA-C*/
               /* 26.04.10 VCO_48   FS   - Use "AB" Index instead of only "B" of the partnumer within EEPROM*/
               /* 26.04.10 VCO_48   FS   - First Frame of Part number not correct*/
               /* 26.03.10  VCO_48   FS   - Update due to Test Drive
                *                           Park contact has been send to late via LIN
                                        --> Update in this file and trigger on WiperSpeed_Running Signal
                                          - Update internal SCS_Signals, that both ldf can work the same*/
               /* 25.03.10  VCO_44   FS   - Implement strategy for Partnumber Read Out
                *                         - delete some parts of VCO_33
                *                         - Switch Stalk Information dependent from CarCode*/
               /* 11.02.10  VDR_437  FS   - Index of Ford Partnumber from EEPROM included *
                 *                        - Mapping of RainSensorSensitivity not in RAM --> in EEPROM*/
               /* 19.01.10  VDR_414  FS    Update due to Testdrive*/
               /* 23.12.09  VDR_394  FS    REWORK: New CarCode Table to be implemented, Req: Email from 20091218*/
               /* 22.12.09  VDR_362  FS    Rework: Overflow of rb_parkpositioncounter_s MUST have been implemented */
               /* 18.12.09  VDR_403  FS    - rb_FixedCarCode deleted
                *                          - Set Auxillary Variable constantly to ALL-value that Ford Partnumber
                *                            can be received by Master for all CarCodes*/
               /* 19.11.09  VDR_396  FS    RainSensorEnable as required in SRS*/
               /* 17.11.09  VDR_394  FS    Default values windshield and comments*/
               /* 01.10.09  VDR_373  FS    "OneTime or Double Overwiped"*/
               /* 29.09.09  VDR_362  FS    Implement wipe cancelling when 4 seconds wiper has not moved*/
               /* 25.09.09  VDR_368  FS    Requirements from FRSI, SRD, ES and Testcases. See comments in code*/
               /* 28.09.09  VDR_360  FS    RainSensorDisable implementation for Ford*/
               /* 31.07.09  VDR_355  AL    Changes based on results of function test and     *
                          & VDR_356        Review of function from Bosch sensor             */
               /* 16.07.09  VDR_344 FS     Updating complete first version to                *
                                           first release version due to                      *
                                           Ford Meeting in Bietigheim                        */
               /* 28.08.15  VCO_268 SP     Cleanup the LIN modules  */
               /*02.10.2015 VDR_911 SP     HammingErr shld be part of RS_Error/LS_Error and shld not be used for Active Err*/
               /*30.05.2016 VDR_983 NB     Sporadic illegale instruction reset in the startup                              */
               /******************************************************************************/
               /*************************************************************************
               **                   Common and module include-file                     **
               **************************************************************************/
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/DEVICE/ior5f109be.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_projectDefs.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_E2ProjectConfig.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_main.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_lininclude.h"
               /*************************************************************************
               **                   Other files included                               **
               **************************************************************************/
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_io.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_timer.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_Check_sr.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_rainsens.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_diagnose.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_E2Handler.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_flashe2.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/RAIN/G5_rs_task.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_IRlight.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_DippedBeam_sr.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control_sr.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_spi_sr.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_utilities.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_AsicFramesLin.h"
               /*VDR_362 Carry Over Standard Code*/
               /*************************************************************************
               **                   Declaration of local module variables              **
               *************************************************************************/
               //#define cb_HUD_MEASURING_RANGE_1    0x40
               //#define cb_HUD_MEASURING_RANGE_2    0x80
               /* PRQA S 0759 1*//*<< 0759:union needed to reduce RAM usage >>*/
               static volatile Flag uF_StalkInPos_Flags_g;
               /******************************************************************************/
               /*                      Definition of exported variables                      */
               /******************************************************************************/
               /*************************************************************************
               **                   Declaration of local module Macros **
               *************************************************************************/
               static const byte cab_PotistageMapping_mg[8] = {4,5,6,7,3,2,1,0}; /*mapping for potistages!*/
               /*************************************************************************
               **                   Declaration of local module Functions              **
               *************************************************************************/
               static void CheckErrors(void);
               void RainFunction(void);
               void LightFunction(void);
               void Humidity_Function(void);
               void StandByMode(void);
               void VoltageDetect(void);
               void OutPutBrightnessValue(void);
               static byte rb_Verglasun_offenDebounce_mg;
               static byte rb_Verglasun_ClosedDebounce_mg;
               static unsigned int rw_CommandCloseWindowTimout_mg;
               static byte rb_KL15_mg;
               static byte rb_AnyErrorCounterDebounce_mg;
               static unsigned int rw_AfterRSWipeCounter_mg;                   // Time after last wipe from RS
               static unsigned int rw_AfterRSWipeCounterAlt_mg;              //Time to the last wipe from RS
               static unsigned int rw_AfterWWSWipeCounter_mg;                  // Time after last wipe from WWS
               static  unsigned int rw_WipeCommandTimOut_mg;                    //timout for requested wipe
               static  byte rb_IgnitionOndelay_mg = 0;
               static  byte rb_Err_State_Light_Sens_mg =0;// light error
               static  int  rb_OutsideTemp_mg  = 1;
               static  byte rb_WipeWorkStatus_mg = 1;
               /******************For HUD**********************/
               static unsigned long HUDEverageValue[2] = {0,0};//,0,0,0,0,0};
               static unsigned long rb_storeHUDValueEvery500ms[10]={0,0,0,0,0,0,0,0,0,0};
               static unsigned long rb_storeFW_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
               static unsigned long rb_storeAMB_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
               void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_100ms);
               unsigned long CalcHUDMean_1000ms(void);
               void orderHUDValue(int n);
               void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb);
               unsigned long  AdjustOutHudValue(unsigned long rl_CurrentHud);
               unsigned char GetUpdateTimeForLightStatus(void);
               static unsigned long FW_Average_In_50ms = 0;
               static unsigned long AMB_Average_In_50ms = 0;
               static  unsigned long FW_Average_In_50ms_Old = 0;
               static  unsigned long AMB_Average_In_50ms_Old = 0;
               static  unsigned long RW_Amb_Fw_Result_End    = 0;
               static  unsigned char rb_hud_data_update      = 0;
               static  unsigned char RW_Update_Time_Count = 0;
               /********************End***********************/
               byte CRC8SAEJ1850(byte *u8_data,byte u8_len);//crc8saej1850 
               byte GetHudCrcj1850(unsigned long hudSrc);
               byte GetOutdBriStsCrcj1850(byte OutdBriSts);
               void GetLightTransmission(byte trans_550nm,byte trans_880nm);
               void Get_BCMVehType(byte CarType);
               void Set_BCMLightOffset(byte offset);
               void SendRLSSerNo(void);
               void SendRLSMPartNo(void);
               void SendRLSMPartNo10(void);
               void OutPutHudValue(void);
               void OutPutHudSendCount(void);
               void TemperatureDetect(void);
               void WipeWinterModeCheck(void);
               byte IsByteOddParity(byte data);
               /**************************************************************************
                 Syntax   : void  GetLeWWS(void)
                 Object   : GetLeWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Schaltermoduls von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLeWWS(void)
               {
                 static unsigned int rw_IgnitionOffDelay_mg;
                 static byte rb_IntervalOnOndelay_mg;
                 static byte rb_AfterResetCounter_l;
                 byte rb_Empfindlichkeit_LS_l;
                 byte rb_BCM_LightSns;
                /***********************Add the Auto_Close_Window Function in Rain Condition*************************/   
1 0     ( )    GetLeWWS
1 1     ( )( ) if (CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1== 1)                        //Window Open
                 {
1 2     ( )( )   if (uF_VoltageStatus_g . Bit . B2 == 0)                                     
                   {
1 3     ( )( )     if (rb_Verglasun_offenDebounce_mg < 0xff)
                     {
                       rb_Verglasun_offenDebounce_mg ++;
                     }
                   }
                   rb_Verglasun_ClosedDebounce_mg = 0;
                 }
                 else 
1 4     ( )( )   if(CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 0)
                 {
1 5     ( )( )     if (rb_Verglasun_ClosedDebounce_mg < 0xff)
                   {
                     rb_Verglasun_ClosedDebounce_mg ++;
                   }
                   rb_Verglasun_offenDebounce_mg = 0;
                 }
                 else
                 {
                 }
1 6     ( )( ) if((uLinIndicationFlags . w[0]. b5 != 0))
                 {
                    {uLinIndicationFlags . w[0]. b5 = 0;};
                    uF_SCIFlags_mg . Bit . B1 = 1;
                    rb_OutsideTemp_mg =  CemCem_Lin1Fr02_CEM_LIN1 . cemcem_lin1fr02_cem_lin1 . AmbTForVisy_CEM_LIN1;
                    WipeWinterModeCheck(); 
                 }
1 7     ( )( ) if((uLinIndicationFlags . w[0]. b4 != 0))
                 {
                      {uLinIndicationFlags . w[0]. b4 = 0;};
                      uF_SCIFlags_mg . Bit . B1 = 1;
                      {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErrActv_CEM_LIN1 = 1;};     
                      Get_BCMVehType(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . VehTyp_CEM_LIN1);
                      GetLightTransmission(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValFrnt_CEM_LIN1,CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValAmb_CEM_LIN1);
                 }
1 8     ( )( ) if((uLinIndicationFlags . w[0]. b3 != 0))
                 {
                    {uLinIndicationFlags . w[0]. b3 = 0;};
                    uF_SCIFlags_mg . Bit . B1 = 1;
                    rb_BCM_LightSns = CemCem_Lin1Fr04_CEM_LIN1 . cemcem_lin1fr04_cem_lin1 . RainSnsrLiThd_CEM_LIN1;
                    Set_BCMLightOffset(rb_BCM_LightSns);
                 }
1 9     ( )( ) if( (uLinIndicationFlags . w[0]. b2 != 0))
                {
                   {uLinIndicationFlags . w[0]. b2 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
                }
1 10    ( )( ) if((uLinIndicationFlags . w[0]. b1 != 0))
                 { 
                   {uLinIndicationFlags . w[0]. b1 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   uF_SCIFlags_mg . Bit . B6 = !CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WiprInWipgAr_CEM_LIN1;        // wiper position
1 11    ( )( )   if (CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1)                                 /* Washpump activ? 0x5:Front washing*/
                   {
                     RSStatus . Bit . B1 = 1;                                       /* set Washing activ bit */
                   }
                   else 
1 12    ( )( )     if (uF_StatusRainsensor_mg . Bit . B7 == 1)                                /* In Parkposition ? */
                   {
                     RSStatus . Bit . B1 = 0;                                      /* Clear Washing active bit */
                   }
                   else{}                                                              /*Do nothing, Dummy-else for Misra Check*/
                 }
1 13    ( )( ) if((uLinIndicationFlags . w[0]. b6 != 0))
                 { 
                   {uLinIndicationFlags . w[0]. b6 = 0;};
                   rw_NoCommunicationCounter_g = 0;                                 // reset no communication counter
                   uF_SCIFlags_mg . Bit . B1 = 1;                                     // set connected to Master  
                   uF_Communication_mg . Bit . B1 = 1;    
                   rb_speed_in_kmh_g  = CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . VehSpdForWipg_CEM_LIN1;   
1 14    ( )( )   if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . VehSpdForWipg_CEM_LIN1 == 0xFF)
                   {
                     rb_speed_in_kmh_g = 75;                           /* set speed to (75 km/h)*/
                   }
                   else 
                   {
                   }
1 15    ( )( )   if(rb_speed_in_kmh_g>=10)
                   {
                     uF_GainAdjustFlags_g . Bit . B1 = 1;
                   }   
                   rb_KL15_mg = (CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WipgPwrActvnSafeWipgPwrAcsyModSafe_CEM_LIN1==2);
                  /* ignore ignition off if speed higher 4km/h*/
1 16    ( )( )   if((rb_KL15_mg == 1)||(rb_speed_in_kmh_g > 4)) /*VCO_083*/
                   {
                     uF_VoltageStatus_g . Bit . B2 = 1;
                     rw_StandbyTimeOutCnt_g = 0;
                     rw_IgnitionOffDelay_mg = 0;
1 17    ( )( )     if(rb_IgnitionOndelay_mg < 250)
                     {
                       rb_IgnitionOndelay_mg++;
                     }
1 18    ( )( )     if((((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0) == 0) &&(rb_AfterResetCounter_l> 10))
                     {
1 19    ( )( )       if(((CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 1)&&(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1==1))                         //automatic
                           || (((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x40)>0) != 0))
                       {
                         uF_StatusRainsensor_mg . Bit . B0 = 1;                            /*Rainsensor always active!*/
                       }
                       else
                       {
                         uF_StatusRainsensor_mg . Bit . B0 = 0;                           /*Rainsensor off!*/
                       }
                     }
                     else
                     {
                       uF_StatusRainsensor_mg . Bit . B0 = 0;                             //Rainsensor off!
                     }
1 20    ( )( )     if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1 == 1)                            // copy automatic wiping mode
                     {
1 21    ( )( )       if(rb_IntervalOnOndelay_mg > 15)                               //debound 150ms when turn the auto wiper on
                       {
                         RSStatus . Bit . B7 = 1;
                       }
                       else
                       {
                         rb_IntervalOnOndelay_mg++;
                       }
                     }
                     else
                     {
                       RSStatus . Bit . B7 = 0;
                       rb_IntervalOnOndelay_mg = 0;
                     }
                   }
                   else
                   {          
                     uF_VoltageStatus_g . Bit . B2 = 0;
                     rw_AfterWWSWipeCounter_mg = 50000;                                //Direktbitdelay bei Kl15 Aus hochsetzen!
                     rw_WipeCommandTimOut_mg = 0;
                     rb_IgnitionOndelay_mg = 0;
                     uF_StatusRainsensor_mg . Bit . B0 = 0;                                //Rainsensor off!
                   }
                   rb_LIN_SensitivityShift_g =  7;                                     //adaptation Variable for sensitivity factor
                   rb_PotiStageFromBox_g = (
1 22    ( )( )   CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1 >= 7)?3:(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1);
                 }  
                 else                                                                  //keine neue Master Nachricht!
                 {                                                                     // check if system is on -> to switch off 
1 23    ( )( )   if((rw_NoCommunicationCounter_g > ((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200)))                               /***4S***/
                   {     
1 24    ( )( )     if ((uF_SCIFlags_mg . Bit . B4 == 0)||( uF_ASIC_ControlFlags_g . Bit . B4 == 0))  /*VDR_526*/
                     {
1 25    ( )( )       if ( ((uF_VoltageStatus_g . Bit . B2== 0)) &&((rb_Verglasun_offenDebounce_mg > 100) &&
                                                          (((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x04)>0) == 1)) && (uF_SCIFlags_mg . Bit . B4 == 0) )
                       {
                         uF_ASIC_ControlFlags_g . Bit . B4 = 1;                             // Set Request for Standby Mode
                       }
                       else
                       {
                         uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                       }       
                       uF_SCIFlags_mg . Bit . B2 = 1;                                         // Was Connected to Master
                     }
                     else 
                     {
1 26    ( )( )       if ((CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1== 0)||(rw_CommandCloseWindowTimout_mg > 6000))
                       {
                         uF_SCIFlags_mg . Bit . B2 = 1;                                       // no need of Standby mode 
                         uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                         uF_SCIFlags_mg . Bit . B0 = 0;                                /*VDR_526*/
                         uF_SCIFlags_mg . Bit . B4 = 0;                           /*VDR_526*/
                         rb_WakeupCounter_mg = 0; 
                       }
                       else
                       {
1 27    ( )( )         if (rb_WakeupCounter_mg == 0)                             /*VDR_526*/
                         { 
                           uF_SCIFlags_mg . Bit . B0 = 1; 
                         }
                       }
                     }
                     uF_SCIFlags_mg . Bit . B1 = 0;                                  // clear connected to Master
                   }
                   else
                   {
                     uF_SCIFlags_mg . Bit . B0 = 0;                                    /*VDR_526*/
                     rw_NoCommunicationCounter_g ++;
                     uF_SCIFlags_mg . Bit . B2 = 0;                                          // Was Connected to Master
1 28    ( )( )     if(rw_NoCommunicationCounter_g >= (((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200) - 3) )
                     {
                                                                                       /*clear marker in the EEPROM to indicate there is a normal sleeep command*/
                       rb_Release_IntervalMarker_Update_g = 0x00;                      //send sleep command to RS
                       uF_StatusRainsensor2_mg . Bit . B3 = 1;                               //indicate if rb_Release_IntervalMarker_g sholud be updated in EEPROM
                     }
                   }
                 }
                 rb_Empfindlichkeit_LS_l = 3;
1 29    ( )( ) if((cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)>3)
                 {
                   rb_LSPotiStage_g = (cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)-3;
1 30    ( )( )   if(rb_LSPotiStage_g>7)
                   {
                     rb_LSPotiStage_g=7;
                   }
                 }
                 else
                 {
                   rb_LSPotiStage_g = 0;
                 }
1 31    ( )( ) if (rb_AfterResetCounter_l<250)
                 {
                   rb_AfterResetCounter_l++;                                           /* counts calls of routine to delay activation of rainsensor*/
                 }
1 32    ( )( ) if(rw_IgnitionOffDelay_mg < 1000)                                     /* 10sec delay */
                 {
                   rw_IgnitionOffDelay_mg++;
                 }
                 else
                 {
                   rb_Release_IntervalMarker_Update_g |= 0xA0;
                   uF_StatusRainsensor2_mg . Bit . B2 = 0;
                 }
               }
               /**************************************************************************
                 Syntax   : void  GetLsWWS(void)
                 Object   : GetLsWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Wischermotorin von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLsWWS(void)
               {  
                 static byte rb_parkpositioncounter_s;
                 /*simulierte Wischzeit bei LSS aus*/
                 static const byte cab_WiperMotorRunntime_mg[8] ={142,142,133,125,117,111,105,100};  
2 0     ( )    GetLsWWS
2 1     ( )( ) if ((rb_WiperSpeed_g > 0)&&(uF_SCIFlags_mg . Bit . B6== 1))
                 {    
2 2     ( )( )   if (rw_WipeCommandTimOut_mg <= 400)
                   {
                     rw_WipeCommandTimOut_mg ++;                // reset Timout if wiper motor wants not wipe
                   }
                   else
                   {
                     rb_LimitMemomryNoWiperReaction_g = 1;
                   }      
                 }
2 3     ( )( ) if(    ((CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1 == 0)    //NO auto wiper
                      && (uF_SCIFlags_mg . Bit . B6 == 1))
                      ||(rw_WipeCommandTimOut_mg > 400))
                 {
2 4     ( )( )   if((rb_WiperSpeed_g > 0)||(uF_StatusRainsensor_mg . Bit . B7 == 0))
                   {
2 5     ( )( )     if(rb_parkpositioncounter_s>10)            // Parkpositioncounter groesser 10
                     {
                       uF_StatusRainsensor_mg . Bit . B7 = 0;              // delete bit for Parkposition
                     }
                     rb_parkpositioncounter_s++;                // increase Parkpositionscounter
                   }
2 6     ( )( )   if(rb_parkpositioncounter_s > (cab_WiperMotorRunntime_mg[rb_WiperSpeed_g]))
                   {
                     rw_WipeCommandTimOut_mg = 0;
                     uF_StatusRainsensor_mg . Bit . B7 = 1;               
                     rb_parkpositioncounter_s = 0;            
                   }
                 }
                 else    
                 {
2 7     ( )( )   if((uF_SCIFlags_mg . Bit . B6 == 0)&&(rb_WiperSpeed_g > 0))
                   {
                     rbi_WiperStarted_g = 1;
                   }
2 8     ( )( )   if(uF_SCIFlags_mg . Bit . B6 == 1)            // In Parklagensignal ?
                   {
2 9     ( )( )     if(uF_StatusRainsensor_mg . Bit . B7 == 0)
                     {
                       rb_parkpositioncounter_s=0;              // Parkpositioncounter zuruecksetzen
                     }
                     else
                     {
2 10    ( )( )       if(rb_parkpositioncounter_s < 255)
                       {
                         rb_parkpositioncounter_s++;
                       }
                     }
                     uF_StatusRainsensor_mg . Bit . B7 = 1;                 // Parkposition True
2 11    ( )( )     if (rub_IntermDelayTime > 5)               // clear option for Wiper Started Flag!
                     {
                       rbi_WiperStarted_g = 0;
                     }
                   }
                   else
                   {
                     rb_LimitMemomryNoWiperReaction_g = 0;
                     rbi_WiperStarted_g = 0;
                     rw_WipeCommandTimOut_mg = 0;               // reset Timout if wiper motor wants not wipe
2 12    ( )( )     if(rb_parkpositioncounter_s>7)             // Parkpositioncounter groesser 8
                     {
                       rbi_WiperStarted_g = 0;
                       uF_StatusRainsensor_mg . Bit . B7 = 0;              // loesche bit fuer Parkposition
                     }
                     else
                     {
                       rb_parkpositioncounter_s++;              // inkrementiere Parkpositionscounter
                     }
                   }
                 }
               }
               /**************************************************************************
                 Syntax   : void  CopyRLSData(void)
                 Object   : CopyRLSData()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Ausgangsdaten des Sensors in den
                 Ausgangsdatenpuffer des Vector Bus Treiber und setzt die internen Daten
                 gemaess SRS um.
               **************************************************************************/
               void CopyRLSData(void)
               {
3 0     ( )    CopyRLSData
                 Check_StartupActiveErrors();
3 1     ( )( ) if((uLinConfirmationFlags . w[0]. b10 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b10 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                 }
3 2     ( )( ) if((uLinConfirmationFlags . w[0]. b9 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b9 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   OutPutHudSendCount();
                 }
3 3     ( )( ) if((uLinConfirmationFlags . w[0]. b8 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b8 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                 }
3 4     ( )( ) if((uLinConfirmationFlags . w[0]. b7 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b7 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   SendRLSMPartNo();
                 }
3 5     ( )( ) if((uLinConfirmationFlags . w[0]. b6 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b6 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                   SendRLSMPartNo10();
                 }
3 6     ( )( ) if((uLinConfirmationFlags . w[0]. b5 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b5 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                   SendRLSSerNo();
                 }
3 7     ( )( ) if(0==uF_Main_Flags_g . Bit . B6)
                 {
3 8     ( )( )   if((0==(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x01)) && (0==((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0)))
                   {
                     /*version error*/
                     (uF_Diagnose_pre_Flag . Bit . B3) = 1;
                   }
                   else
                   {
                     (uF_Diagnose_pre_Flag . Bit . B3) = 0;
                   }
                 }
                 RainFunction();                              //Tunnel wiper,auto wiper,rain level, splash mode, rain sonser error
                 CheckErrors();                               //Other error signals send in this function
                 VoltageDetect();                             //Send high/low voltage error
                 TemperatureDetect();                         //send temperate error
                 LightFunction();                             //light request and the reason of light on                            
                 StandByMode();                               //Auto close window
                 OutPutBrightnessValue();                     //output FW IR SOLAR brightness
                 Humidity_Function();                         //dew point & Screen temperature & sensor teamperature & relative Humidity
                 CopyRLSDataAsic();
                 rb_WDG_BusTaskCounter_g++;                   //increment test counter for bus
               }
               /*0x0£ºOFF "WipgSpd0Rpm";
               0x1£ºLow speed "WipgSpd40Rpm";
               0x2£ºwipe speed "WipgSpd43Rpm";
               0x3£ºwipe speed"WipgSpd46Rpm";
               0x4£ºwipe speed "WipgSpd50Rpm";
               0x5£ºwipe speed "WipgSpd54Rpm";
               0x6£ºwipe speed "WipgSpd57Rpm";
               0x7£ºHigh speed "WipgSpd60Rpm";
               0x8~0xE£ºcurrently not used*/
               void RainFunction(void)
               {
                 static byte rb_OutOffParkCounter_mg;
                 static byte rb_TunnelWipeTimeOut_mg;   
                 unsigned int rw_tunnelWischVerzoegerung_l=(((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv>>4))*100);
                 unsigned int rw_tunnelWischAktivierung_l=(((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv&0x0F))*100);
                 static byte rb_tunnelWipeActive_g;
                 byte newWiperSpeedLin = 0;
4 0     ( )    RainFunction
4 1     ( )( ) if((rb_IgnitionOndelay_mg<50))
                 {
                   rw_rain_intensitiy_g = 0;
                   rw_AfterRSWipeCounter_mg = 50000;
                 }
4 2     ( )( ) if(uF_SCIFlags_mg . Bit . B6 == 0)     
                 {                                            //wiper is running 
4 3     ( )( )   if (rb_OutOffParkCounter_mg > 18) 
                   {
                     rw_AfterWWSWipeCounter_mg = 0;
                   }
                   else
                   {
                     rb_OutOffParkCounter_mg ++;
                   }
                 }
                 else
                 {                                            //wiper in park position
                   rb_OutOffParkCounter_mg = 0;
4 4     ( )( )   if (rw_AfterWWSWipeCounter_mg < 50000)
                   {
                     rw_AfterWWSWipeCounter_mg++;
                   }
                 }
4 5     ( )( ) if (rw_AfterRSWipeCounter_mg < 50000)        //Delay for Tunnel wipe function
                 {
                   rw_AfterRSWipeCounter_mg++;   
                 }
                 /*VCO_260 Tunnel wipe activation and delay according to Tunnel Verzoegerung and Aktivierung parameters*/
                 /*activation of afterwipe at tunnel*/
4 6     ( )( ) if((rw_AfterRSWipeCounterAlt_mg <= rw_tunnelWischVerzoegerung_l)
                    &&(rb_speed_in_kmh_g > 29)
                      &&(uF_modi_lightsens_g . Bit . B2 == 1)
                        &&(rub_RSIntermDelayInit == 0xFF))
                 {
4 7     ( )( )   if ((uF_Communication_mg . Bit . B4 == 0) && (rw_AfterRSWipeCounter_mg < rw_tunnelWischAktivierung_l))
                   {
                     rb_tunnelWipeActive_g = 1;
                   }
                 }
                 else
                 {
                   rb_tunnelWipeActive_g = 0;
                 }
                 /*trigger the afterwipe at tunnel*/
4 8     ( )( ) if((rw_AfterRSWipeCounter_mg >= rw_AfterRSWipeCounterAlt_mg)
                      &&(rb_tunnelWipeActive_g == 1)
                        &&(rb_WiperSpeed_g == 0))
                 {
                   rb_TunnelWipeTimeOut_mg = 0;
                   uF_Communication_mg . Bit . B3 = 1;
                   rb_tunnelWipeActive_g = 0;
                   rw_AfterRSWipeCounterAlt_mg = 50000;
                   rw_AfterRSWipeCounter_mg = 50000;
               	/**********Zhiyuan HU 20190313**************/
4 9     ( )( )   if(CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 != 1)
               	{
               	  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;};   // wiper request
               	}
               	else
               	{
               	  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;};
               	}
               	/**********Zhiyuan HU 20190313**************/
                 }
                 else 
4 10    ( )( )   if(uF_Communication_mg . Bit . B3 == 1)
                 {
4 11    ( )( )     if((uF_StatusRainsensor_mg . Bit . B7 == 0)||(rb_TunnelWipeTimeOut_mg >= 50))
                   {
                     uF_Communication_mg . Bit . B3 = 0;
                     rb_TunnelWipeTimeOut_mg = 0;
                   }
                   else
                   {
                     rb_TunnelWipeTimeOut_mg++;
                   }
               	/**********Zhiyuan HU 20190313**************/
4 12    ( )( )     if(CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 != 1)
               	{
               	  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;};   // wiper request
               	}
               	else
               	{
               	  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;};
               	}
               	/**********Zhiyuan HU 20190313**************/
                 }
                 else
                 {
4 13    ( )( )     if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1 == 1)
                   {
4 14    ( )( )       if((rb_WiperSpeed_g != 0) &&(rb_WipeWorkStatus_mg == 1))
                     {
4 15    ( )( )         if ((RSStatus . Bit . B5==0)&&(RSStatus . Bit . B6==0))
                       {
                          newWiperSpeedLin = 1; //interval         
                       }
                       else
                       {
                          newWiperSpeedLin = rb_WiperSpeed_g;        
                       }  
                     }
                     else
                     {
                       newWiperSpeedLin = 0;
                     } 
                   }    
               	/**********Zhiyuan HU 20190313**************/
4 16    ( )( )     if(CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 != 1)
               	{
               	  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = newWiperSpeedLin;};   // wiper request
               	}
               	else
               	{
               	  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;};
               	}
               	/**********Zhiyuan HU 20190313**************/
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;}; 
4 17    ( )( )     if(rb_WiperSpeed_g >0)
                   {
4 18    ( )( )       if(rb_WiperSpeedAlt_g == 0)
                     {
                       rw_AfterRSWipeCounterAlt_mg = rw_AfterRSWipeCounter_mg;
                     }
                     rw_AfterRSWipeCounter_mg = 0;
                   }     
                 } 
                 rb_WiperSpeedAlt_g = rb_WiperSpeed_g;
                 uF_Communication_mg . Bit . B4 = uF_modi_lightsens_g . Bit . B2;  
               }
               void LightFunction(void)
               {
                 byte rb_AnyErrorCounterDebounce_l; 
                 byte rb_TempLightOn_l;
                 byte rb_OpModeState = 0;
                 byte rb_crc_StsOutdBriSts = 0;
                /* PRQA S 3415, 4112 1 */ /* << Getter functions must not have side effects >>*/
5 0     ( )    LightFunction
5 1     ( )( ) if ((((((( (rw_SPINoCommCounter_g>0)||(get_rb_LightVetoCounter_g()>0)|| (get_rb_LightSignalErrorCnt_g()>0)|| (rb_ASIC_SPI_ErrorCodeCnt_g>0)||(rb_StaticNoValidAD_cnt_g>0)|| (get_rb_VDD_LightSignalErrorCnt_g()>0)||(get_rb_LEDx_LStop_error_cnt_g()>0)|| (rb_ClockFreq_Error_cnt_g>0) || (rb_ASIC_ALSx_ShortDetected_cnt_g!=0) || (rb_ASIC_initTimeout_g > 0) || (rb_VIref_ErrCnt_g>0) )) > 0))||(rb_Err_State_Light_Sens_mg > 0))||(((uF_VoltageStatus_g . Bit . B0) == 1))
                      || ((uF_VoltageStatus_g . Bit . B3) == 1)))
                 {
                   rb_AnyErrorCounterDebounce_mg = 250;
                 }
                 else
                 {
5 2     ( )( )   if (rb_AnyErrorCounterDebounce_mg > 0)
                   {
                     rb_AnyErrorCounterDebounce_mg -- ;
                   }
                 }
                 rb_AnyErrorCounterDebounce_l = rb_AnyErrorCounterDebounce_mg; 
                                                                                                                                          /**The conditions for lamp on**/
5 3     ( )( ) if(rb_Err_State_Light_Sens_mg == 1)                                                                               //sensor in error
                 {
                    // SWRS3  95106 v3 Failure to detect ambient light data, or to provide a reliable status (Day or Night) after initialization, 
                    // shall result in the sensor setting the value to 'Invalid'.
                    rb_TempLightOn_l = 3;  
                 }
                 else 
5 4     ( )( )   if(((uF_modi_lightsens_g.AllBit & 0x2F)>0)||(uF_Main_Flags_g . Bit . B7 > 0)||((uF_LightInternalStatus_g . Bit . B6) !=0)) //darkness/darkstart/tunnel
                 {
                   rb_TempLightOn_l = 1;
                 }
                 /*VDR_129 use Sensitivity Treatment*/
                 else 
5 5     ( )( )     if((((((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x01)>0)==1))&& ((uF_LightInternalStatus_g . Bit . B4) == 1))                                        //highway/rain
                         ||(((uF_modi_lightsens_g . Bit . B4 == 1)&& (((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x02)>0) == 1))))
                 {
                   rb_TempLightOn_l = 1;
                 }
                 else
                 { /* PRQA S 3415 1 */ /* << Swapping expressions not feasible for performance >>*/
5 6     ( )( )       if ((rb_AnyErrorCounterDebounce_l ==0)&&(get_rb_LightVetoCounter_g()==0)) /*VCO_093 use Veto of Lightsensor*/
                   {
                     rb_TempLightOn_l = 2;
                   }
                   else
                   {
                     rb_TempLightOn_l = RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1;                                                               /* stay in old light mode and do */
                   }
                 }
                                                                                                                                        /**Send lamp on command**/
5 7     ( )( ) if((uF_Main_Flags_g . Bit . B6 == 0)
                     && ((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x8A )||(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x98)))
                 {
                   /*Incase of only Feuchte and solar frame preset then set the light ON, FW and IR to init value for safety reason*/
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;};   
                 } 
                 else
                 {
                   /* PRQA S 434, 436, 781 7 */ /* <<usind Micro Controller specific command > */
                   MK2L_bit . no4 = 1U;;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;};                                                                    // Turn Light on = TRUE
                   MK2L_bit . no4 = 0U;;
                 } 
                  rb_crc_StsOutdBriSts =  GetOutdBriStsCrcj1850(rb_TempLightOn_l);
                  {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriChks_CEM_LIN1 = rb_crc_StsOutdBriSts;};
5 8     ( )( ) if((((uF_LightInternalStatus_g . Bit . B0) == 1) && (uF_Main_Flags_g . Bit . B6 == 0)) && (rb_TempLightOn_l>0))
                  {
5 9     ( )( )   if((uF_modi_lightsens_g . Bit . B4 == 1)&& (((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x02)>0) == 1))
                     {   
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 1;};
                     }
                     else
                     {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 0;};
                     }
                  }
                  else
                  {
                      {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 0;};
                  }
                 switch (uF_modi_lightsens_g.AllBit & 0x0F)   //Switch Lightsensor Mode
                 {
5 10    ( )      case (byte) 1 :              //Case Darkstartmode
                     rb_OpModeState = 0x02;
                     break;
5 11    ( )      case (byte) 0 :                    //Case Daymode
                     rb_OpModeState = 0x01;
                     break;
5 12    ( )      case (byte) 2 :                 // Case Nightmode
                     rb_OpModeState = 0x00;
                     break;
5 13    ( )      case (byte) 4 :               // Case Tunnelmode
                     rb_OpModeState = 0x03;
                     break;
5 14    ( )      default:
                     rb_OpModeState = 0x00 ;
                     break;
                 }
                 {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . LiOprnMod_CEM_LIN1 = rb_OpModeState;}; 
               }
               void Humidity_Function(void)
               {
                 //static word rw_Temperature_Sensor_g;
                 static unsigned int rw_Temperature_Scheibe_g;
6 0     ( )    Humidity_Function
6 1     ( )( ) if (rbi_HumTempComError_g != 0)
                 {
6 2     ( )( )   if(((rbi_HumTempComError_g&0x08) == 0x08) && ((rbi_HumTempComError_g&0x10) == 0x10))
                   {
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 1;};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;};
                   } 
                   else 
6 3     ( )( )     if((rbi_HumTempComError_g&0x08) == 0x08)
                   {
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 0;};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;};
                   }
                   else 
6 4     ( )( )       if((rbi_HumTempComError_g&0x10) == 0x10)
                   {
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 1;};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 0;};;
                   }
                   else
                   {
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 1;};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;};
                   }
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(1650&0x03)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((1650>>3)&0xff));};      //window temperature   
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 255;};     // relation hum
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)(1650&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)((1650>>8)&0x03));};  //dew point temperature
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 0;};
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 0;};;  
                                                                            /*the temperature of screen ,the range is -40~120*/
6 5     ( )( )   if(rw_Temperature_raw_g < 0x2ad)                         // The temperature less than -40 the tool doesnot support 
                   {
                     rw_Temperature_Scheibe_g = 0x2ad;
                   }
                   else 
6 6     ( )( )     if(rw_Temperature_raw_g > 0x4321)                   // The temperature greater than 120 the tool doesnot support
                   {
                     rw_Temperature_Scheibe_g = 0x4321;    
                   }
                   else
                   {
                     rw_Temperature_Scheibe_g = rw_Temperature_raw_g;
                   }    
6 7     ( )( )   if(rw_Temperature_raw_g == 0)
                   {
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(400&0x03)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((400>>3)&0xff));};
                   }
                   else
                   {
6 8     ( )( )     if(((rw_Temperature_Scheibe_g -685)/10) < 1650)
                     {        
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(((rw_Temperature_Scheibe_g -685)/10)&0x03)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((((rw_Temperature_Scheibe_g -685)/10)>>3)&0xff));};
                     }
                     else
                     {         
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(1650&0x03)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((1650>>3)&0xff));};
                     }
                   } 
6 9     ( )( )   if (rw_DewPoint_g == 0)
                   {
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)(400&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)((400>>8)&0x03));};
                   }    
                   else
                   {
6 10    ( )( )     if (rw_DewPoint_g < (1650) )                /* dew point should be less than or equal to Scheibe temperature */
                     {                                                                       
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)(rw_DewPoint_g&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)((rw_DewPoint_g>>8)&0x03));};        
                     }
                     else
                     {
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)((1650)&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)(((1650)>>8)&0x03));};
                     }
                   }
6 11    ( )( )   if (rb_Humidity_g == 0)                   /* Relative Humidity output*/ /*VCO_061 name hase changed*/
                   {
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 0;};
                   }        
                   else
                   {        
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = rb_Humidity_raw_g;};
                   }
                 }
               }
               void StandByMode(void)
               {
7 0     ( )    StandByMode
7 1     ( )( ) if((rb_Verglasun_ClosedDebounce_mg > 100)||(uF_VoltageStatus_g . Bit . B2== 1)||(rw_CommandCloseWindowTimout_mg > 6000))
                 {
                   uF_SCIFlags_mg . Bit . B4 = 0;
                   uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                 }
7 2     ( )( ) if(uF_SCIFlags_mg . Bit . B0 == 1)
                 {
                   ApplLinInit(0x01);                                  // send wakup frame
                   uF_SCIFlags_mg . Bit . B0 = 0;                      
                 }
7 3     ( )( ) if(uF_SCIFlags_mg . Bit . B4 == 1)               // send close window command
                 {
                    {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 1;}; 
7 4     ( )( )   if (rw_CommandCloseWindowTimout_mg > 6000)          // last for 60s
                   {
                     uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                   }
                   else
                   {
                     rw_CommandCloseWindowTimout_mg++;
                   }
                 }
                 else
                 {
                   rw_CommandCloseWindowTimout_mg = 0;
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 0;};
                 }
               }
               void VoltageDetect(void)
               {
                 static byte rb_underVoltageTimer_s;
8 0     ( )    VoltageDetect
8 1     ( )( ) if(uF_VoltageStatus_g . Bit . B0 == 1)                         //undervoltage, Overvoltage ?
                 {
8 2     ( )( )   if(rb_underVoltageTimer_s>249)                       // undervoltagetimer > 249 -> 2500 ms abwarten
                   {
                     uF_VoltageStatus_g . Bit . B7 = 1;
                   }
                   else
                   {
                     rb_underVoltageTimer_s++;                          // increase undervoltagetimer
                   }
                 }
                 else
                 {
                   rb_underVoltageTimer_s=0;                            // loesche Timer
                   uF_VoltageStatus_g . Bit . B7 = 0;
                 }
8 3     ( )( ) if(uF_VoltageStatus_g . Bit . B0 == 1)
                 {
                     //l_u8_wr_L_Err_State_Volt(rbi_UnderVoltage_g);    //voltage error statue
                 }
                 else 
8 4     ( )( )   if(uF_VoltageStatus_g . Bit . B3 == 1)
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 1;};  //voltage error statue
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 0;};
                 }     
               }
               //SWRS4 89031 v4 Rain Sensor Diagnostics [CS Released]
               // 1 (1050mV - (3.6mV x 65))/3300mV  x 256 =63 ===>90
               // 1. (1050mV - (3.6mV x 70))/3300mV  x 256 =62 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1050mV 
               //2 (1140mV - (3.9mV x 65))/2417mV  x 1024 =485 ===>90
               //2. (1140mV - (3.9mV x 70))/2417mV  x 1024 =367 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1140mV 
               void TemperatureDetect(void)
               {
                 static unsigned int rb_overTemperatureTimer_s;
                 byte rb_temperateOver_l = 0;
9 0     ( )    TemperatureDetect
9 1     ( )( ) if(((rb_InternalTemperature_g > 0) && (rb_InternalTemperature_g < 62))  || ((ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (ras_ASIC_MUX_MeasAD_g[3]. avg < 367)))                        //undervoltage, Overvoltage ?
                 {
9 2     ( )( )   if(rb_overTemperatureTimer_s>10000)                       
                   {
                     rb_temperateOver_l = 1;
                   }
                   else
                   {
                     rb_overTemperatureTimer_s++;                          
                   }
                 }
                 else 
9 3     ( )( )   if(((rb_InternalTemperature_g > 0) && (rb_InternalTemperature_g< 63)) || ((ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (ras_ASIC_MUX_MeasAD_g[3]. avg < 485))) 
                 {
9 4     ( )( )     if(rb_overTemperatureTimer_s>10000)                       
                   {
                     rb_temperateOver_l = 1;//continue on
                   }
                   else
                   {
                     rb_overTemperatureTimer_s=0;                            
                     rb_temperateOver_l = 0;                         
                   }
                 }  
                 else
                 {
                   rb_overTemperatureTimer_s=0;                            
                   rb_temperateOver_l = 0;
                 }
                 // ASIC/MCU temperature detect,when over 95 degree,then set.
                 {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiTDetd_CEM_LIN1 = rb_temperateOver_l;}; 
               }
               void OutPutHudSendCount(void)
               {
                    static byte rb_HUD_Cnt_s = 0;
                    //cnt count 
10 0    ( )    OutPutHudSendCount
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = rb_HUD_Cnt_s;};
10 1    ( )( ) if(rb_HUD_Cnt_s < 15)
                   {
                     rb_HUD_Cnt_s ++;
                   }
                   else
                   {
                     rb_HUD_Cnt_s = 0;
                   }
               }
               void OutPutHudValue(void)
               {
                  byte rb_hud_Crc8_l;
                  unsigned long rl_hud_Brightness_l;
                  unsigned long rl_hud_AMB_Brightness_l;
                  unsigned long rl_hud_FW_Brightness_l; 
                  unsigned long rl_eeprom_hud_max_l = 0;
                  byte rb_hud_Low8Bit_l = 0;
                  unsigned int rw_hud_high9Bit_l  = 0;
                  /*****************Get the Real Lux for FW and AMB  Illuminance = FW*6 + AMB*15 *********************/
11 0    ( )    OutPutHudValue
                   rl_hud_AMB_Brightness_l = 15*((unsigned long)(get_rw_Amb_light16bit_g()));
                   rl_hud_FW_Brightness_l = (unsigned long)((3*((unsigned long)(get_rl_HUD_light32bit_g())))>>1);
                   /*********Pre-Process for original value get average for "rl_HUD_AMB_Brightness" and "rl_HUD_FW_Brightness"*********/
                   /********100ms average for AMB and FW        1000ms for sum average      ******************/
                   GetFiveTableValue_50ms(rl_hud_AMB_Brightness_l,rl_hud_FW_Brightness_l);   
                   /*************5000ms for average output**************/
                   rl_hud_Brightness_l  = CalcHUDMean_1000ms();
                   /***********Output to LIN Interface**************/
                   rl_eeprom_hud_max_l = EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Resolution*EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Value;
11 1    ( )( ) if(rl_hud_Brightness_l >= rl_eeprom_hud_max_l)
                   {
                        rl_hud_Brightness_l = rl_eeprom_hud_max_l;        
                   }
11 2    ( )( ) if(rl_hud_Brightness_l > 126000)//currnet send data  length is shorter
                   {
                      rl_hud_Brightness_l = 126000;
                   } 
                   rb_hud_Low8Bit_l  = (byte)(rl_hud_Brightness_l&0xFF);
                   rw_hud_high9Bit_l = (unsigned int)((rl_hud_Brightness_l>>8)&0x1ff);
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = rb_hud_Low8Bit_l;};
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(rw_hud_high9Bit_l&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((rw_hud_high9Bit_l>>8)&0x1));};
                   //check crc 
                   rb_hud_Crc8_l = GetHudCrcj1850(rl_hud_Brightness_l);
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = rb_hud_Crc8_l;};
                   /*****************end hud info relation  *********************/  
               }
               void OutPutTwliBriValue(void)
               {
                   // AMB 
12 0    ( )    OutPutTwliBriValue
12 1    ( )( ) if(get_rw_Amb_light16bit_g()*20 < 16383)    
                   {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(get_rw_Amb_light16bit_g()*20&0x3F)); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((get_rw_Amb_light16bit_g()*20>>6)&0xFF));};
                   }
                   else
                   {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(16383&0x3F)); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((16383>>6)&0xFF));};
                   } 
               }
               void OutPutSolarValue(void)
               {
                   unsigned int rw_IrLightforSOSE_Corr1_l;
                   unsigned int rw_IrLightforSOSE_Corr2_l;
                   unsigned int rw_SoSe_SunInt_2D_Le_l;
                   unsigned int rw_SoSe_SunInt_2D_Re_l; 
13 0    ( )    OutPutSolarValue
13 1    ( )( ) if ((((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x02)>0) == 1) && (1 == uF_ASIC_ControlFlags_g . Bit . B2))
                   {
13 2    ( )( )   if ((EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ) > 0)
                     {
                       rw_IrLightforSOSE_Corr1_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ); 
                     }
                     else 
                     {
                       rw_IrLightforSOSE_Corr1_l = 0;  
                     }
13 3    ( )( )   if((rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_2_g))
                     {
                       rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr1_l;
                     }
                     else
                     {
                       rw_SoSe_SunInt_2D_Le_l = rw_Solar_light16bit_2_g ;
                     }
13 4    ( )( )   if((rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_1_g))
                     {
                       rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr1_l;
                     }
                     else
                     {
                       rw_SoSe_SunInt_2D_Re_l = rw_Solar_light16bit_1_g ;
                     }    
13 5    ( )( )   if ((EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ) > 0)
                     {
                       rw_IrLightforSOSE_Corr2_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ); 
                     }
                     else 
                     {
                       rw_IrLightforSOSE_Corr2_l = 0;  
                     }
13 6    ( )( )   if((rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Le_l) && (rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Re_l)) 
                     {
                       rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr2_l;
                       rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr2_l;
                     }
                     rw_SoSe_SunInt_2D_Le_l=(rw_SoSe_SunInt_2D_Le_l>>3)*5;
                     rw_SoSe_SunInt_2D_Le_l=((
13 7    ( )( )   rw_SoSe_SunInt_2D_Le_l>240)?240:rw_SoSe_SunInt_2D_Le_l);
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Le_l;};
                     rw_SoSe_SunInt_2D_Re_l=(rw_SoSe_SunInt_2D_Re_l>>3)*5;
                     rw_SoSe_SunInt_2D_Re_l=((
13 8    ( )( )   rw_SoSe_SunInt_2D_Re_l>240)?240:rw_SoSe_SunInt_2D_Re_l);
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Re_l;};       
                   }
                   else
                   {
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;}; 
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;}; 
                   }
               }
               void OutPutBrightnessValue(void)
               {
                 static byte rb_InitLightValCnt_l=100;
14 0    ( )    OutPutBrightnessValue
14 1    ( )( ) if((uF_ASIC_ControlFlags_g . Bit . B1 == 0)|| (uF_Main_Flags_g . Bit . B6 == 1))
                 {
                                                                                        //hold the previous values
14 2    ( )( )   if(rb_InitLightValCnt_l<100)
                   {
                     rb_InitLightValCnt_l++;
                   }
                   else
                   { 
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(0&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((0>>8)&0x1));};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0;};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = 0;};
                      {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(0&0x3F)); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((0>>6)&0xFF));};
                      {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0;};        // Init 
                      {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0;};         // Init
                   }
                 }
                 else
                 {
                   rb_InitLightValCnt_l=0;  
14 3    ( )( )   if(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x98)
                   {
                     /*Incase of only Feuchte and solar frame preset then set the light ON, FW and IR to init value for safety reason*/ 
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(0x1FF&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((0x1FF>>8)&0x1));};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0xFF;};;
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = 0;};
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(16383&0x3F)); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((16383>>6)&0xFF));};
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;};       //Blake_Check Even never run here,but make up is better.                      /* Init*/
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;};                             /* Init*/
                   }
                   else 
14 4    ( )( )     if(rb_Err_State_Light_Sens_mg == 1)                    /*  VDR469   set for error*/
                   {
                                                   // IR Helligkeit Fehler
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(0x1FF&0xff)); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((0x1FF>>8)&0x1));};
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0xFF;};;
                      {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = 0;};
                      {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(16383&0x3F)); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((16383>>6)&0xFF));};
                      {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;};                            /* Init*/
                      {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;};                             /* Init*/
                   }
                   else
                   {  
                        OutPutHudValue(); 
                        OutPutTwliBriValue();
                        OutPutSolarValue();
                   }
                 } 
               }
               #pragma inline=forced
               static void CheckErrors(void)
               {
                 //l_u8_wr_L_Err_State_Cal_RS(1);                                                 //custorm defined, but we do not support
                 //l_u8_wr_L_Err_State_Coding(0);
                 byte rb_hud_errorParity_l = 0;
15 0    ( )    CheckErrors
                 rb_RS_LS_Error1_g = ((uF_Diagnose_pre_Flag . Bit . B1) | 
                                      ((uF_Diagnose_pre_Flag . Bit . B0)<<1) | 
                                        ((uF_Check_lightsensor_g . Bit . B3)<<2) | 
                                          (uF_ASIC_Error_Flags_g . Bit . B3<<3) | 
                                            (uF_ASIC_Ctrl_Error_Flags_g . Bit . B5<<4) | 
                                              (uF_ASIC_Ctrl_Error_Flags_g . Bit . B0<<5) | 
                                                (uF_ASIC_Ctrl_Error_Flags_g . Bit . B1<<6) | 
                                                  (uF_ASIC_Ctrl_Error_Flags_g . Bit . B4<<7));
                 /*VCO_220 VIrefLo/Hi monitoring*/ /*VDR_878*/
                 rb_RS_LS_Error2_g = (uF_ASIC_Ctrl_Error_Flags_g . Bit . B3 | 
                                      ((uF_uC_Error_g . Bit . B1)<<1) | 
                                        (uF_ASIC_Error_Flags_g . Bit . B5<<2) |
                                          (uF_ASIC_Error_Flags_g . Bit . B7<<3) |
                                            (uF_ASIC_Error_Flags1_g . Bit . B0<<4));
                 /*VCO_225 RS functionality detection - error when not available*/
                 rb_RainS_Error1_g = (RSStatus . Bit . B4 | 
                                      (uF_ASIC_Ctrl_Error_Flags_g . Bit . B2<<1) |
                                        (uF_ASIC_Error_Flags_g . Bit . B6<<2)|
                                          ((uF_Diagnose_pre_Flag . Bit . B3)<<3)|
                                            ((uF_uC_Error_g . Bit . B0)<<4));  
                 rb_LightS_Error1_g = ((uF_LightInternalStatus_g . Bit . B5) | 
                                       (rb_ASIC_ALSx_ShortDetected_Error_g<<1) | 
                                         ((uF_Diagnose_pre_Flag . Bit . B2)<<2) | 
                                           (uF_ASIC_Error_Flags_g . Bit . B4<<3)| 
                                             ((uF_Diagnose_pre_Flag . Bit . B4) << 4));
                 /*VCO_224 RS_Error should be set only by RAM/ROM error, when RS function is coded as inactive in kodierbyte0*/
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErrActv_CEM_LIN1 = 1;};  
15 1    ( )( ) if((1==(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x01)) && (0==((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0)))
                 {
                   /* VCO132: SM210 - ASIC Frequency Check (done at startup) - LS,RS_Failure */
                   /* VCO 140: SM150 - ADC test */
                   /* setze Lichtsensor RS-Fehler nach SRS */
                   /*SM240*/
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 = (uF_VoltageStatus_g . Bit . B3 != 0)||(rb_RS_LS_Error1_g != 0)||(rb_RS_LS_Error2_g != 0)||(rb_RainS_Error1_g != 0) ||(uF_E2ConfigErrorFlags_g . Bit . B6 != 0);};
                 }
                 else
                 {
                   /*only RAM/ROM error and RS version error*/
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 = ((rb_RS_LS_Error1_g&0x3) != 0)||(1==(uF_Diagnose_pre_Flag . Bit . B3))||(uF_E2ConfigErrorFlags_g . Bit . B6 != 0);};
                 }
15 2    ( )( ) if(((rb_RS_LS_Error1_g != 0)||(rb_RS_LS_Error2_g != 0)||(rb_LightS_Error1_g != 0)||(uF_E2ConfigErrorFlags_g . Bit . B6 != 0)||(uF_LIN_DiagReq2_mg . Bit . B1)))
                 {
                   rb_Err_State_Light_Sens_mg = 1;
                 }
                 else
                 {
                   rb_Err_State_Light_Sens_mg = 0;
                 }
                 {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrErr_CEM_LIN1 = rb_Err_State_Light_Sens_mg;};
15 3    ( )( ) if(uF_ASIC_Error_Flags_g . Bit . B0 != 0)
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 2;}; //AMB ERROR
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 3;};//NORMAL
                 }
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1 = (uF_ASIC_Error_Flags_g . Bit . B0 != 0) || (uF_ASIC_Error_Flags_g . Bit . B1 != 0);};//AMB and FW error 
                 rb_hud_errorParity_l =IsByteOddParity(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1);
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrParChk_CEM_LIN1 = rb_hud_errorParity_l;};
               }
               void ApplLinInit(byte rb_LIN_State_l)
               {
                 // init unused bits to 1
                 byte rb_Index_l; 
                 static const byte LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};    /* 0x22"RlsmCem_SerNrLin1Fr01_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};    /* 0x18"RlsmCem_Lin1PartNrFr02_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};    /* 0x20"RlsmCem_Lin1PartNrFr01_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};          /* 0x02"RlsmCem_Lin1Fr03_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[8] = {144,1,0,0,0,0,50,0};       /* 0x2C"RlsmCem_Lin1Fr02_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[8] = {0,0,0,1,0,0,0,0};         /* 0x15"RlsmCem_Lin1Fr01_CEM_LIN1" */
16 0    ( )    ApplLinInit
                 rb_Index_l = 0;
                 do
                 {
                   RlsmCem_SerNrLin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1PartNrFr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1PartNrFr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1Fr03_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1Fr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[rb_Index_l];
                   rb_Index_l++;
                 } while (
16 1    ( )( )   rb_Index_l < 8);
                 rw_AfterRSWipeCounter_mg = 50000;
                 rw_AfterRSWipeCounterAlt_mg = 50000;
                 rw_AfterWWSWipeCounter_mg = 50000;                                                      //Direktbitdelay bei Kl15 Aus hochsetzen!
                 sci_init(rb_LIN_State_l);
                 uF_SCIFlags_mg . Bit . B6 = 1;
                 uF_StatusRainsensor_mg . Bit . B7 = 1;
                 rb_PotiStageFromBox_g = 3;  
                 rw_WipeCommandTimOut_mg = 0; 
                 rb_AnyErrorCounterDebounce_mg = 200;  
                 rb_WipeWorkStatus_mg = 1;  
               }
               __callt void ApplLinSlavePreCopy(byte rb_MessageID_l)                                     /* callt function faster */
               {
17 0    ( )    ApplLinSlavePreCopy
17 1    ( )( ) if(rb_MessageID_l == (EEPROM_Struct_PD . EEPROMStructPD . IDRLSs_01 & 0x3F))
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . ErrRespRLSM_CEM_LIN1 = uF_Communication_mg . Bit . B6;};
                   //l_u8_wr_L_Signal_Error(rbi_latched_ResponseError_mg);
                   uF_Communication_mg . Bit . B6 = 0;
                 } 
               }
               /******************************HUD Algrithm shenzhen-team 2018-05-05************************/
               void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_50ms)
               {
                 static unsigned char rb_k_cycleIn50ms=0;
                 static unsigned char rb_k_cycleIn500ms=0;
18 0    ( )    GetFiveTableValue_500ms
                 rb_storeHUDValueEvery500ms[rb_k_cycleIn50ms] = rl_HUD_Brightness_50ms;
                 rb_k_cycleIn50ms++;
18 1    ( )( ) if(rb_k_cycleIn50ms >= 10)
                 {
                   rb_k_cycleIn50ms = 0;
                   orderHUDValue(10);
                   HUDEverageValue[rb_k_cycleIn500ms]=(rb_storeHUDValueEvery500ms[3]+rb_storeHUDValueEvery500ms[4]+rb_storeHUDValueEvery500ms[5]+rb_storeHUDValueEvery500ms[6]+rb_storeHUDValueEvery500ms[7])/5;
                   rb_k_cycleIn500ms++;
18 2    ( )( )   if(rb_k_cycleIn500ms >= 2)
                   {
                     rb_k_cycleIn500ms=0;  
                     rb_hud_data_update = 1;
                   }    
                 }
               }
               unsigned long  AdjustOutHudValue(unsigned long rl_CurrentHud)
               {
                   int currLevel = 0;
                   int rw_LastCurrDiff = 0;
                   unsigned long  rl_adjustAfterHud=0;
19 0    ( )    AdjustOutHudValue
19 1    ( )( ) if(rl_CurrentHud >= 100)
                   {
                     return rl_CurrentHud;
                   }
                   currLevel = RW_Amb_Fw_Result_End/10;  
                   rw_LastCurrDiff = rl_CurrentHud -RW_Amb_Fw_Result_End;
19 2    ( )( ) if(rw_LastCurrDiff >=-15 && rw_LastCurrDiff <=15)// less than 15 is 
                   {
                       return  rl_CurrentHud;
                   }
                   currLevel = currLevel+rw_LastCurrDiff/15;
                   rw_LastCurrDiff = rw_LastCurrDiff%3;
19 3    ( )( ) if(currLevel < 0)
                   {   
                     rl_adjustAfterHud = 5+rw_LastCurrDiff;
                   }
                   else 
19 4    ( )( )   if(currLevel > 9)
                   {
                     rl_adjustAfterHud = 92+rw_LastCurrDiff;
                   }
                   else
                   {
                     rl_adjustAfterHud = 5+currLevel*10+rw_LastCurrDiff;
                   }
                   return  rl_adjustAfterHud;    
               }
               unsigned char GetUpdateTimeForLightStatus(void)
               {
                  unsigned char  hud_refresh_time = 1;  
                   //1 in tunnel and day for 1s  get data;in night and darkstart for 3s  get data 
                   //2 if in tunnel and speed less 10,then 3s will upate
20 0    ( )    GetUpdateTimeForLightStatus
20 1    ( )( ) if(((uF_LightInternalStatus_g . Bit . B0) == 1) && (uF_Main_Flags_g . Bit . B6 == 0))
                  {
20 2    ( )( )   if(uF_modi_lightsens_g.AllBit & (byte) 2)
                       {
                          hud_refresh_time = 3;
                       }
                       else 
20 3    ( )( )     if (uF_modi_lightsens_g.AllBit & (byte) 4)
                       {
20 4    ( )( )       if(rb_speed_in_kmh_g >= 10)
                         {
                           hud_refresh_time = 1;
                         }
                         else
                         {
                           hud_refresh_time = 3;
                         }   
                       }
                       else 
20 5    ( )( )       if (uF_modi_lightsens_g.AllBit & (byte) 1)
                       {
                         hud_refresh_time = 3;
                       }
                       else
                       {
                         hud_refresh_time = 1;  
                       }
                   }
                   else
                   {
                      hud_refresh_time = 1;  
                   }  
                   return  hud_refresh_time;
               }
               unsigned long CalcHUDMean_1000ms(void)
               {  
                   unsigned long  rl_current_hud_lux = 0;
                   unsigned char  rb_hud_refresh_time = 1;
21 0    ( )    CalcHUDMean_1000ms
21 1    ( )( ) if(rb_hud_data_update == 1)
                   {
                     rb_hud_data_update = 0;
                     rb_hud_refresh_time = GetUpdateTimeForLightStatus();
21 2    ( )( )   if(RW_Update_Time_Count < rb_hud_refresh_time)
                     {
                       RW_Update_Time_Count++;
                       rl_current_hud_lux = (HUDEverageValue[0] + HUDEverageValue[1])/2; 
21 3    ( )( )     if((rl_current_hud_lux < 100) && (RW_Amb_Fw_Result_End < 100))
                       {        
                            rl_current_hud_lux = (RW_Amb_Fw_Result_End +rl_current_hud_lux)/2;
                       }
                     }
21 4    ( )( )   if(rb_hud_refresh_time == RW_Update_Time_Count)//refresh time is reached
                     {   
                        RW_Update_Time_Count = 0;         
                        RW_Amb_Fw_Result_End = AdjustOutHudValue(rl_current_hud_lux);        
                     }   
                   }
                   return RW_Amb_Fw_Result_End;//((HUDEverageValue[0] + HUDEverageValue[1])/2);// + HUDEverageValue[2] + HUDEverageValue[3] + HUDEverageValue[4]) / 5);
               }
               /*****Bubble Sort**********/
               void orderHUDValue(int n)
               {
                 unsigned long rb_temp_l = 0;
                 int i =0;
                 int j = 0;
22 0    ( )    orderHUDValue
22 1    ( )( ) for(i=0;i<n;i++)
22 2    ( )( )   for( j=1;j<n-i;j++)
                 {    
22 3    ( )( )     if(rb_storeHUDValueEvery500ms[j-1]>rb_storeHUDValueEvery500ms[j])
                   {
                     rb_temp_l = rb_storeHUDValueEvery500ms[j];
                     rb_storeHUDValueEvery500ms[j] = rb_storeHUDValueEvery500ms[j-1];
                     rb_storeHUDValueEvery500ms[j-1] = rb_temp_l ;
                   }
                 }
               }
               void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb)
               {
                 static unsigned char rb_k_cycleIn50ms=0;
                 unsigned char rb_count = 0;
23 0    ( )    GetFiveTableValue_50ms
                 rb_storeFW_ValueEvery50ms[rb_k_cycleIn50ms] = Fw;
                 rb_storeAMB_ValueEvery50ms[rb_k_cycleIn50ms] = Amb;
                 rb_k_cycleIn50ms++;
23 1    ( )( ) if(rb_k_cycleIn50ms >= 5)
                 {
                   rb_k_cycleIn50ms = 0;
                   FW_Average_In_50ms = rb_storeFW_ValueEvery50ms[0];
23 2    ( )( )   for(rb_count = 1;rb_count < 5;rb_count++)
                   {
                     FW_Average_In_50ms =(FW_Average_In_50ms+ rb_storeFW_ValueEvery50ms[rb_count])/2;
                   }
                   AMB_Average_In_50ms=rb_storeAMB_ValueEvery50ms[0];
23 3    ( )( )   for(rb_count = 1;rb_count < 5;rb_count++)
                   {
                     AMB_Average_In_50ms =(AMB_Average_In_50ms+ rb_storeAMB_ValueEvery50ms[rb_count])/2;
                   } 
                   FW_Average_In_50ms = (FW_Average_In_50ms_Old+FW_Average_In_50ms)/2 ;
                   AMB_Average_In_50ms = (AMB_Average_In_50ms_Old +AMB_Average_In_50ms)/2; 
                   GetFiveTableValue_500ms(FW_Average_In_50ms + AMB_Average_In_50ms);
                   FW_Average_In_50ms_Old = FW_Average_In_50ms;
                   AMB_Average_In_50ms_Old = AMB_Average_In_50ms;
                  }  
               }
               /******************************************End*********************************************/
               /*byte resultCrcTest = 0;
               void TestCrcJ1850Info(void)
               {
                   byte buffer[4]={0x00,0x00,0x00,0x00};//0x59
                   byte buffer1[3]={0xF2,0x01,0x83};//0x37
                   byte buffer2[4]={0x0F,0xAA,0x00,0x55};//0x79
                   byte buffer3[4]={0x00,0xFF,0x55,0x11};//0xB8
                   byte buffer4[9]={0x33,0x22,0x55,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};//0xcb
                   byte buffer5[3]={0x92,0x6B,0x55};//0x8C
                   byte buffer6[4]={0xFF,0xFF,0xFF,0xFF};//0x74
                   resultCrcTest =  CRC8SAEJ1850(buffer,4); //ok
                   resultCrcTest =  CRC8SAEJ1850(buffer1,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer2,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer3,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer4,9);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer5,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer6,4);//ok
               }*/
               byte CRC8SAEJ1850(byte *u8_data,byte u8_len)
               {
                   byte i, j;
                   byte u8_crc8;
                   byte u8_poly;
24 0    ( )    CRC8SAEJ1850
                   u8_crc8 = 0xFF;
                   u8_poly = 0x1D;
24 1    ( )( ) for (i = 0; i < u8_len; i++)
                   {
                     u8_crc8 ^= u8_data[i];
24 2    ( )( )   for (j = 0; j < 8; j++)
                     {
24 3    ( )( )     if (u8_crc8 & 0x80)
                       {
                         u8_crc8 = (u8_crc8 << 1) ^ u8_poly;
                       }
                       else
                       {
                         u8_crc8 <<= 1;
                       }
                    }
                   }
                   u8_crc8 ^= (byte)0xFF;
                   return u8_crc8;
               }
               byte GetOutdBriStsCrcj1850(byte OutdBriSts)
               {  
                     byte buffer[1];
25 0    ( )    GetOutdBriStsCrcj1850
                     buffer[0] = OutdBriSts;
                     //TestCrcJ1850Info();
                     return CRC8SAEJ1850(buffer,1);  
               }
               byte GetHudCrcj1850(unsigned long hudSrc)
               {     
                     //byte buffer[2];
                     //buffer[0] = hudSrc&0xFF;
                     //buffer[1] = (hudSrc>>8)&0xFF;      
                     //return CRC8SAEJ1850(buffer,2);
               	  /**********Zhiyuan HU 20190313**************/
               	  byte buffer[3];
26 0    ( )    GetHudCrcj1850
                  buffer[0] = hudSrc&0xFF;
               	  buffer[1] = (hudSrc>>8)&0xFF;
               	  buffer[2] = (hudSrc>>16)&0xFF;
               	  return CRC8SAEJ1850(buffer,3);
               	  /**********Zhiyuan HU 20190313**************/
               }
               void GetLightTransmission(byte trans_550nm,byte trans_880nm)
               {
                 byte rb_880nm_Transmission_local_Coding = 0;
                 byte rb_550nm_Transmission_local_Coding = 0;
                 byte rb_550nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 byte rb_880nm_Transmission_local_Coding_outOfRangeFlag = 0;
27 0    ( )    GetLightTransmission
                 rb_550nm_Transmission_local_Coding = (trans_550nm);
                 rb_550nm_Transmission_local_Coding = ((
27 1    ( )( ) (rb_550nm_Transmission_local_Coding > 90) && (rb_550nm_Transmission_local_Coding <= 100))? 90 : rb_550nm_Transmission_local_Coding);
                 rb_880nm_Transmission_local_Coding = (trans_880nm);
                 rb_880nm_Transmission_local_Coding = ((
27 2    ( )( ) (rb_880nm_Transmission_local_Coding > 90) && (rb_880nm_Transmission_local_Coding <= 100))? 90 : rb_880nm_Transmission_local_Coding);
27 3    ( )( ) if((rb_550nm_Transmission_local_Coding >= 15) && (rb_550nm_Transmission_local_Coding <= 90))
                 {
                   rb_550nm_Transmission_local_Coding = ((rb_550nm_Transmission_local_Coding-15) + 2) / 5; 
                   rb_550nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 }
                 else
                 {
                   rb_550nm_Transmission_local_Coding = 0 ; 
                   rb_550nm_Transmission_local_Coding_outOfRangeFlag =1;
                 }
27 4    ( )( ) if((rb_880nm_Transmission_local_Coding >= 15) && (rb_880nm_Transmission_local_Coding <= 90))
                 {
                   rb_880nm_Transmission_local_Coding = ((rb_880nm_Transmission_local_Coding-15) + 2) / 5; 
                   rb_880nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 }
                 else
                 {
                   rb_880nm_Transmission_local_Coding = 0 ;
                   rb_880nm_Transmission_local_Coding_outOfRangeFlag = 1;
                 }
27 5    ( )( ) if(rb_550nm_Transmission_local_Coding_outOfRangeFlag == 1 || rb_880nm_Transmission_local_Coding_outOfRangeFlag == 1)
                 {
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErr_CEM_LIN1 = 1;};    
                 }
                 else
                 {
                    {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErr_CEM_LIN1 = 0;};
                 }
27 6    ( )( ) if(((rb_550nm_Transmission_local_Coding_outOfRangeFlag == 0) && (rb_880nm_Transmission_local_Coding_outOfRangeFlag == 0))
                        && (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte2_g != ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding))
                        && ((uF_Main_Flags_g . Bit . B2 == 0)||(uF_Main_Flags_g . Bit . B1 == 1)))
                 {
                     rab_EEPROM_Bytes_toWrite_g[0] = ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding);
                     rw_EEPROM_Address_to_Write_g = (268); /*set adress to write*/
                     rb_I2C_EEPROM_bytesToWrite_g = 1;         /*set number of bytes to 1*/
                     uF_Main_Flags_g . Bit . B2 = 1;
                     uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               void Get_BCMVehType(byte CarType)
               {
                 static byte rb_VehTypeValueDebounce = 0;
                 byte rb_Kodierbyte1_Update_g ; 
                 byte rb_BaseType ;// 0 to 3 rain config
28 0    ( )    Get_BCMVehType
28 1    ( )( ) if(rb_VehTypeValueDebounce < 20)//if 100MS run once ,2s delay check
                 {
                     rb_VehTypeValueDebounce ++;
                     return ;
                 }
                  /*check if the E2PROM data has been loaded*/
28 2    ( )( ) if(uF_Main_Flags_g . Bit . B6 == 1)
                 {
                   return ;
                 }
                 rb_Kodierbyte1_Update_g = EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte1_g;
                 rb_BaseType  = CarType/4;
28 3    ( )( ) if((rb_BaseType < 4)&& ( ((rb_Kodierbyte1_Update_g & 12)>>2)!= rb_BaseType)&& ((uF_Main_Flags_g . Bit . B2 == 0)||(uF_Main_Flags_g . Bit . B1 == 1)))
                 {
                     rb_Kodierbyte1_Update_g &=0xF3; //Clear 2 and 3 bit
                     rb_Kodierbyte1_Update_g |=(rb_BaseType << 2); //set
                     rab_EEPROM_Bytes_toWrite_g[0] = rb_Kodierbyte1_Update_g;
                     rw_EEPROM_Address_to_Write_g = (268)+1; /*set adress to write*/
                     rb_I2C_EEPROM_bytesToWrite_g = 1;         /*set number of bytes to 1*/
                     uF_Main_Flags_g . Bit . B2 = 1;
                     uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               void Set_BCMLightOffset(byte offset)
               {
                 static byte rb_lightValueDebounce = 0;
                 byte rb_OldSensorLs ;
                 byte rb_Kodierbyte0_Update_g; 
29 0    ( )    Set_BCMLightOffset
29 1    ( )( ) if(rb_lightValueDebounce < 20)//if 100MS run once ,2s delay check
                 {
                     rb_lightValueDebounce ++;
                     return ;
                 }
                 /*check if the E2PROM data has been loaded*/
29 2    ( )( ) if(uF_Main_Flags_g . Bit . B6 == 1)
                 {
                    return ;
                 }
                 rb_OldSensorLs = (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g& 0x38)>>3;
                 rb_Kodierbyte0_Update_g = EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g; 
29 3    ( )( ) if((offset < 8)&& (rb_OldSensorLs != offset)&& ((uF_Main_Flags_g . Bit . B2 == 0)||(uF_Main_Flags_g . Bit . B1 == 1)))
                 {
                     rb_Kodierbyte0_Update_g &=0xC7; 
                     rb_Kodierbyte0_Update_g |=(offset << 3); 
                     rab_EEPROM_Bytes_toWrite_g[0] = rb_Kodierbyte0_Update_g;
                     rw_EEPROM_Address_to_Write_g = (268)+2; 
                     rb_I2C_EEPROM_bytesToWrite_g = 1;         
                     uF_Main_Flags_g . Bit . B2 = 1;
                     uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               void SendRLSSerNo(void)
               {
30 0    ( )    SendRLSSerNo
                   {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(0)]);};
                   {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(1)]);};
                   {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(2)]);};
                   {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr4_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(3)]);};
               }
               void SendRLSMPartNo(void)
               {
31 0    ( )    SendRLSMPartNo
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(0)]);};
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(1)]);};
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(2)]);};
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr4_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(3)]);};
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(5)]);};
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(6)]);};
                   {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(7)]);};
               }
               void SendRLSMPartNo10(void)
               {
32 0    ( )    SendRLSMPartNo10
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(0)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(1)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(2)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(3)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(4)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(5)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(6)]);};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(7)]);};
               }
               /************************************************Winter mode check************************************************/
               /**************************T < 0 degree and Speed is under 5KM/H.*************************************************/
               void WipeWinterModeCheck(void)
               {  
33 0    ( )    WipeWinterModeCheck
33 1    ( )( ) if((rb_speed_in_kmh_g < 5) && (rb_OutsideTemp_mg <= 0))
                 {
                    rb_WipeWorkStatus_mg = 2;
                 }
                 else
                 {
                    rb_WipeWorkStatus_mg = 1;
                 }  
               }
               /*!
                * @brief ÅÐ¶Ïµ±Ç°byteµÄ¼«ÐÔÊÇ·ñÎªÅ¼
                *
                * @param byte£¬ ´ý¼ÆËãÆæÅ¼ÐÔµÄÊý¾Ý.
                * @retval false  byte¼«ÐÔ(º¬1µÄ¸öÊý)ÎªÆæÊý.
                * @retval ture£¬ byte¼«ÐÔ(º¬1µÄ¸öÊý)ÎªÅ¼Êý.
                */
               byte IsByteOddParity(byte data)
               {
                   byte parity = 0;
34 0    ( )    IsByteOddParity
34 1    ( )( ) while (data)
                   {
                       parity = !parity;
                       data &= data - 1;
                   }
                   return !parity;
               }
