               /* PRQA S 3619 EOF */ /* << IAR-Compiler allows whitespaces>> */
               /* PRQA S 3116 EOF */ /* << pragma directives needed, compiler specific>>*/
               /*************************************************************************
                 Company : Valeo Wiper System
                 Project : RLT Sensor, RDN Sensor
                 Component : RLS_LINST.c
                 Documentation reference   : Software Requrement Specification
                 Overview of the component : LIN- Data Link layer
                 Evolution of the component : see PVCS Version control system
                               Initials   date   modification
               *************************************************************************/
               /* History                                                                    */
               /*----------------------------------------------------------------------------*/
               /* Date      VDR_Number     Description                                       */
               /* DD.MM.YY*/
               /*----------------------------------------------------------------------------*/
               /* 05.09.11 VDR_705  PCG  - Send detection of Rain Sensor at any time not only when active */
               /* 31.08.11 VDR_700  PCG  - Set Light Sensitivity "0" like LS "4". Set default to "4" instead of "0" 
                                         - Reorganize signals related to Message CEM_L8_FrP04 */
               /* 13.05.11 VDR_659  PCG  - QA-C                       */
               /* 12.05.11 VDR_634  PCG  - removed changes from 10.May.11 */
               /* 10.05.11 VDR_634  PCG  - set adapterrrainsensacrive failure when no master msg is received */
               /* 24.03.11 VDR_647  FS   - Variable name changed*/ 
               /* 18.03.11 VDR_66   PCG  - RLS_VDR_633 RLS_VOLVO_Y555 the first frame of RSM partnumber is set to 0 at startup */
               /* 17.02.11 VCO_70   PCG  - reduced low limit for WS Transmission due to Blue shade band*/
               /* 15.02.11 VDR_580  PCG  - splash bit no more depending on directmode */
               /* 17.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 04.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 11.08.10 VCO_73   PCG  - Implemented Rain Sensor Sensitivity up to 8 sensitivities. SWRS-RSM-001:Req34v1 */
               /* 06.08.10 VCO_71   PCG  - Implemented Rain Sensor Norm Value: adjust RSM sensitivity when placed on 
               *                            different vehicles. SWRS-RSM-001: Req38v1  */
               /* 06.08.10 VCO_73   PCG  - Implemented VCC Part Number: 31314540. SWRS-RSM-001:Req14v1  */
               /* 05.08.10 VCO_72   PCG  - Implemented Light Sensor Sensitivity: RainSnsrLiSnvty. SWRS-RSM-001:Req51v2  */
               /* 03.08.10 VCO_69   PCG  - Implemented new output signal RainSnsrLiMod. SWRS-RSM-001:Req39v2 */
               /* 03.08.10 VCO_66   PCG  - Implemented CarCode table values according mail 26.03.2010*/
               /* 02.08.10 VCO_67   PCG  - Implemented Rain Sensor active when Terminal_X is set regardless 
               *                            Switch Position. SWRS-RSM-001:Req31v1 */
               /* 02.08.10 VCO_68   PCG  - Implement New message CEM_L8_FrP04. SWRS-RSM-001:Req19v1 */
               /* 30.06.10 VDR_540  FS   - Butterfly Option integrated*/
               /* 10.06.10 VCO_49   FS   - Implement long EEPROM PLUS Logging Issues from 11.June --> Park Position corrected*/
               /* 10.06.10 VCO_59   FS   - Logging files --> Rework ParkPosition Evaluation*/
               /* 26.05.10  VCO_055     AL      reomve debouncing of RAM and ROM error*/
               /* 29.04.10 VDR_473  FS   - QA-C*/
               /* 26.04.10 VCO_48   FS   - Use "AB" Index instead of only "B" of the partnumer within EEPROM*/
               /* 26.04.10 VCO_48   FS   - First Frame of Part number not correct*/
               /* 26.03.10  VCO_48   FS   - Update due to Test Drive
                *                           Park contact has been send to late via LIN
                                        --> Update in this file and trigger on WiperSpeed_Running Signal
                                          - Update internal SCS_Signals, that both ldf can work the same*/
               /* 25.03.10  VCO_44   FS   - Implement strategy for Partnumber Read Out
                *                         - delete some parts of VCO_33
                *                         - Switch Stalk Information dependent from CarCode*/
               /* 11.02.10  VDR_437  FS   - Index of Ford Partnumber from EEPROM included *
                 *                        - Mapping of RainSensorSensitivity not in RAM --> in EEPROM*/
               /* 19.01.10  VDR_414  FS    Update due to Testdrive*/
               /* 23.12.09  VDR_394  FS    REWORK: New CarCode Table to be implemented, Req: Email from 20091218*/
               /* 22.12.09  VDR_362  FS    Rework: Overflow of rb_parkpositioncounter_s MUST have been implemented */
               /* 18.12.09  VDR_403  FS    - rb_FixedCarCode deleted
                *                          - Set Auxillary Variable constantly to ALL-value that Ford Partnumber
                *                            can be received by Master for all CarCodes*/
               /* 19.11.09  VDR_396  FS    RainSensorEnable as required in SRS*/
               /* 17.11.09  VDR_394  FS    Default values windshield and comments*/
               /* 01.10.09  VDR_373  FS    "OneTime or Double Overwiped"*/
               /* 29.09.09  VDR_362  FS    Implement wipe cancelling when 4 seconds wiper has not moved*/
               /* 25.09.09  VDR_368  FS    Requirements from FRSI, SRD, ES and Testcases. See comments in code*/
               /* 28.09.09  VDR_360  FS    RainSensorDisable implementation for Ford*/
               /* 31.07.09  VDR_355  AL    Changes based on results of function test and     *
                          & VDR_356        Review of function from Bosch sensor             */
               /* 16.07.09  VDR_344 FS     Updating complete first version to                *
                                           first release version due to                      *
                                           Ford Meeting in Bietigheim                        */
               /* 28.08.15  VCO_268 SP     Cleanup the LIN modules  */
               /*02.10.2015 VDR_911 SP     HammingErr shld be part of RS_Error/LS_Error and shld not be used for Active Err*/
               /*30.05.2016 VDR_983 NB     Sporadic illegale instruction reset in the startup                              */
               /******************************************************************************/
               /*************************************************************************
               **                   Common and module include-file                     **
               **************************************************************************/
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/DEVICE/ior5f109be.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_projectDefs.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_E2ProjectConfig.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_main.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_lininclude.h"
               /*************************************************************************
               **                   Other files included                               **
               **************************************************************************/
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_io.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_timer.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_Check_sr.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_rainsens.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_diagnose.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_E2Handler.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_flashe2.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/RAIN/G5_rs_task.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_IRlight.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_DippedBeam_sr.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control_sr.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_spi_sr.h"
               #include "C:/BASELINE/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_utilities.h"
               #include "C:/baseline/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0__0006_E3/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_AsicFramesLin.h"
               /*VDR_362 Carry Over Standard Code*/
               /*************************************************************************
               **                   Declaration of local module variables              **
               *************************************************************************/
               //#define cb_HUD_MEASURING_RANGE_1    0x40
               //#define cb_HUD_MEASURING_RANGE_2    0x80
               /* PRQA S 0759 1*//*<< 0759:union needed to reduce RAM usage >>*/
               static volatile Flag uF_StalkInPos_Flags_g;
               /******************************************************************************/
               /*                      Definition of exported variables                      */
               /******************************************************************************/
               /*************************************************************************
               **                   Declaration of local module Macros **
               *************************************************************************/
               static const byte cab_PotistageMapping_mg[8] = {4,5,6,7,3,2,1,0}; /*mapping for potistages!*/
               /*************************************************************************
               **                   Declaration of local module Functions              **
               *************************************************************************/
               static void CheckErrors(void);
               void RainFunction(void);
               void LightFunction(void);
               void Humidity_Function(void);
               void StandByMode(void);
               void VoltageDetect(void);
               void OutPutBrightnessValue(void);
               static byte rb_Verglasun_offenDebounce_mg;
               static byte rb_Verglasun_ClosedDebounce_mg;
               static unsigned int rw_CommandCloseWindowTimout_mg;
               static byte rb_KL15_mg;
               static byte rb_AnyErrorCounterDebounce_mg;
               static unsigned int rw_AfterRSWipeCounter_mg;                   // Time after last wipe from RS
               static unsigned int rw_AfterRSWipeCounterAlt_mg;              //Time to the last wipe from RS
               static unsigned int rw_AfterWWSWipeCounter_mg;                  // Time after last wipe from WWS
               static  unsigned int rw_WipeCommandTimOut_mg;                    //timout for requested wipe
               static  byte rb_IgnitionOndelay_mg = 0;
               static  byte rb_Err_State_Light_Sens_mg =0;// light error
               static  int  rb_OutsideTemp_mg  = 1;
               static  byte rb_WipeWorkStatus_mg = 1;
               /******************For HUD**********************/
               static unsigned long HUDEverageValue[2] = {0,0};//,0,0,0,0,0};
               static unsigned long rb_storeHUDValueEvery500ms[10]={0,0,0,0,0,0,0,0,0,0};
               static unsigned long rb_storeFW_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
               static unsigned long rb_storeAMB_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
               void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_100ms);
               unsigned long CalcHUDMean_1000ms(void);
               void orderHUDValue(int n);
               void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb);
               unsigned long  AdjustOutHudValue(unsigned long rl_CurrentHud);
               unsigned char GetUpdateTimeForLightStatus(void);
               static unsigned long FW_Average_In_50ms = 0;
               static unsigned long AMB_Average_In_50ms = 0;
               static  unsigned long FW_Average_In_50ms_Old = 0;
               static  unsigned long AMB_Average_In_50ms_Old = 0;
               static  unsigned long RW_Amb_Fw_Result_End    = 0;
               static  unsigned char rb_hud_data_update      = 0;
               static  unsigned char RW_Update_Time_Count = 0;
               /********************End***********************/
               byte CRC8SAEJ1850(byte *u8_data,byte u8_len);//crc8saej1850 
               byte GetHudCrcj1850(unsigned long hudSrc);
               byte GetOutdBriStsCrcj1850(byte OutdBriSts);
               void GetLightTransmission(byte trans_550nm,byte trans_880nm);
               void Get_BCMVehType(byte CarType);
               void Set_BCMLightOffset(byte offset);
               void SendRLSSerNo(void);
               void SendRLSMPartNo(void);
               void SendRLSMPartNo10(void);
               void OutPutHudValue(void);
               void OutPutHudSendCount(void);
               void TemperatureDetect(void);
               void WipeWinterModeCheck(void);
               byte IsByteOddParity(byte data);
               /**************************************************************************
                 Syntax   : void  GetLeWWS(void)
                 Object   : GetLeWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Schaltermoduls von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLeWWS(void)
               {
                 static unsigned int rw_IgnitionOffDelay_mg;
                 static byte rb_IntervalOnOndelay_mg;
                 static byte rb_AfterResetCounter_l;
                 byte rb_Empfindlichkeit_LS_l;
                 byte rb_BCM_LightSns;
                /***********************Add the Auto_Close_Window Function in Rain Condition*************************/   
1 0     ( )    GetLeWWS
1 1     ( )( )   if (
1 1.1   ( )( )   CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1== 1)                        //Window Open
                 {
1 2     ( )( )     if (
1 2.1   ( )( )     uF_VoltageStatus_g . Bit . B2 == 0)                                     
                   {
1 3     ( )( )       if (
1 3.1   ( )( )       rb_Verglasun_offenDebounce_mg < 0xff)
                     {
1 4                    rb_Verglasun_offenDebounce_mg ++;
                     }
                   }
1 5                rb_Verglasun_ClosedDebounce_mg = 0;
                 }
                 else 
1 6     ( )( )     if(
1 6.1   ( )( )     CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 0)
                 {
1 7     ( )( )       if (
1 7.1   ( )( )       rb_Verglasun_ClosedDebounce_mg < 0xff)
                   {
1 8                    rb_Verglasun_ClosedDebounce_mg ++;
                   }
1 9                  rb_Verglasun_offenDebounce_mg = 0;
                 }
                 else
                 {
                 }
1 10    ( )( )   if((
1 10.1  ( )( )   uLinIndicationFlags . w[0]. b5 != 0))
                 {
                    {
1 11               uLinIndicationFlags . w[0]. b5 = 0;}
1 12               ;
1 13               uF_SCIFlags_mg . Bit . B1 = 1;
1 14               rb_OutsideTemp_mg =  CemCem_Lin1Fr02_CEM_LIN1 . cemcem_lin1fr02_cem_lin1 . AmbTForVisy_CEM_LIN1;
1 15               WipeWinterModeCheck(); 
                 }
1 16    ( )( )   if((
1 16.1  ( )( )   uLinIndicationFlags . w[0]. b4 != 0))
                 {
                      {
1 17               uLinIndicationFlags . w[0]. b4 = 0;}
1 18               ;
1 19               uF_SCIFlags_mg . Bit . B1 = 1;
                      {
1 20               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErrActv_CEM_LIN1 = 1;}
1 21               ;     
1 22               Get_BCMVehType(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . VehTyp_CEM_LIN1);
1 23               GetLightTransmission(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValFrnt_CEM_LIN1,CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValAmb_CEM_LIN1);
                 }
1 24    ( )( )   if((
1 24.1  ( )( )   uLinIndicationFlags . w[0]. b3 != 0))
                 {
                    {
1 25               uLinIndicationFlags . w[0]. b3 = 0;}
1 26               ;
1 27               uF_SCIFlags_mg . Bit . B1 = 1;
1 28               rb_BCM_LightSns = CemCem_Lin1Fr04_CEM_LIN1 . cemcem_lin1fr04_cem_lin1 . RainSnsrLiThd_CEM_LIN1;
1 29               Set_BCMLightOffset(rb_BCM_LightSns);
                 }
1 30    ( )( )   if( (
1 30.1  ( )( )   uLinIndicationFlags . w[0]. b2 != 0))
                {
                   {
1 31               uLinIndicationFlags . w[0]. b2 = 0;}
1 32               ;
1 33               uF_SCIFlags_mg . Bit . B1 = 1;
                }
1 34    ( )( )   if((
1 34.1  ( )( )   uLinIndicationFlags . w[0]. b1 != 0))
                 { 
                   {
1 35               uLinIndicationFlags . w[0]. b1 = 0;}
1 36               ;
1 37               uF_SCIFlags_mg . Bit . B1 = 1;
1 38    ( )( )     uF_SCIFlags_mg . Bit . B6 = !
1 38.1  ( )( )     CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WiprInWipgAr_CEM_LIN1;        // wiper position
1 39    ( )( )     if (
1 39.1  ( )( )     CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1)                                 /* Washpump activ? 0x5:Front washing*/
                   {
1 40                 RSStatus . Bit . B1 = 1;                                       /* set Washing activ bit */
                   }
                   else 
1 41    ( )( )       if (
1 41.1  ( )( )       uF_StatusRainsensor_mg . Bit . B7 == 1)                                /* In Parkposition ? */
                   {
1 42                   RSStatus . Bit . B1 = 0;                                      /* Clear Washing active bit */
                   }
                   else{}                                                              /*Do nothing, Dummy-else for Misra Check*/
                 }
1 43    ( )( )   if((
1 43.1  ( )( )   uLinIndicationFlags . w[0]. b6 != 0))
                 { 
                   {
1 44               uLinIndicationFlags . w[0]. b6 = 0;}
1 45               ;
1 46               rw_NoCommunicationCounter_g = 0;                                 // reset no communication counter
1 47               uF_SCIFlags_mg . Bit . B1 = 1;                                     // set connected to Master  
1 48               uF_Communication_mg . Bit . B1 = 1;    
1 49               rb_speed_in_kmh_g  = CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . VehSpdForWipg_CEM_LIN1;   
1 50    ( )( )     if(
1 50.1  ( )( )     CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . VehSpdForWipg_CEM_LIN1 == 0xFF)
                   {
1 51                 rb_speed_in_kmh_g = 75;                           /* set speed to (75 km/h)*/
                   }
                   else 
                   {
                   }
1 52    ( )( )     if(
1 52.1  ( )( )     rb_speed_in_kmh_g>=10)
                   {
1 53                 uF_GainAdjustFlags_g . Bit . B1 = 1;
                   }   
1 54    ( )( )     rb_KL15_mg = (
1 54.1  ( )( )     CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WipgPwrActvnSafeWipgPwrAcsyModSafe_CEM_LIN1==2);
                  /* ignore ignition off if speed higher 4km/h*/
1 55    ( )( )     if((
1 55.1  ( )( )     rb_KL15_mg == 1)||(
1 55.2  ( )( )     rb_speed_in_kmh_g > 4)) /*VCO_083*/
                   {
1 56                 uF_VoltageStatus_g . Bit . B2 = 1;
1 57                 rw_StandbyTimeOutCnt_g = 0;
1 58                 rw_IgnitionOffDelay_mg = 0;
1 59    ( )( )       if(
1 59.1  ( )( )       rb_IgnitionOndelay_mg < 250)
                     {
1 60                   rb_IgnitionOndelay_mg++;
                     }
1 61    ( )( )       if((
1 61.1  ( )( )       (
1 62    ( )( ) 
1 62.1  ( )( )       (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0) == 0) &&(
1 61.2  ( )( )       rb_AfterResetCounter_l> 10))
                     {
1 63    ( )( )         if(((
1 63.1  ( )( )         CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 1)&&(
1 63.2  ( )( )         CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1==1))                         //automatic
                           || (
1 63.3  ( )( )         (
1 64    ( )( ) 
1 64.1  ( )( )         (EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x40)>0) != 0))
                       {
1 65                     uF_StatusRainsensor_mg . Bit . B0 = 1;                            /*Rainsensor always active!*/
                       }
                       else
                       {
1 66                     uF_StatusRainsensor_mg . Bit . B0 = 0;                           /*Rainsensor off!*/
                       }
                     }
                     else
                     {
1 67                   uF_StatusRainsensor_mg . Bit . B0 = 0;                             //Rainsensor off!
                     }
1 68    ( )( )       if(
1 68.1  ( )( )       CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1 == 1)                            // copy automatic wiping mode
                     {
1 69    ( )( )         if(
1 69.1  ( )( )         rb_IntervalOnOndelay_mg > 15)                               //debound 150ms when turn the auto wiper on
                       {
1 70                     RSStatus . Bit . B7 = 1;
                       }
                       else
                       {
1 71                     rb_IntervalOnOndelay_mg++;
                       }
                     }
                     else
                     {
1 72                   RSStatus . Bit . B7 = 0;
1 73                   rb_IntervalOnOndelay_mg = 0;
                     }
                   }
                   else
                   {          
1 74                 uF_VoltageStatus_g . Bit . B2 = 0;
1 75                 rw_AfterWWSWipeCounter_mg = 50000;                                //Direktbitdelay bei Kl15 Aus hochsetzen!
1 76                 rw_WipeCommandTimOut_mg = 0;
1 77                 rb_IgnitionOndelay_mg = 0;
1 78                 uF_StatusRainsensor_mg . Bit . B0 = 0;                                //Rainsensor off!
                   }
1 79               rb_LIN_SensitivityShift_g =  7;                                     //adaptation Variable for sensitivity factor
                   rb_PotiStageFromBox_g = (
1 80    ( )( ) 
1 80.1  ( )( )     CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1 >= 7)?3:(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1);
                 }  
                 else                                                                  //keine neue Master Nachricht!
                 {                                                                     // check if system is on -> to switch off 
1 81    ( )( )     if((
1 81.1  ( )( )     rw_NoCommunicationCounter_g > ((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200)))                               /***4S***/
                   {     
1 82    ( )( )       if ((
1 82.1  ( )( )       uF_SCIFlags_mg . Bit . B4 == 0)||( 
1 82.2  ( )( )       uF_ASIC_ControlFlags_g . Bit . B4 == 0))  /*VDR_526*/
                     {
1 83    ( )( )         if ( ((
1 83.1  ( )( )         uF_VoltageStatus_g . Bit . B2== 0)) &&((
1 83.2  ( )( )         rb_Verglasun_offenDebounce_mg > 100) &&
                                                          (
1 83.3  ( )( )         (
1 84    ( )( ) 
1 84.1  ( )( )         (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x04)>0) == 1)) && (
1 83.4  ( )( )         uF_SCIFlags_mg . Bit . B4 == 0) )
                       {
1 85                     uF_ASIC_ControlFlags_g . Bit . B4 = 1;                             // Set Request for Standby Mode
                       }
                       else
                       {
1 86                     uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                       }       
1 87                   uF_SCIFlags_mg . Bit . B2 = 1;                                         // Was Connected to Master
                     }
                     else 
                     {
1 88    ( )( )         if ((
1 88.1  ( )( )         CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1== 0)||(
1 88.2  ( )( )         rw_CommandCloseWindowTimout_mg > 6000))
                       {
1 89                     uF_SCIFlags_mg . Bit . B2 = 1;                                       // no need of Standby mode 
1 90                     uF_ASIC_ControlFlags_g . Bit . B4 = 0;
1 91                     uF_SCIFlags_mg . Bit . B0 = 0;                                /*VDR_526*/
1 92                     uF_SCIFlags_mg . Bit . B4 = 0;                           /*VDR_526*/
1 93                     rb_WakeupCounter_mg = 0; 
                       }
                       else
                       {
1 94    ( )( )           if (
1 94.1  ( )( )           rb_WakeupCounter_mg == 0)                             /*VDR_526*/
                         { 
1 95                       uF_SCIFlags_mg . Bit . B0 = 1; 
                         }
                       }
                     }
1 96                 uF_SCIFlags_mg . Bit . B1 = 0;                                  // clear connected to Master
                   }
                   else
                   {
1 97                 uF_SCIFlags_mg . Bit . B0 = 0;                                    /*VDR_526*/
1 98                 rw_NoCommunicationCounter_g ++;
1 99                 uF_SCIFlags_mg . Bit . B2 = 0;                                          // Was Connected to Master
1 100   ( )( )       if(
1 100.1 ( )( )       rw_NoCommunicationCounter_g >= (((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200) - 3) )
                     {
                                                                                       /*clear marker in the EEPROM to indicate there is a normal sleeep command*/
1 101                  rb_Release_IntervalMarker_Update_g = 0x00;                      //send sleep command to RS
1 102                  uF_StatusRainsensor2_mg . Bit . B3 = 1;                               //indicate if rb_Release_IntervalMarker_g sholud be updated in EEPROM
                     }
                   }
                 }
1 103            rb_Empfindlichkeit_LS_l = 3;
1 104   ( )( )   if(
1 104.1 ( )( )   (cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)>3)
                 {
1 105              rb_LSPotiStage_g = (cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)-3;
1 106   ( )( )     if(
1 106.1 ( )( )     rb_LSPotiStage_g>7)
                   {
1 107                rb_LSPotiStage_g=7;
                   }
                 }
                 else
                 {
1 108              rb_LSPotiStage_g = 0;
                 }
1 109   ( )( )   if (
1 109.1 ( )( )   rb_AfterResetCounter_l<250)
                 {
1 110              rb_AfterResetCounter_l++;                                           /* counts calls of routine to delay activation of rainsensor*/
                 }
1 111   ( )( )   if(
1 111.1 ( )( )   rw_IgnitionOffDelay_mg < 1000)                                     /* 10sec delay */
                 {
1 112              rw_IgnitionOffDelay_mg++;
                 }
                 else
                 {
1 113              rb_Release_IntervalMarker_Update_g |= 0xA0;
1 114              uF_StatusRainsensor2_mg . Bit . B2 = 0;
                 }
               }
               /**************************************************************************
                 Syntax   : void  GetLsWWS(void)
                 Object   : GetLsWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Wischermotorin von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLsWWS(void)
               {  
                 static byte rb_parkpositioncounter_s;
                 /*simulierte Wischzeit bei LSS aus*/
                 static const byte cab_WiperMotorRunntime_mg[8] ={142,142,133,125,117,111,105,100};  
2 0     ( )    GetLsWWS
2 1     ( )( )   if ((
2 1.1   ( )( )   rb_WiperSpeed_g > 0)&&(
2 1.2   ( )( )   uF_SCIFlags_mg . Bit . B6== 1))
                 {    
2 2     ( )( )     if (
2 2.1   ( )( )     rw_WipeCommandTimOut_mg <= 400)
                   {
2 3                  rw_WipeCommandTimOut_mg ++;                // reset Timout if wiper motor wants not wipe
                   }
                   else
                   {
2 4                  rb_LimitMemomryNoWiperReaction_g = 1;
                   }      
                 }
2 5     ( )( )   if(    ((
2 5.1   ( )( )   CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1 == 0)    //NO auto wiper
                      && (
2 5.2   ( )( )   uF_SCIFlags_mg . Bit . B6 == 1))
                      ||(
2 5.3   ( )( )   rw_WipeCommandTimOut_mg > 400))
                 {
2 6     ( )( )     if((
2 6.1   ( )( )     rb_WiperSpeed_g > 0)||(
2 6.2   ( )( )     uF_StatusRainsensor_mg . Bit . B7 == 0))
                   {
2 7     ( )( )       if(
2 7.1   ( )( )       rb_parkpositioncounter_s>10)            // Parkpositioncounter groesser 10
                     {
2 8                    uF_StatusRainsensor_mg . Bit . B7 = 0;              // delete bit for Parkposition
                     }
2 9                  rb_parkpositioncounter_s++;                // increase Parkpositionscounter
                   }
2 10    ( )( )     if(
2 10.1  ( )( )     rb_parkpositioncounter_s > (cab_WiperMotorRunntime_mg[rb_WiperSpeed_g]))
                   {
2 11                 rw_WipeCommandTimOut_mg = 0;
2 12                 uF_StatusRainsensor_mg . Bit . B7 = 1;               
2 13                 rb_parkpositioncounter_s = 0;            
                   }
                 }
                 else    
                 {
2 14    ( )( )     if((
2 14.1  ( )( )     uF_SCIFlags_mg . Bit . B6 == 0)&&(
2 14.2  ( )( )     rb_WiperSpeed_g > 0))
                   {
2 15                 rbi_WiperStarted_g = 1;
                   }
2 16    ( )( )     if(
2 16.1  ( )( )     uF_SCIFlags_mg . Bit . B6 == 1)            // In Parklagensignal ?
                   {
2 17    ( )( )       if(
2 17.1  ( )( )       uF_StatusRainsensor_mg . Bit . B7 == 0)
                     {
2 18                   rb_parkpositioncounter_s=0;              // Parkpositioncounter zuruecksetzen
                     }
                     else
                     {
2 19    ( )( )         if(
2 19.1  ( )( )         rb_parkpositioncounter_s < 255)
                       {
2 20                     rb_parkpositioncounter_s++;
                       }
                     }
2 21                 uF_StatusRainsensor_mg . Bit . B7 = 1;                 // Parkposition True
2 22    ( )( )       if (
2 22.1  ( )( )       rub_IntermDelayTime > 5)               // clear option for Wiper Started Flag!
                     {
2 23                   rbi_WiperStarted_g = 0;
                     }
                   }
                   else
                   {
2 24                 rb_LimitMemomryNoWiperReaction_g = 0;
2 25                 rbi_WiperStarted_g = 0;
2 26                 rw_WipeCommandTimOut_mg = 0;               // reset Timout if wiper motor wants not wipe
2 27    ( )( )       if(
2 27.1  ( )( )       rb_parkpositioncounter_s>7)             // Parkpositioncounter groesser 8
                     {
2 28                   rbi_WiperStarted_g = 0;
2 29                   uF_StatusRainsensor_mg . Bit . B7 = 0;              // loesche bit fuer Parkposition
                     }
                     else
                     {
2 30                   rb_parkpositioncounter_s++;              // inkrementiere Parkpositionscounter
                     }
                   }
                 }
               }
               /**************************************************************************
                 Syntax   : void  CopyRLSData(void)
                 Object   : CopyRLSData()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Ausgangsdaten des Sensors in den
                 Ausgangsdatenpuffer des Vector Bus Treiber und setzt die internen Daten
                 gemaess SRS um.
               **************************************************************************/
               void CopyRLSData(void)
               {
3 0     ( )    CopyRLSData
3 1              Check_StartupActiveErrors();
3 2     ( )( )   if((
3 2.1   ( )( )   uLinConfirmationFlags . w[0]. b10 != 0))
                 {
                   {
3 3                uLinConfirmationFlags . w[0]. b10 = 0;} 
3 4                ;
3 5                uF_SCIFlags_mg . Bit . B1 = 1; 
                 }
3 6     ( )( )   if((
3 6.1   ( )( )   uLinConfirmationFlags . w[0]. b9 != 0))
                 {
                   {
3 7                uLinConfirmationFlags . w[0]. b9 = 0;} 
3 8                ;
3 9                uF_SCIFlags_mg . Bit . B1 = 1;
3 10               OutPutHudSendCount();
                 }
3 11    ( )( )   if((
3 11.1  ( )( )   uLinConfirmationFlags . w[0]. b8 != 0))
                 {
                   {
3 12               uLinConfirmationFlags . w[0]. b8 = 0;} 
3 13               ;
3 14               uF_SCIFlags_mg . Bit . B1 = 1; 
                 }
3 15    ( )( )   if((
3 15.1  ( )( )   uLinConfirmationFlags . w[0]. b7 != 0))
                 {
                   {
3 16               uLinConfirmationFlags . w[0]. b7 = 0;} 
3 17               ;
3 18               uF_SCIFlags_mg . Bit . B1 = 1;
3 19               SendRLSMPartNo();
                 }
3 20    ( )( )   if((
3 20.1  ( )( )   uLinConfirmationFlags . w[0]. b6 != 0))
                 {
                   {
3 21               uLinConfirmationFlags . w[0]. b6 = 0;} 
3 22               ;
3 23               uF_SCIFlags_mg . Bit . B1 = 1; 
3 24               SendRLSMPartNo10();
                 }
3 25    ( )( )   if((
3 25.1  ( )( )   uLinConfirmationFlags . w[0]. b5 != 0))
                 {
                   {
3 26               uLinConfirmationFlags . w[0]. b5 = 0;} 
3 27               ;
3 28               uF_SCIFlags_mg . Bit . B1 = 1; 
3 29               SendRLSSerNo();
                 }
3 30    ( )( )   if(
3 30.1  ( )( )   0==uF_Main_Flags_g . Bit . B6)
                 {
3 31    ( )( )     if((
3 31.1  ( )( )     0==(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x01)) && (
3 31.2  ( )( )     0==(
3 32    ( )( ) 
3 32.1  ( )( )     (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0)))
                   {
                     /*version error*/
3 33                 (uF_Diagnose_pre_Flag . Bit . B3) = 1;
                   }
                   else
                   {
3 34                 (uF_Diagnose_pre_Flag . Bit . B3) = 0;
                   }
                 }
3 35             RainFunction();                              //Tunnel wiper,auto wiper,rain level, splash mode, rain sonser error
3 36             CheckErrors();                               //Other error signals send in this function
3 37             VoltageDetect();                             //Send high/low voltage error
3 38             TemperatureDetect();                         //send temperate error
3 39             LightFunction();                             //light request and the reason of light on                            
3 40             StandByMode();                               //Auto close window
3 41             OutPutBrightnessValue();                     //output FW IR SOLAR brightness
3 42             Humidity_Function();                         //dew point & Screen temperature & sensor teamperature & relative Humidity
3 43             CopyRLSDataAsic();
3 44             rb_WDG_BusTaskCounter_g++;                   //increment test counter for bus
               }
               /*0x0£ºOFF "WipgSpd0Rpm";
               0x1£ºLow speed "WipgSpd40Rpm";
               0x2£ºwipe speed "WipgSpd43Rpm";
               0x3£ºwipe speed"WipgSpd46Rpm";
               0x4£ºwipe speed "WipgSpd50Rpm";
               0x5£ºwipe speed "WipgSpd54Rpm";
               0x6£ºwipe speed "WipgSpd57Rpm";
               0x7£ºHigh speed "WipgSpd60Rpm";
               0x8~0xE£ºcurrently not used*/
               void RainFunction(void)
               {
                 static byte rb_OutOffParkCounter_mg;
                 static byte rb_TunnelWipeTimeOut_mg;   
                 unsigned int rw_tunnelWischVerzoegerung_l=(((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv>>4))*100);
                 unsigned int rw_tunnelWischAktivierung_l=(((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv&0x0F))*100);
                 static byte rb_tunnelWipeActive_g;
                 byte newWiperSpeedLin = 0;
4 0     ( )    RainFunction
4 1     ( )( )   if((
4 1.1   ( )( )   rb_IgnitionOndelay_mg<50))
                 {
4 2                rw_rain_intensitiy_g = 0;
4 3                rw_AfterRSWipeCounter_mg = 50000;
                 }
4 4     ( )( )   if(
4 4.1   ( )( )   uF_SCIFlags_mg . Bit . B6 == 0)     
                 {                                            //wiper is running 
4 5     ( )( )     if (
4 5.1   ( )( )     rb_OutOffParkCounter_mg > 18) 
                   {
4 6                  rw_AfterWWSWipeCounter_mg = 0;
                   }
                   else
                   {
4 7                  rb_OutOffParkCounter_mg ++;
                   }
                 }
                 else
                 {                                            //wiper in park position
4 8                rb_OutOffParkCounter_mg = 0;
4 9     ( )( )     if (
4 9.1   ( )( )     rw_AfterWWSWipeCounter_mg < 50000)
                   {
4 10                 rw_AfterWWSWipeCounter_mg++;
                   }
                 }
4 11    ( )( )   if (
4 11.1  ( )( )   rw_AfterRSWipeCounter_mg < 50000)        //Delay for Tunnel wipe function
                 {
4 12               rw_AfterRSWipeCounter_mg++;   
                 }
                 /*VCO_260 Tunnel wipe activation and delay according to Tunnel Verzoegerung and Aktivierung parameters*/
                 /*activation of afterwipe at tunnel*/
4 13    ( )( )   if((
4 13.1  ( )( )   rw_AfterRSWipeCounterAlt_mg <= rw_tunnelWischVerzoegerung_l)
                    &&(
4 13.2  ( )( )   rb_speed_in_kmh_g > 29)
                      &&(
4 13.3  ( )( )   uF_modi_lightsens_g . Bit . B2 == 1)
                        &&(
4 13.4  ( )( )   rub_RSIntermDelayInit == 0xFF))
                 {
4 14    ( )( )     if ((
4 14.1  ( )( )     uF_Communication_mg . Bit . B4 == 0) && (
4 14.2  ( )( )     rw_AfterRSWipeCounter_mg < rw_tunnelWischAktivierung_l))
                   {
4 15                 rb_tunnelWipeActive_g = 1;
                   }
                 }
                 else
                 {
4 16               rb_tunnelWipeActive_g = 0;
                 }
                 /*trigger the afterwipe at tunnel*/
4 17    ( )( )   if((
4 17.1  ( )( )   rw_AfterRSWipeCounter_mg >= rw_AfterRSWipeCounterAlt_mg)
                      &&(
4 17.2  ( )( )   rb_tunnelWipeActive_g == 1)
                        &&(
4 17.3  ( )( )   rb_WiperSpeed_g == 0))
                 {
4 18               rb_TunnelWipeTimeOut_mg = 0;
4 19               uF_Communication_mg . Bit . B3 = 1;
4 20               rb_tunnelWipeActive_g = 0;
4 21               rw_AfterRSWipeCounterAlt_mg = 50000;
4 22               rw_AfterRSWipeCounter_mg = 50000;
               	/**********Zhiyuan HU 20190313**************/
4 23    ( )( )     if(
4 23.1  ( )( )     CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 != 1)
               	{
               	  {
4 24                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;}
4 25                 ;   // wiper request
               	}
               	else
               	{
               	  {
4 26                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;}
4 27                 ;
               	}
               	/**********Zhiyuan HU 20190313**************/
                 }
                 else 
4 28    ( )( )     if(
4 28.1  ( )( )     uF_Communication_mg . Bit . B3 == 1)
                 {
4 29    ( )( )       if((
4 29.1  ( )( )       uF_StatusRainsensor_mg . Bit . B7 == 0)||(
4 29.2  ( )( )       rb_TunnelWipeTimeOut_mg >= 50))
                   {
4 30                   uF_Communication_mg . Bit . B3 = 0;
4 31                   rb_TunnelWipeTimeOut_mg = 0;
                   }
                   else
                   {
4 32                   rb_TunnelWipeTimeOut_mg++;
                   }
               	/**********Zhiyuan HU 20190313**************/
4 33    ( )( )       if(
4 33.1  ( )( )       CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 != 1)
               	{
               	  {
4 34                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;}
4 35                   ;   // wiper request
               	}
               	else
               	{
               	  {
4 36                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;}
4 37                   ;
               	}
               	/**********Zhiyuan HU 20190313**************/
                 }
                 else
                 {
4 38    ( )( )       if(
4 38.1  ( )( )       CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotFrntLvrCmdSafeLvrInIntlPosn_CEM_LIN1 == 1)
                   {
4 39    ( )( )         if((
4 39.1  ( )( )         rb_WiperSpeed_g != 0) &&(
4 39.2  ( )( )         rb_WipeWorkStatus_mg == 1))
                     {
4 40    ( )( )           if ((
4 40.1  ( )( )           RSStatus . Bit . B5==0)&&(
4 40.2  ( )( )           RSStatus . Bit . B6==0))
                       {
4 41                       newWiperSpeedLin = 1; //interval         
                       }
                       else
                       {
4 42                       newWiperSpeedLin = rb_WiperSpeed_g;        
                       }  
                     }
                     else
                     {
4 43                     newWiperSpeedLin = 0;
                     } 
                   }    
               	/**********Zhiyuan HU 20190313**************/
4 44    ( )( )       if(
4 44.1  ( )( )       CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 != 1)
               	{
               	  {
4 45                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = newWiperSpeedLin;}
4 46                   ;   // wiper request
               	}
               	else
               	{
               	  {
4 47                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;}
4 48                   ;
               	}
               	/**********Zhiyuan HU 20190313**************/
                   {
4 49                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;}
4 50                 ; 
4 51    ( )( )       if(
4 51.1  ( )( )       rb_WiperSpeed_g >0)
                   {
4 52    ( )( )         if(
4 52.1  ( )( )         rb_WiperSpeedAlt_g == 0)
                     {
4 53                     rw_AfterRSWipeCounterAlt_mg = rw_AfterRSWipeCounter_mg;
                     }
4 54                   rw_AfterRSWipeCounter_mg = 0;
                   }     
                 } 
4 55             rb_WiperSpeedAlt_g = rb_WiperSpeed_g;
4 56             uF_Communication_mg . Bit . B4 = uF_modi_lightsens_g . Bit . B2;  
               }
               void LightFunction(void)
               {
                 byte rb_AnyErrorCounterDebounce_l; 
                 byte rb_TempLightOn_l;
                 byte rb_OpModeState = 0;
                 byte rb_crc_StsOutdBriSts = 0;
                /* PRQA S 3415, 4112 1 */ /* << Getter functions must not have side effects >>*/
5 0     ( )    LightFunction
5 1     ( )( )   if (((((
5 1.1   ( )( )   (( 
5 2     ( )( )   (
5 2.1   ( )( )   rw_SPINoCommCounter_g>0)||(
5 2.2   ( )( )   get_rb_LightVetoCounter_g()>0)|| (
5 2.3   ( )( )   get_rb_LightSignalErrorCnt_g()>0)|| (
5 2.4   ( )( )   rb_ASIC_SPI_ErrorCodeCnt_g>0)||(
5 2.5   ( )( )   rb_StaticNoValidAD_cnt_g>0)|| (
5 2.6   ( )( )   get_rb_VDD_LightSignalErrorCnt_g()>0)||(
5 2.7   ( )( )   get_rb_LEDx_LStop_error_cnt_g()>0)|| (
5 2.8   ( )( )   rb_ClockFreq_Error_cnt_g>0) || (
5 2.9   ( )( )   rb_ASIC_ALSx_ShortDetected_cnt_g!=0) || (
5 2.10  ( )( )   rb_ASIC_initTimeout_g > 0) || (
5 2.11  ( )( )   rb_VIref_ErrCnt_g>0) )) > 0))||(
5 1.2   ( )( )   rb_Err_State_Light_Sens_mg > 0))||((
5 1.3   ( )( )   (uF_VoltageStatus_g . Bit . B0) == 1))
                      || (
5 1.4   ( )( )   (uF_VoltageStatus_g . Bit . B3) == 1)))
                 {
5 3                rb_AnyErrorCounterDebounce_mg = 250;
                 }
                 else
                 {
5 4     ( )( )     if (
5 4.1   ( )( )     rb_AnyErrorCounterDebounce_mg > 0)
                   {
5 5                  rb_AnyErrorCounterDebounce_mg -- ;
                   }
                 }
5 6              rb_AnyErrorCounterDebounce_l = rb_AnyErrorCounterDebounce_mg; 
                                                                                                                                          /**The conditions for lamp on**/
5 7     ( )( )   if(
5 7.1   ( )( )   rb_Err_State_Light_Sens_mg == 1)                                                                               //sensor in error
                 {
                    // SWRS3  95106 v3 Failure to detect ambient light data, or to provide a reliable status (Day or Night) after initialization, 
                    // shall result in the sensor setting the value to 'Invalid'.
5 8                rb_TempLightOn_l = 3;  
                 }
                 else 
5 9     ( )( )     if((
5 9.1   ( )( )     (uF_modi_lightsens_g.AllBit & 0x2F)>0)||(
5 9.2   ( )( )     uF_Main_Flags_g . Bit . B7 > 0)||(
5 9.3   ( )( )     (uF_LightInternalStatus_g . Bit . B6) !=0)) //darkness/darkstart/tunnel
                 {
5 10                 rb_TempLightOn_l = 1;
                 }
                 /*VDR_129 use Sensitivity Treatment*/
                 else 
5 11    ( )( )       if((((
5 11.1  ( )( )       (
5 12    ( )( ) 
5 12.1  ( )( )       (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x01)>0)==1))&& (
5 11.2  ( )( )       (uF_LightInternalStatus_g . Bit . B4) == 1))                                        //highway/rain
                         ||(((
5 11.3  ( )( )       uF_modi_lightsens_g . Bit . B4 == 1)&& (
5 11.4  ( )( )       (
5 13    ( )( ) 
5 13.1  ( )( )       (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x02)>0) == 1))))
                 {
5 14                   rb_TempLightOn_l = 1;
                 }
                 else
                 { /* PRQA S 3415 1 */ /* << Swapping expressions not feasible for performance >>*/
5 15    ( )( )         if ((
5 15.1  ( )( )         rb_AnyErrorCounterDebounce_l ==0)&&(
5 15.2  ( )( )         get_rb_LightVetoCounter_g()==0)) /*VCO_093 use Veto of Lightsensor*/
                   {
5 16                     rb_TempLightOn_l = 2;
                   }
                   else
                   {
5 17                     rb_TempLightOn_l = RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1;                                                               /* stay in old light mode and do */
                   }
                 }
                                                                                                                                        /**Send lamp on command**/
5 18    ( )( )   if((
5 18.1  ( )( )   uF_Main_Flags_g . Bit . B6 == 0)
                     && ((
5 18.2  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x8A )||(
5 18.3  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x98)))
                 {
                   /*Incase of only Feuchte and solar frame preset then set the light ON, FW and IR to init value for safety reason*/
                   {
5 19               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;}
5 20               ;   
                 } 
                 else
                 {
                   /* PRQA S 434, 436, 781 7 */ /* <<usind Micro Controller specific command > */
5 21               MK2L_bit . no4 = 1U;
5 22               ;
                   {
5 23               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;}
5 24               ;                                                                    // Turn Light on = TRUE
5 25               MK2L_bit . no4 = 0U;
5 26               ;
                 } 
5 27             rb_crc_StsOutdBriSts =  GetOutdBriStsCrcj1850(rb_TempLightOn_l);
                  {
5 28             RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriChks_CEM_LIN1 = rb_crc_StsOutdBriSts;}
5 29             ;
5 30    ( )( )   if(((
5 30.1  ( )( )   (uF_LightInternalStatus_g . Bit . B0) == 1) && (
5 30.2  ( )( )   uF_Main_Flags_g . Bit . B6 == 0)) && (
5 30.3  ( )( )   rb_TempLightOn_l>0))
                  {
5 31    ( )( )     if((
5 31.1  ( )( )     uF_modi_lightsens_g . Bit . B4 == 1)&& (
5 31.2  ( )( )     (
5 32    ( )( ) 
5 32.1  ( )( )     (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x02)>0) == 1))
                     {   
                       {
5 33                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 1;}
5 34                 ;
                     }
                     else
                     {
                       {
5 35                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 0;}
5 36                 ;
                     }
                  }
                  else
                  {
                      {
5 37               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 0;}
5 38               ;
                  }
5 39             switch (uF_modi_lightsens_g.AllBit & 0x0F)   //Switch Lightsensor Mode
                 {
5 40    ( )        case (byte) 1 :              //Case Darkstartmode
5 41                 rb_OpModeState = 0x02;
5 42                 break;
5 43    ( )        case (byte) 0 :                    //Case Daymode
5 44                 rb_OpModeState = 0x01;
5 45                 break;
5 46    ( )        case (byte) 2 :                 // Case Nightmode
5 47                 rb_OpModeState = 0x00;
5 48                 break;
5 49    ( )        case (byte) 4 :               // Case Tunnelmode
5 50                 rb_OpModeState = 0x03;
5 51                 break;
5 52    ( )        default:
5 53                 rb_OpModeState = 0x00 ;
5 54                 break;
                 }
                 {
5 55             RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . LiOprnMod_CEM_LIN1 = rb_OpModeState;}
5 56             ; 
               }
               void Humidity_Function(void)
               {
                 //static word rw_Temperature_Sensor_g;
                 static unsigned int rw_Temperature_Scheibe_g;
6 0     ( )    Humidity_Function
6 1     ( )( )   if (
6 1.1   ( )( )   rbi_HumTempComError_g != 0)
                 {
6 2     ( )( )     if((
6 2.1   ( )( )     (rbi_HumTempComError_g&0x08) == 0x08) && (
6 2.2   ( )( )     (rbi_HumTempComError_g&0x10) == 0x10))
                   {
                      {
6 3                  RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 1;}
6 4                  ;
                      {
6 5                  RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;}
6 6                  ;
                   } 
                   else 
6 7     ( )( )       if(
6 7.1   ( )( )       (rbi_HumTempComError_g&0x08) == 0x08)
                   {
                      {
6 8                    RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 0;}
6 9                    ;
                      {
6 10                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;}
6 11                   ;
                   }
                   else 
6 12    ( )( )         if(
6 12.1  ( )( )         (rbi_HumTempComError_g&0x10) == 0x10)
                   {
                      {
6 13                     RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 1;}
6 14                     ;
                      {
6 15                     RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 0;}
6 16                     ;
6 17                     ;
                   }
                   else
                   {
                      {
6 18                     RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 1;}
6 19                     ;
                      {
6 20                     RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;}
6 21                     ;
                   }
                   {
6 22               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(1650&0x03)); 
6 23               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((1650>>3)&0xff));}
6 24               ;      //window temperature   
                   {
6 25               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 255;}
6 26               ;     // relation hum
                   {
6 27               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)(1650&0xff)); 
6 28               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)((1650>>8)&0x03));}
6 29               ;  //dew point temperature
                 }
                 else
                 {
                   {
6 30               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindTErr_CEM_LIN1 = 0;}
6 31               ;
                   {
6 32               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 0;}
6 33               ;
6 34               ;  
                                                                            /*the temperature of screen ,the range is -40~120*/
6 35    ( )( )     if(
6 35.1  ( )( )     rw_Temperature_raw_g < 0x2ad)                         // The temperature less than -40 the tool doesnot support 
                   {
6 36                 rw_Temperature_Scheibe_g = 0x2ad;
                   }
                   else 
6 37    ( )( )       if(
6 37.1  ( )( )       rw_Temperature_raw_g > 0x4321)                   // The temperature greater than 120 the tool doesnot support
                   {
6 38                   rw_Temperature_Scheibe_g = 0x4321;    
                   }
                   else
                   {
6 39                   rw_Temperature_Scheibe_g = rw_Temperature_raw_g;
                   }    
6 40    ( )( )     if(
6 40.1  ( )( )     rw_Temperature_raw_g == 0)
                   {
                     {
6 41                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(400&0x03)); 
6 42                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((400>>3)&0xff));}
6 43                 ;
                   }
                   else
                   {
6 44    ( )( )       if(
6 44.1  ( )( )       ((rw_Temperature_Scheibe_g -685)/10) < 1650)
                     {        
                       {
6 45                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(((rw_Temperature_Scheibe_g -685)/10)&0x03)); 
6 46                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((((rw_Temperature_Scheibe_g -685)/10)>>3)&0xff));}
6 47                   ;
                     }
                     else
                     {         
                       {
6 48                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = ((canuint8)(1650&0x03)); 
6 49                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((canuint8)((1650>>3)&0xff));}
6 50                   ;
                     }
                   } 
6 51    ( )( )     if (
6 51.1  ( )( )     rw_DewPoint_g == 0)
                   {
                      {
6 52                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)(400&0xff)); 
6 53                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)((400>>8)&0x03));}
6 54                 ;
                   }    
                   else
                   {
6 55    ( )( )       if (
6 55.1  ( )( )       rw_DewPoint_g < (1650) )                /* dew point should be less than or equal to Scheibe temperature */
                     {                                                                       
                       {
6 56                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)(rw_DewPoint_g&0xff)); 
6 57                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)((rw_DewPoint_g>>8)&0x03));}
6 58                   ;        
                     }
                     else
                     {
                       {
6 59                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((canuint8)((1650)&0xff)); 
6 60                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((canuint8)(((1650)>>8)&0x03));}
6 61                   ;
                     }
                   }
6 62    ( )( )     if (
6 62.1  ( )( )     rb_Humidity_g == 0)                   /* Relative Humidity output*/ /*VCO_061 name hase changed*/
                   {
                     {
6 63                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 0;}
6 64                 ;
                   }        
                   else
                   {        
                     {
6 65                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = rb_Humidity_raw_g;}
6 66                 ;
                   }
                 }
               }
               void StandByMode(void)
               {
7 0     ( )    StandByMode
7 1     ( )( )   if((
7 1.1   ( )( )   rb_Verglasun_ClosedDebounce_mg > 100)||(
7 1.2   ( )( )   uF_VoltageStatus_g . Bit . B2== 1)||(
7 1.3   ( )( )   rw_CommandCloseWindowTimout_mg > 6000))
                 {
7 2                uF_SCIFlags_mg . Bit . B4 = 0;
7 3                uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                 }
7 4     ( )( )   if(
7 4.1   ( )( )   uF_SCIFlags_mg . Bit . B0 == 1)
                 {
7 5                ApplLinInit(0x01);                                  // send wakup frame
7 6                uF_SCIFlags_mg . Bit . B0 = 0;                      
                 }
7 7     ( )( )   if(
7 7.1   ( )( )   uF_SCIFlags_mg . Bit . B4 == 1)               // send close window command
                 {
                    {
7 8                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 1;}
7 9                ; 
7 10    ( )( )     if (
7 10.1  ( )( )     rw_CommandCloseWindowTimout_mg > 6000)          // last for 60s
                   {
7 11                 uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                   }
                   else
                   {
7 12                 rw_CommandCloseWindowTimout_mg++;
                   }
                 }
                 else
                 {
7 13               rw_CommandCloseWindowTimout_mg = 0;
                   {
7 14               RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 0;}
7 15               ;
                 }
               }
               void VoltageDetect(void)
               {
                 static byte rb_underVoltageTimer_s;
8 0     ( )    VoltageDetect
8 1     ( )( )   if(
8 1.1   ( )( )   uF_VoltageStatus_g . Bit . B0 == 1)                         //undervoltage, Overvoltage ?
                 {
8 2     ( )( )     if(
8 2.1   ( )( )     rb_underVoltageTimer_s>249)                       // undervoltagetimer > 249 -> 2500 ms abwarten
                   {
8 3                  uF_VoltageStatus_g . Bit . B7 = 1;
                   }
                   else
                   {
8 4                  rb_underVoltageTimer_s++;                          // increase undervoltagetimer
                   }
                 }
                 else
                 {
8 5                rb_underVoltageTimer_s=0;                            // loesche Timer
8 6                uF_VoltageStatus_g . Bit . B7 = 0;
                 }
8 7     ( )( )   if(
8 7.1   ( )( )   uF_VoltageStatus_g . Bit . B0 == 1)
                 {
                     //l_u8_wr_L_Err_State_Volt(rbi_UnderVoltage_g);    //voltage error statue
                 }
                 else 
8 8     ( )( )     if(
8 8.1   ( )( )     uF_VoltageStatus_g . Bit . B3 == 1)
                 {
                   {
8 9                  RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 1;}
8 10                 ;  //voltage error statue
                 }
                 else
                 {
                   {
8 11                 RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 0;}
8 12                 ;
                 }     
               }
               //SWRS4 89031 v4 Rain Sensor Diagnostics [CS Released]
               // 1 (1050mV - (3.6mV x 65))/3300mV  x 256 =63 ===>90
               // 1. (1050mV - (3.6mV x 70))/3300mV  x 256 =62 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1050mV 
               //2 (1140mV - (3.9mV x 65))/2417mV  x 1024 =485 ===>90
               //2. (1140mV - (3.9mV x 70))/2417mV  x 1024 =367 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1140mV 
               void TemperatureDetect(void)
               {
                 static unsigned int rb_overTemperatureTimer_s;
                 byte rb_temperateOver_l = 0;
9 0     ( )    TemperatureDetect
9 1     ( )( )   if(((
9 1.1   ( )( )   rb_InternalTemperature_g > 0) && (
9 1.2   ( )( )   rb_InternalTemperature_g < 62))  || ((
9 1.3   ( )( )   ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (
9 1.4   ( )( )   ras_ASIC_MUX_MeasAD_g[3]. avg < 367)))                        //undervoltage, Overvoltage ?
                 {
9 2     ( )( )     if(
9 2.1   ( )( )     rb_overTemperatureTimer_s>10000)                       
                   {
9 3                  rb_temperateOver_l = 1;
                   }
                   else
                   {
9 4                  rb_overTemperatureTimer_s++;                          
                   }
                 }
                 else 
9 5     ( )( )     if(((
9 5.1   ( )( )     rb_InternalTemperature_g > 0) && (
9 5.2   ( )( )     rb_InternalTemperature_g< 63)) || ((
9 5.3   ( )( )     ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (
9 5.4   ( )( )     ras_ASIC_MUX_MeasAD_g[3]. avg < 485))) 
                 {
9 6     ( )( )       if(
9 6.1   ( )( )       rb_overTemperatureTimer_s>10000)                       
                   {
9 7                    rb_temperateOver_l = 1;//continue on
                   }
                   else
                   {
9 8                    rb_overTemperatureTimer_s=0;                            
9 9                    rb_temperateOver_l = 0;                         
                   }
                 }  
                 else
                 {
9 10                 rb_overTemperatureTimer_s=0;                            
9 11                 rb_temperateOver_l = 0;
                 }
                 // ASIC/MCU temperature detect,when over 95 degree,then set.
                 {
9 12             RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiTDetd_CEM_LIN1 = rb_temperateOver_l;}
9 13             ; 
               }
               void OutPutHudSendCount(void)
               {
                    static byte rb_HUD_Cnt_s = 0;
                    //cnt count 
10 0    ( )    OutPutHudSendCount
                   {
10 1             RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = rb_HUD_Cnt_s;}
10 2             ;
10 3    ( )( )   if(
10 3.1  ( )( )   rb_HUD_Cnt_s < 15)
                   {
10 4               rb_HUD_Cnt_s ++;
                   }
                   else
                   {
10 5               rb_HUD_Cnt_s = 0;
                   }
               }
               void OutPutHudValue(void)
               {
                  byte rb_hud_Crc8_l;
                  unsigned long rl_hud_Brightness_l;
                  unsigned long rl_hud_AMB_Brightness_l;
                  unsigned long rl_hud_FW_Brightness_l; 
                  unsigned long rl_eeprom_hud_max_l = 0;
                  byte rb_hud_Low8Bit_l = 0;
                  unsigned int rw_hud_high9Bit_l  = 0;
                  /*****************Get the Real Lux for FW and AMB  Illuminance = FW*6 + AMB*15 *********************/
11 0    ( )    OutPutHudValue
11 1             rl_hud_AMB_Brightness_l = 15*((unsigned long)(get_rw_Amb_light16bit_g()));
11 2             rl_hud_FW_Brightness_l = (unsigned long)((3*((unsigned long)(get_rl_HUD_light32bit_g())))>>1);
                   /*********Pre-Process for original value get average for "rl_HUD_AMB_Brightness" and "rl_HUD_FW_Brightness"*********/
                   /********100ms average for AMB and FW        1000ms for sum average      ******************/
11 3             GetFiveTableValue_50ms(rl_hud_AMB_Brightness_l,rl_hud_FW_Brightness_l);   
                   /*************5000ms for average output**************/
11 4             rl_hud_Brightness_l  = CalcHUDMean_1000ms();
                   /***********Output to LIN Interface**************/
11 5             rl_eeprom_hud_max_l = EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Resolution*EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Value;
11 6    ( )( )   if(
11 6.1  ( )( )   rl_hud_Brightness_l >= rl_eeprom_hud_max_l)
                   {
11 7               rl_hud_Brightness_l = rl_eeprom_hud_max_l;        
                   }
11 8    ( )( )   if(
11 8.1  ( )( )   rl_hud_Brightness_l > 126000)//currnet send data  length is shorter
                   {
11 9               rl_hud_Brightness_l = 126000;
                   } 
11 10            rb_hud_Low8Bit_l  = (byte)(rl_hud_Brightness_l&0xFF);
11 11            rw_hud_high9Bit_l = (unsigned int)((rl_hud_Brightness_l>>8)&0x1ff);
                   {
11 12            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = rb_hud_Low8Bit_l;}
11 13            ;
                   {
11 14            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(rw_hud_high9Bit_l&0xff)); 
11 15            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((rw_hud_high9Bit_l>>8)&0x1));}
11 16            ;
                   //check crc 
11 17            rb_hud_Crc8_l = GetHudCrcj1850(rl_hud_Brightness_l);
                   {
11 18            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = rb_hud_Crc8_l;}
11 19            ;
                   /*****************end hud info relation  *********************/  
               }
               void OutPutTwliBriValue(void)
               {
                   // AMB 
12 0    ( )    OutPutTwliBriValue
12 1    ( )( )   if(
12 1.1  ( )( )   get_rw_Amb_light16bit_g()*20 < 16383)    
                   {
                       {
12 2               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(get_rw_Amb_light16bit_g()*20&0x3F)); 
12 3               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((get_rw_Amb_light16bit_g()*20>>6)&0xFF));}
12 4               ;
                   }
                   else
                   {
                       {
12 5               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(16383&0x3F)); 
12 6               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((16383>>6)&0xFF));}
12 7               ;
                   } 
               }
               void OutPutSolarValue(void)
               {
                   unsigned int rw_IrLightforSOSE_Corr1_l;
                   unsigned int rw_IrLightforSOSE_Corr2_l;
                   unsigned int rw_SoSe_SunInt_2D_Le_l;
                   unsigned int rw_SoSe_SunInt_2D_Re_l; 
13 0    ( )    OutPutSolarValue
13 1    ( )( )   if ((
13 1.1  ( )( )   (
13 2    ( )( ) 
13 2.1  ( )( )   (EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x02)>0) == 1) && (
13 1.2  ( )( )   1 == uF_ASIC_ControlFlags_g . Bit . B2))
                   {
13 3    ( )( )     if (
13 3.1  ( )( )     (EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ) > 0)
                     {
13 4                 rw_IrLightforSOSE_Corr1_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ); 
                     }
                     else 
                     {
13 5                 rw_IrLightforSOSE_Corr1_l = 0;  
                     }
13 6    ( )( )     if(
13 6.1  ( )( )     (rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_2_g))
                     {
13 7                 rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr1_l;
                     }
                     else
                     {
13 8                 rw_SoSe_SunInt_2D_Le_l = rw_Solar_light16bit_2_g ;
                     }
13 9    ( )( )     if(
13 9.1  ( )( )     (rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_1_g))
                     {
13 10                rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr1_l;
                     }
                     else
                     {
13 11                rw_SoSe_SunInt_2D_Re_l = rw_Solar_light16bit_1_g ;
                     }    
13 12   ( )( )     if (
13 12.1 ( )( )     (EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ) > 0)
                     {
13 13                rw_IrLightforSOSE_Corr2_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ); 
                     }
                     else 
                     {
13 14                rw_IrLightforSOSE_Corr2_l = 0;  
                     }
13 15   ( )( )     if((
13 15.1 ( )( )     rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Le_l) && (
13 15.2 ( )( )     rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Re_l)) 
                     {
13 16                rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr2_l;
13 17                rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr2_l;
                     }
13 18              rw_SoSe_SunInt_2D_Le_l=(rw_SoSe_SunInt_2D_Le_l>>3)*5;
                     rw_SoSe_SunInt_2D_Le_l=((
13 19   ( )( ) 
13 19.1 ( )( )     rw_SoSe_SunInt_2D_Le_l>240)?240:rw_SoSe_SunInt_2D_Le_l);
                     {
13 20              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Le_l;}
13 21              ;
13 22              rw_SoSe_SunInt_2D_Re_l=(rw_SoSe_SunInt_2D_Re_l>>3)*5;
                     rw_SoSe_SunInt_2D_Re_l=((
13 23   ( )( ) 
13 23.1 ( )( )     rw_SoSe_SunInt_2D_Re_l>240)?240:rw_SoSe_SunInt_2D_Re_l);
                     {
13 24              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Re_l;}
13 25              ;       
                   }
                   else
                   {
                     {
13 26              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;}
13 27              ; 
                     {
13 28              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;}
13 29              ; 
                   }
               }
               void OutPutBrightnessValue(void)
               {
                 static byte rb_InitLightValCnt_l=100;
14 0    ( )    OutPutBrightnessValue
14 1    ( )( )   if((
14 1.1  ( )( )   uF_ASIC_ControlFlags_g . Bit . B1 == 0)|| (
14 1.2  ( )( )   uF_Main_Flags_g . Bit . B6 == 1))
                 {
                                                                                        //hold the previous values
14 2    ( )( )     if(
14 2.1  ( )( )     rb_InitLightValCnt_l<100)
                   {
14 3                 rb_InitLightValCnt_l++;
                   }
                   else
                   { 
                      {
14 4                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(0&0xff)); 
14 5                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((0>>8)&0x1));}
14 6                 ;
                      {
14 7                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0;}
14 8                 ;
                      {
14 9                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = 0;}
14 10                ;
                      {
14 11                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(0&0x3F)); 
14 12                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((0>>6)&0xFF));}
14 13                ;
                      {
14 14                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0;}
14 15                ;        // Init 
                      {
14 16                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0;}
14 17                ;         // Init
                   }
                 }
                 else
                 {
14 18              rb_InitLightValCnt_l=0;  
14 19   ( )( )     if(
14 19.1 ( )( )     EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x98)
                   {
                     /*Incase of only Feuchte and solar frame preset then set the light ON, FW and IR to init value for safety reason*/ 
                     {
14 20                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(0x1FF&0xff)); 
14 21                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((0x1FF>>8)&0x1));}
14 22                ;
                      {
14 23                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0xFF;}
14 24                ;
14 25                ;
                     {
14 26                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = 0;}
14 27                ;
                     {
14 28                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(16383&0x3F)); 
14 29                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((16383>>6)&0xFF));}
14 30                ;
                     {
14 31                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;}
14 32                ;       //Blake_Check Even never run here,but make up is better.                      /* Init*/
                     {
14 33                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;}
14 34                ;                             /* Init*/
                   }
                   else 
14 35   ( )( )       if(
14 35.1 ( )( )       rb_Err_State_Light_Sens_mg == 1)                    /*  VDR469   set for error*/
                   {
                                                   // IR Helligkeit Fehler
                      {
14 36                  RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = ((canuint8)(0x1FF&0xff)); 
14 37                  RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((canuint8)((0x1FF>>8)&0x1));}
14 38                  ;
                      {
14 39                  RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0xFF;}
14 40                  ;
14 41                  ;
                      {
14 42                  RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = 0;}
14 43                  ;
                      {
14 44                  RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((canuint8)(16383&0x3F)); 
14 45                  RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((canuint8)((16383>>6)&0xFF));}
14 46                  ;
                      {
14 47                  RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;}
14 48                  ;                            /* Init*/
                      {
14 49                  RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;}
14 50                  ;                             /* Init*/
                   }
                   else
                   {  
14 51                  OutPutHudValue(); 
14 52                  OutPutTwliBriValue();
14 53                  OutPutSolarValue();
                   }
                 } 
               }
               #pragma inline=forced
               static void CheckErrors(void)
               {
                 //l_u8_wr_L_Err_State_Cal_RS(1);                                                 //custorm defined, but we do not support
                 //l_u8_wr_L_Err_State_Coding(0);
                 byte rb_hud_errorParity_l = 0;
15 0    ( )    CheckErrors
15 1             rb_RS_LS_Error1_g = ((uF_Diagnose_pre_Flag . Bit . B1) | 
                                      ((uF_Diagnose_pre_Flag . Bit . B0)<<1) | 
                                        ((uF_Check_lightsensor_g . Bit . B3)<<2) | 
                                          (uF_ASIC_Error_Flags_g . Bit . B3<<3) | 
                                            (uF_ASIC_Ctrl_Error_Flags_g . Bit . B5<<4) | 
                                              (uF_ASIC_Ctrl_Error_Flags_g . Bit . B0<<5) | 
                                                (uF_ASIC_Ctrl_Error_Flags_g . Bit . B1<<6) | 
                                                  (uF_ASIC_Ctrl_Error_Flags_g . Bit . B4<<7));
                 /*VCO_220 VIrefLo/Hi monitoring*/ /*VDR_878*/
15 2             rb_RS_LS_Error2_g = (uF_ASIC_Ctrl_Error_Flags_g . Bit . B3 | 
                                      ((uF_uC_Error_g . Bit . B1)<<1) | 
                                        (uF_ASIC_Error_Flags_g . Bit . B5<<2) |
                                          (uF_ASIC_Error_Flags_g . Bit . B7<<3) |
                                            (uF_ASIC_Error_Flags1_g . Bit . B0<<4));
                 /*VCO_225 RS functionality detection - error when not available*/
15 3             rb_RainS_Error1_g = (RSStatus . Bit . B4 | 
                                      (uF_ASIC_Ctrl_Error_Flags_g . Bit . B2<<1) |
                                        (uF_ASIC_Error_Flags_g . Bit . B6<<2)|
                                          ((uF_Diagnose_pre_Flag . Bit . B3)<<3)|
                                            ((uF_uC_Error_g . Bit . B0)<<4));  
15 4             rb_LightS_Error1_g = ((uF_LightInternalStatus_g . Bit . B5) | 
                                       (rb_ASIC_ALSx_ShortDetected_Error_g<<1) | 
                                         ((uF_Diagnose_pre_Flag . Bit . B2)<<2) | 
                                           (uF_ASIC_Error_Flags_g . Bit . B4<<3)| 
                                             ((uF_Diagnose_pre_Flag . Bit . B4) << 4));
                 /*VCO_224 RS_Error should be set only by RAM/ROM error, when RS function is coded as inactive in kodierbyte0*/
                 {
15 5             RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErrActv_CEM_LIN1 = 1;}
15 6             ;  
15 7    ( )( )   if((
15 7.1  ( )( )   1==(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x01)) && (
15 7.2  ( )( )   0==(
15 8    ( )( ) 
15 8.1  ( )( )   (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0)))
                 {
                   /* VCO132: SM210 - ASIC Frequency Check (done at startup) - LS,RS_Failure */
                   /* VCO 140: SM150 - ADC test */
                   /* setze Lichtsensor RS-Fehler nach SRS */
                   /*SM240*/
                   {
15 9    ( )( )     RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 = (
15 9.1  ( )( )     uF_VoltageStatus_g . Bit . B3 != 0)||(
15 9.2  ( )( )     rb_RS_LS_Error1_g != 0)||(
15 9.3  ( )( )     rb_RS_LS_Error2_g != 0)||(
15 9.4  ( )( )     rb_RainS_Error1_g != 0) ||(
15 9.5  ( )( )     uF_E2ConfigErrorFlags_g . Bit . B6 != 0);}
15 10              ;
                 }
                 else
                 {
                   /*only RAM/ROM error and RS version error*/
                   {
15 11   ( )( )     RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 = (
15 11.1 ( )( )     (rb_RS_LS_Error1_g&0x3) != 0)||(
15 11.2 ( )( )     1==(uF_Diagnose_pre_Flag . Bit . B3))||(
15 11.3 ( )( )     uF_E2ConfigErrorFlags_g . Bit . B6 != 0);}
15 12              ;
                 }
15 13   ( )( )   if(((
15 13.1 ( )( )   rb_RS_LS_Error1_g != 0)||(
15 13.2 ( )( )   rb_RS_LS_Error2_g != 0)||(
15 13.3 ( )( )   rb_LightS_Error1_g != 0)||(
15 13.4 ( )( )   uF_E2ConfigErrorFlags_g . Bit . B6 != 0)||(
15 13.5 ( )( )   uF_LIN_DiagReq2_mg . Bit . B1)))
                 {
15 14              rb_Err_State_Light_Sens_mg = 1;
                 }
                 else
                 {
15 15              rb_Err_State_Light_Sens_mg = 0;
                 }
                 {
15 16            RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrErr_CEM_LIN1 = rb_Err_State_Light_Sens_mg;}
15 17            ;
15 18   ( )( )   if(
15 18.1 ( )( )   uF_ASIC_Error_Flags_g . Bit . B0 != 0)
                 {
                   {
15 19              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 2;}
15 20              ; //AMB ERROR
                 }
                 else
                 {
                   {
15 21              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 3;}
15 22              ;//NORMAL
                 }
                 {
15 23   ( )( )   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1 = (
15 23.1 ( )( )   uF_ASIC_Error_Flags_g . Bit . B0 != 0) || (
15 23.2 ( )( )   uF_ASIC_Error_Flags_g . Bit . B1 != 0);}
15 24            ;//AMB and FW error 
15 25            rb_hud_errorParity_l =IsByteOddParity(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1);
                 {
15 26            RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrParChk_CEM_LIN1 = rb_hud_errorParity_l;}
15 27            ;
               }
               void ApplLinInit(byte rb_LIN_State_l)
               {
                 // init unused bits to 1
                 byte rb_Index_l; 
                 static const byte LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};    /* 0x22"RlsmCem_SerNrLin1Fr01_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};    /* 0x18"RlsmCem_Lin1PartNrFr02_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};    /* 0x20"RlsmCem_Lin1PartNrFr01_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};          /* 0x02"RlsmCem_Lin1Fr03_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[8] = {144,1,0,0,0,0,50,0};       /* 0x2C"RlsmCem_Lin1Fr02_CEM_LIN1" */
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[8] = {0,0,0,1,0,0,0,0};         /* 0x15"RlsmCem_Lin1Fr01_CEM_LIN1" */
16 0    ( )    ApplLinInit
16 1             rb_Index_l = 0;
                 do
                 {
16 2               RlsmCem_SerNrLin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[rb_Index_l];
16 3               RlsmCem_Lin1PartNrFr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[rb_Index_l];
16 4               RlsmCem_Lin1PartNrFr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[rb_Index_l];
16 5               RlsmCem_Lin1Fr03_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[rb_Index_l];
16 6               RlsmCem_Lin1Fr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[rb_Index_l];
16 7               RlsmCem_Lin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[rb_Index_l];
16 8               rb_Index_l++;
                 }
16 9    ( )( )      while (
16 9.1  ( )( )     rb_Index_l < 8);
16 10            rw_AfterRSWipeCounter_mg = 50000;
16 11            rw_AfterRSWipeCounterAlt_mg = 50000;
16 12            rw_AfterWWSWipeCounter_mg = 50000;                                                      //Direktbitdelay bei Kl15 Aus hochsetzen!
16 13            sci_init(rb_LIN_State_l);
16 14            uF_SCIFlags_mg . Bit . B6 = 1;
16 15            uF_StatusRainsensor_mg . Bit . B7 = 1;
16 16            rb_PotiStageFromBox_g = 3;  
16 17            rw_WipeCommandTimOut_mg = 0; 
16 18            rb_AnyErrorCounterDebounce_mg = 200;  
16 19            rb_WipeWorkStatus_mg = 1;  
               }
               __callt void ApplLinSlavePreCopy(byte rb_MessageID_l)                                     /* callt function faster */
               {
17 0    ( )    ApplLinSlavePreCopy
17 1    ( )( )   if(
17 1.1  ( )( )   rb_MessageID_l == (EEPROM_Struct_PD . EEPROMStructPD . IDRLSs_01 & 0x3F))
                 {
                   {
17 2               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . ErrRespRLSM_CEM_LIN1 = uF_Communication_mg . Bit . B6;}
17 3               ;
                   //l_u8_wr_L_Signal_Error(rbi_latched_ResponseError_mg);
17 4               uF_Communication_mg . Bit . B6 = 0;
                 } 
               }
               /******************************HUD Algrithm shenzhen-team 2018-05-05************************/
               void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_50ms)
               {
                 static unsigned char rb_k_cycleIn50ms=0;
                 static unsigned char rb_k_cycleIn500ms=0;
18 0    ( )    GetFiveTableValue_500ms
18 1             rb_storeHUDValueEvery500ms[rb_k_cycleIn50ms] = rl_HUD_Brightness_50ms;
18 2             rb_k_cycleIn50ms++;
18 3    ( )( )   if(
18 3.1  ( )( )   rb_k_cycleIn50ms >= 10)
                 {
18 4               rb_k_cycleIn50ms = 0;
18 5               orderHUDValue(10);
18 6               HUDEverageValue[rb_k_cycleIn500ms]=(rb_storeHUDValueEvery500ms[3]+rb_storeHUDValueEvery500ms[4]+rb_storeHUDValueEvery500ms[5]+rb_storeHUDValueEvery500ms[6]+rb_storeHUDValueEvery500ms[7])/5;
18 7               rb_k_cycleIn500ms++;
18 8    ( )( )     if(
18 8.1  ( )( )     rb_k_cycleIn500ms >= 2)
                   {
18 9                 rb_k_cycleIn500ms=0;  
18 10                rb_hud_data_update = 1;
                   }    
                 }
               }
               unsigned long  AdjustOutHudValue(unsigned long rl_CurrentHud)
               {
                   int currLevel = 0;
                   int rw_LastCurrDiff = 0;
                   unsigned long  rl_adjustAfterHud=0;
19 0    ( )    AdjustOutHudValue
19 1    ( )( )   if(
19 1.1  ( )( )   rl_CurrentHud >= 100)
                   {
19 2               return rl_CurrentHud;
                   }
19 3             currLevel = RW_Amb_Fw_Result_End/10;  
19 4             rw_LastCurrDiff = rl_CurrentHud -RW_Amb_Fw_Result_End;
19 5    ( )( )   if(
19 5.1  ( )( )   rw_LastCurrDiff >=-15 && 
19 5.2  ( )( )   rw_LastCurrDiff <=15)// less than 15 is 
                   {
19 6               return  rl_CurrentHud;
                   }
19 7             currLevel = currLevel+rw_LastCurrDiff/15;
19 8             rw_LastCurrDiff = rw_LastCurrDiff%3;
19 9    ( )( )   if(
19 9.1  ( )( )   currLevel < 0)
                   {   
19 10              rl_adjustAfterHud = 5+rw_LastCurrDiff;
                   }
                   else 
19 11   ( )( )     if(
19 11.1 ( )( )     currLevel > 9)
                   {
19 12                rl_adjustAfterHud = 92+rw_LastCurrDiff;
                   }
                   else
                   {
19 13                rl_adjustAfterHud = 5+currLevel*10+rw_LastCurrDiff;
                   }
19 14            return  rl_adjustAfterHud;    
               }
               unsigned char GetUpdateTimeForLightStatus(void)
               {
                  unsigned char  hud_refresh_time = 1;  
                   //1 in tunnel and day for 1s  get data;in night and darkstart for 3s  get data 
                   //2 if in tunnel and speed less 10,then 3s will upate
20 0    ( )    GetUpdateTimeForLightStatus
20 1    ( )( )   if((
20 1.1  ( )( )   (uF_LightInternalStatus_g . Bit . B0) == 1) && (
20 1.2  ( )( )   uF_Main_Flags_g . Bit . B6 == 0))
                  {
20 2    ( )( )     if(
20 2.1  ( )( )     uF_modi_lightsens_g.AllBit & (byte) 2)
                       {
20 3                 hud_refresh_time = 3;
                       }
                       else 
20 4    ( )( )       if (
20 4.1  ( )( )       uF_modi_lightsens_g.AllBit & (byte) 4)
                       {
20 5    ( )( )         if(
20 5.1  ( )( )         rb_speed_in_kmh_g >= 10)
                         {
20 6                     hud_refresh_time = 1;
                         }
                         else
                         {
20 7                     hud_refresh_time = 3;
                         }   
                       }
                       else 
20 8    ( )( )         if (
20 8.1  ( )( )         uF_modi_lightsens_g.AllBit & (byte) 1)
                       {
20 9                     hud_refresh_time = 3;
                       }
                       else
                       {
20 10                    hud_refresh_time = 1;  
                       }
                   }
                   else
                   {
20 11              hud_refresh_time = 1;  
                   }  
20 12            return  hud_refresh_time;
               }
               unsigned long CalcHUDMean_1000ms(void)
               {  
                   unsigned long  rl_current_hud_lux = 0;
                   unsigned char  rb_hud_refresh_time = 1;
21 0    ( )    CalcHUDMean_1000ms
21 1    ( )( )   if(
21 1.1  ( )( )   rb_hud_data_update == 1)
                   {
21 2               rb_hud_data_update = 0;
21 3               rb_hud_refresh_time = GetUpdateTimeForLightStatus();
21 4    ( )( )     if(
21 4.1  ( )( )     RW_Update_Time_Count < rb_hud_refresh_time)
                     {
21 5                 RW_Update_Time_Count++;
21 6                 rl_current_hud_lux = (HUDEverageValue[0] + HUDEverageValue[1])/2; 
21 7    ( )( )       if((
21 7.1  ( )( )       rl_current_hud_lux < 100) && (
21 7.2  ( )( )       RW_Amb_Fw_Result_End < 100))
                       {        
21 8                   rl_current_hud_lux = (RW_Amb_Fw_Result_End +rl_current_hud_lux)/2;
                       }
                     }
21 9    ( )( )     if(
21 9.1  ( )( )     rb_hud_refresh_time == RW_Update_Time_Count)//refresh time is reached
                     {   
21 10                RW_Update_Time_Count = 0;         
21 11                RW_Amb_Fw_Result_End = AdjustOutHudValue(rl_current_hud_lux);        
                     }   
                   }
21 12            return RW_Amb_Fw_Result_End;//((HUDEverageValue[0] + HUDEverageValue[1])/2);// + HUDEverageValue[2] + HUDEverageValue[3] + HUDEverageValue[4]) / 5);
               }
               /*****Bubble Sort**********/
               void orderHUDValue(int n)
               {
                 unsigned long rb_temp_l = 0;
                 int i =0;
                 int j = 0;
22 0    ( )    orderHUDValue
22 1    ( )( )   for(i=0;
22 1.1  ( )( )   i<n;i++)
22 2    ( )( )     for( j=1;
22 2.1  ( )( )     j<n-i;j++)
                 {    
22 3    ( )( )       if(
22 3.1  ( )( )       rb_storeHUDValueEvery500ms[j-1]>rb_storeHUDValueEvery500ms[j])
                   {
22 4                   rb_temp_l = rb_storeHUDValueEvery500ms[j];
22 5                   rb_storeHUDValueEvery500ms[j] = rb_storeHUDValueEvery500ms[j-1];
22 6                   rb_storeHUDValueEvery500ms[j-1] = rb_temp_l ;
                   }
                 }
               }
               void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb)
               {
                 static unsigned char rb_k_cycleIn50ms=0;
                 unsigned char rb_count = 0;
23 0    ( )    GetFiveTableValue_50ms
23 1             rb_storeFW_ValueEvery50ms[rb_k_cycleIn50ms] = Fw;
23 2             rb_storeAMB_ValueEvery50ms[rb_k_cycleIn50ms] = Amb;
23 3             rb_k_cycleIn50ms++;
23 4    ( )( )   if(
23 4.1  ( )( )   rb_k_cycleIn50ms >= 5)
                 {
23 5               rb_k_cycleIn50ms = 0;
23 6               FW_Average_In_50ms = rb_storeFW_ValueEvery50ms[0];
23 7    ( )( )     for(rb_count = 1;
23 7.1  ( )( )     rb_count < 5;rb_count++)
                   {
23 8                 FW_Average_In_50ms =(FW_Average_In_50ms+ rb_storeFW_ValueEvery50ms[rb_count])/2;
                   }
23 9               AMB_Average_In_50ms=rb_storeAMB_ValueEvery50ms[0];
23 10   ( )( )     for(rb_count = 1;
23 10.1 ( )( )     rb_count < 5;rb_count++)
                   {
23 11                AMB_Average_In_50ms =(AMB_Average_In_50ms+ rb_storeAMB_ValueEvery50ms[rb_count])/2;
                   } 
23 12              FW_Average_In_50ms = (FW_Average_In_50ms_Old+FW_Average_In_50ms)/2 ;
23 13              AMB_Average_In_50ms = (AMB_Average_In_50ms_Old +AMB_Average_In_50ms)/2; 
23 14              GetFiveTableValue_500ms(FW_Average_In_50ms + AMB_Average_In_50ms);
23 15              FW_Average_In_50ms_Old = FW_Average_In_50ms;
23 16              AMB_Average_In_50ms_Old = AMB_Average_In_50ms;
                  }  
               }
               /******************************************End*********************************************/
               /*byte resultCrcTest = 0;
               void TestCrcJ1850Info(void)
               {
                   byte buffer[4]={0x00,0x00,0x00,0x00};//0x59
                   byte buffer1[3]={0xF2,0x01,0x83};//0x37
                   byte buffer2[4]={0x0F,0xAA,0x00,0x55};//0x79
                   byte buffer3[4]={0x00,0xFF,0x55,0x11};//0xB8
                   byte buffer4[9]={0x33,0x22,0x55,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};//0xcb
                   byte buffer5[3]={0x92,0x6B,0x55};//0x8C
                   byte buffer6[4]={0xFF,0xFF,0xFF,0xFF};//0x74
                   resultCrcTest =  CRC8SAEJ1850(buffer,4); //ok
                   resultCrcTest =  CRC8SAEJ1850(buffer1,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer2,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer3,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer4,9);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer5,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer6,4);//ok
               }*/
               byte CRC8SAEJ1850(byte *u8_data,byte u8_len)
               {
                   byte i, j;
                   byte u8_crc8;
                   byte u8_poly;
24 0    ( )    CRC8SAEJ1850
24 1             u8_crc8 = 0xFF;
24 2             u8_poly = 0x1D;
24 3    ( )( )   for (i = 0; 
24 3.1  ( )( )   i < u8_len; i++)
                   {
24 4               u8_crc8 ^= u8_data[i];
24 5    ( )( )     for (j = 0; 
24 5.1  ( )( )     j < 8; j++)
                     {
24 6    ( )( )       if (
24 6.1  ( )( )       u8_crc8 & 0x80)
                       {
24 7                   u8_crc8 = (u8_crc8 << 1) ^ u8_poly;
                       }
                       else
                       {
24 8                   u8_crc8 <<= 1;
                       }
                    }
                   }
24 9             u8_crc8 ^= (byte)0xFF;
24 10            return u8_crc8;
               }
               byte GetOutdBriStsCrcj1850(byte OutdBriSts)
               {  
                     byte buffer[1];
25 0    ( )    GetOutdBriStsCrcj1850
25 1             buffer[0] = OutdBriSts;
                     //TestCrcJ1850Info();
25 2             return CRC8SAEJ1850(buffer,1);  
               }
               byte GetHudCrcj1850(unsigned long hudSrc)
               {     
                     //byte buffer[2];
                     //buffer[0] = hudSrc&0xFF;
                     //buffer[1] = (hudSrc>>8)&0xFF;      
                     //return CRC8SAEJ1850(buffer,2);
               	  /**********Zhiyuan HU 20190313**************/
               	  byte buffer[3];
26 0    ( )    GetHudCrcj1850
26 1             buffer[0] = hudSrc&0xFF;
26 2             buffer[1] = (hudSrc>>8)&0xFF;
26 3             buffer[2] = (hudSrc>>16)&0xFF;
26 4             return CRC8SAEJ1850(buffer,3);
               	  /**********Zhiyuan HU 20190313**************/
               }
               void GetLightTransmission(byte trans_550nm,byte trans_880nm)
               {
                 byte rb_880nm_Transmission_local_Coding = 0;
                 byte rb_550nm_Transmission_local_Coding = 0;
                 byte rb_550nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 byte rb_880nm_Transmission_local_Coding_outOfRangeFlag = 0;
27 0    ( )    GetLightTransmission
27 1             rb_550nm_Transmission_local_Coding = (trans_550nm);
                 rb_550nm_Transmission_local_Coding = ((
27 2    ( )( )   (
27 2.1  ( )( )   rb_550nm_Transmission_local_Coding > 90) && (
27 2.2  ( )( )   rb_550nm_Transmission_local_Coding <= 100))? 90 : rb_550nm_Transmission_local_Coding);
27 3             rb_880nm_Transmission_local_Coding = (trans_880nm);
                 rb_880nm_Transmission_local_Coding = ((
27 4    ( )( )   (
27 4.1  ( )( )   rb_880nm_Transmission_local_Coding > 90) && (
27 4.2  ( )( )   rb_880nm_Transmission_local_Coding <= 100))? 90 : rb_880nm_Transmission_local_Coding);
27 5    ( )( )   if((
27 5.1  ( )( )   rb_550nm_Transmission_local_Coding >= 15) && (
27 5.2  ( )( )   rb_550nm_Transmission_local_Coding <= 90))
                 {
27 6               rb_550nm_Transmission_local_Coding = ((rb_550nm_Transmission_local_Coding-15) + 2) / 5; 
27 7               rb_550nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 }
                 else
                 {
27 8               rb_550nm_Transmission_local_Coding = 0 ; 
27 9               rb_550nm_Transmission_local_Coding_outOfRangeFlag =1;
                 }
27 10   ( )( )   if((
27 10.1 ( )( )   rb_880nm_Transmission_local_Coding >= 15) && (
27 10.2 ( )( )   rb_880nm_Transmission_local_Coding <= 90))
                 {
27 11              rb_880nm_Transmission_local_Coding = ((rb_880nm_Transmission_local_Coding-15) + 2) / 5; 
27 12              rb_880nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 }
                 else
                 {
27 13              rb_880nm_Transmission_local_Coding = 0 ;
27 14              rb_880nm_Transmission_local_Coding_outOfRangeFlag = 1;
                 }
27 15   ( )( )   if(
27 15.1 ( )( )   rb_550nm_Transmission_local_Coding_outOfRangeFlag == 1 || 
27 15.2 ( )( )   rb_880nm_Transmission_local_Coding_outOfRangeFlag == 1)
                 {
                     {
27 16              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErr_CEM_LIN1 = 1;}
27 17              ;    
                 }
                 else
                 {
                    {
27 18              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErr_CEM_LIN1 = 0;}
27 19              ;
                 }
27 20   ( )( )   if(((
27 20.1 ( )( )   rb_550nm_Transmission_local_Coding_outOfRangeFlag == 0) && (
27 20.2 ( )( )   rb_880nm_Transmission_local_Coding_outOfRangeFlag == 0))
                        && (
27 20.3 ( )( )   EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte2_g != ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding))
                        && ((
27 20.4 ( )( )   uF_Main_Flags_g . Bit . B2 == 0)||(
27 20.5 ( )( )   uF_Main_Flags_g . Bit . B1 == 1)))
                 {
27 21              rab_EEPROM_Bytes_toWrite_g[0] = ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding);
27 22              rw_EEPROM_Address_to_Write_g = (268); /*set adress to write*/
27 23              rb_I2C_EEPROM_bytesToWrite_g = 1;         /*set number of bytes to 1*/
27 24              uF_Main_Flags_g . Bit . B2 = 1;
27 25              uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               void Get_BCMVehType(byte CarType)
               {
                 static byte rb_VehTypeValueDebounce = 0;
                 byte rb_Kodierbyte1_Update_g ; 
                 byte rb_BaseType ;// 0 to 3 rain config
28 0    ( )    Get_BCMVehType
28 1    ( )( )   if(
28 1.1  ( )( )   rb_VehTypeValueDebounce < 20)//if 100MS run once ,2s delay check
                 {
28 2               rb_VehTypeValueDebounce ++;
28 3               return ;
                 }
                  /*check if the E2PROM data has been loaded*/
28 4    ( )( )   if(
28 4.1  ( )( )   uF_Main_Flags_g . Bit . B6 == 1)
                 {
28 5               return ;
                 }
28 6             rb_Kodierbyte1_Update_g = EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte1_g;
28 7             rb_BaseType  = CarType/4;
28 8    ( )( )   if((
28 8.1  ( )( )   rb_BaseType < 4)&& ( 
28 8.2  ( )( )   ((rb_Kodierbyte1_Update_g & 12)>>2)!= rb_BaseType)&& ((
28 8.3  ( )( )   uF_Main_Flags_g . Bit . B2 == 0)||(
28 8.4  ( )( )   uF_Main_Flags_g . Bit . B1 == 1)))
                 {
28 9               rb_Kodierbyte1_Update_g &=0xF3; //Clear 2 and 3 bit
28 10              rb_Kodierbyte1_Update_g |=(rb_BaseType << 2); //set
28 11              rab_EEPROM_Bytes_toWrite_g[0] = rb_Kodierbyte1_Update_g;
28 12              rw_EEPROM_Address_to_Write_g = (268)+1; /*set adress to write*/
28 13              rb_I2C_EEPROM_bytesToWrite_g = 1;         /*set number of bytes to 1*/
28 14              uF_Main_Flags_g . Bit . B2 = 1;
28 15              uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               void Set_BCMLightOffset(byte offset)
               {
                 static byte rb_lightValueDebounce = 0;
                 byte rb_OldSensorLs ;
                 byte rb_Kodierbyte0_Update_g; 
29 0    ( )    Set_BCMLightOffset
29 1    ( )( )   if(
29 1.1  ( )( )   rb_lightValueDebounce < 20)//if 100MS run once ,2s delay check
                 {
29 2               rb_lightValueDebounce ++;
29 3               return ;
                 }
                 /*check if the E2PROM data has been loaded*/
29 4    ( )( )   if(
29 4.1  ( )( )   uF_Main_Flags_g . Bit . B6 == 1)
                 {
29 5               return ;
                 }
29 6             rb_OldSensorLs = (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g& 0x38)>>3;
29 7             rb_Kodierbyte0_Update_g = EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g; 
29 8    ( )( )   if((
29 8.1  ( )( )   offset < 8)&& (
29 8.2  ( )( )   rb_OldSensorLs != offset)&& ((
29 8.3  ( )( )   uF_Main_Flags_g . Bit . B2 == 0)||(
29 8.4  ( )( )   uF_Main_Flags_g . Bit . B1 == 1)))
                 {
29 9               rb_Kodierbyte0_Update_g &=0xC7; 
29 10              rb_Kodierbyte0_Update_g |=(offset << 3); 
29 11              rab_EEPROM_Bytes_toWrite_g[0] = rb_Kodierbyte0_Update_g;
29 12              rw_EEPROM_Address_to_Write_g = (268)+2; 
29 13              rb_I2C_EEPROM_bytesToWrite_g = 1;         
29 14              uF_Main_Flags_g . Bit . B2 = 1;
29 15              uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               void SendRLSSerNo(void)
               {
30 0    ( )    SendRLSSerNo
                   {
30 1             RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(0)]);}
30 2             ;
                   {
30 3             RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(1)]);}
30 4             ;
                   {
30 5             RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(2)]);}
30 6             ;
                   {
30 7             RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr4_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(3)]);}
30 8             ;
               }
               void SendRLSMPartNo(void)
               {
31 0    ( )    SendRLSMPartNo
                   {
31 1             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(0)]);}
31 2             ;
                   {
31 3             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(1)]);}
31 4             ;
                   {
31 5             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(2)]);}
31 6             ;
                   {
31 7             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr4_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(3)]);}
31 8             ;
                   {
31 9             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(5)]);}
31 10            ;
                   {
31 11            RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(6)]);}
31 12            ;
                   {
31 13            RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(7)]);}
31 14            ;
               }
               void SendRLSMPartNo10(void)
               {
32 0    ( )    SendRLSMPartNo10
                   {
32 1             RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(0)]);}
32 2             ;
                   {
32 3             RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(1)]);}
32 4             ;
                   {
32 5             RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(2)]);}
32 6             ;
                   {
32 7             RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(3)]);}
32 8             ;
                   {
32 9             RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(4)]);}
32 10            ;
                   {
32 11            RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(5)]);}
32 12            ;
                   {
32 13            RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(6)]);}
32 14            ;
                   {
32 15            RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = (EEPROM_Struct_PD . EEPROMStructPD . Audi_HW_Partnumber[(7)]);}
32 16            ;
               }
               /************************************************Winter mode check************************************************/
               /**************************T < 0 degree and Speed is under 5KM/H.*************************************************/
               void WipeWinterModeCheck(void)
               {  
33 0    ( )    WipeWinterModeCheck
33 1    ( )( )   if((
33 1.1  ( )( )   rb_speed_in_kmh_g < 5) && (
33 1.2  ( )( )   rb_OutsideTemp_mg <= 0))
                 {
33 2               rb_WipeWorkStatus_mg = 2;
                 }
                 else
                 {
33 3               rb_WipeWorkStatus_mg = 1;
                 }  
               }
               /*!
                * @brief ÅÐ¶Ïµ±Ç°byteµÄ¼«ÐÔÊÇ·ñÎªÅ¼
                *
                * @param byte£¬ ´ý¼ÆËãÆæÅ¼ÐÔµÄÊý¾Ý.
                * @retval false  byte¼«ÐÔ(º¬1µÄ¸öÊý)ÎªÆæÊý.
                * @retval ture£¬ byte¼«ÐÔ(º¬1µÄ¸öÊý)ÎªÅ¼Êý.
                */
               byte IsByteOddParity(byte data)
               {
                   byte parity = 0;
34 0    ( )    IsByteOddParity
34 1    ( )( )   while (
34 1.1  ( )( )   data)
                   {
34 2    ( )( )     parity = !
34 2.1  ( )( )     parity;
34 3               data &= data - 1;
                   }
34 4    ( )( )   return !
34 4.1  ( )( )   parity;
               }
