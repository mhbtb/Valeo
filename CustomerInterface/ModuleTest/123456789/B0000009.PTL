               /* PRQA S 3619 EOF */ /* << IAR-Compiler allows whitespaces>> */
               /* PRQA S 3116 EOF */ /* << pragma directives needed, compiler specific>>*/
               /*************************************************************************
                 Company : Valeo Wiper System
                 Project : RLT Sensor, RDN Sensor
                 Component : RLS_LINST.c
                 Documentation reference   : Software Requrement Specification
                 Overview of the component : LIN- Data Link layer
                 Evolution of the component : see PVCS Version control system
                               Initials   date   modification
               *************************************************************************/
               /* History                                                                    */
               /*----------------------------------------------------------------------------*/
               /* Date      VDR_Number     Description                                       */
               /* DD.MM.YY*/
               /*----------------------------------------------------------------------------*/
               /* 05.09.11 VDR_705  PCG  - Send detection of Rain Sensor at any time not only when active */
               /* 31.08.11 VDR_700  PCG  - Set Light Sensitivity "0" like LS "4". Set default to "4" instead of "0" 
                                         - Reorganize signals related to Message CEM_L8_FrP04 */
               /* 13.05.11 VDR_659  PCG  - QA-C                       */
               /* 12.05.11 VDR_634  PCG  - removed changes from 10.May.11 */
               /* 10.05.11 VDR_634  PCG  - set adapterrrainsensacrive failure when no master msg is received */
               /* 24.03.11 VDR_647  FS   - Variable name changed*/ 
               /* 18.03.11 VDR_66   PCG  - RLS_VDR_633 RLS_VOLVO_Y555 the first frame of RSM partnumber is set to 0 at startup */
               /* 17.02.11 VCO_70   PCG  - reduced low limit for WS Transmission due to Blue shade band*/
               /* 15.02.11 VDR_580  PCG  - splash bit no more depending on directmode */
               /* 17.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 04.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 11.08.10 VCO_73   PCG  - Implemented Rain Sensor Sensitivity up to 8 sensitivities. SWRS-RSM-001:Req34v1 */
               /* 06.08.10 VCO_71   PCG  - Implemented Rain Sensor Norm Value: adjust RSM sensitivity when placed on 
               *                            different vehicles. SWRS-RSM-001: Req38v1  */
               /* 06.08.10 VCO_73   PCG  - Implemented VCC Part Number: 31314540. SWRS-RSM-001:Req14v1  */
               /* 05.08.10 VCO_72   PCG  - Implemented Light Sensor Sensitivity: RainSnsrLiSnvty. SWRS-RSM-001:Req51v2  */
               /* 03.08.10 VCO_69   PCG  - Implemented new output signal RainSnsrLiMod. SWRS-RSM-001:Req39v2 */
               /* 03.08.10 VCO_66   PCG  - Implemented CarCode table values according mail 26.03.2010*/
               /* 02.08.10 VCO_67   PCG  - Implemented Rain Sensor active when Terminal_X is set regardless 
               *                            Switch Position. SWRS-RSM-001:Req31v1 */
               /* 02.08.10 VCO_68   PCG  - Implement New message CEM_L8_FrP04. SWRS-RSM-001:Req19v1 */
               /* 30.06.10 VDR_540  FS   - Butterfly Option integrated*/
               /* 10.06.10 VCO_49   FS   - Implement long EEPROM PLUS Logging Issues from 11.June --> Park Position corrected*/
               /* 10.06.10 VCO_59   FS   - Logging files --> Rework ParkPosition Evaluation*/
               /* 26.05.10  VCO_055     AL      reomve debouncing of RAM and ROM error*/
               /* 29.04.10 VDR_473  FS   - QA-C*/
               /* 26.04.10 VCO_48   FS   - Use "AB" Index instead of only "B" of the partnumer within EEPROM*/
               /* 26.04.10 VCO_48   FS   - First Frame of Part number not correct*/
               /* 26.03.10  VCO_48   FS   - Update due to Test Drive
                *                           Park contact has been send to late via LIN
                                        --> Update in this file and trigger on WiperSpeed_Running Signal
                                          - Update internal SCS_Signals, that both ldf can work the same*/
               /* 25.03.10  VCO_44   FS   - Implement strategy for Partnumber Read Out
                *                         - delete some parts of VCO_33
                *                         - Switch Stalk Information dependent from CarCode*/
               /* 11.02.10  VDR_437  FS   - Index of Ford Partnumber from EEPROM included *
                 *                        - Mapping of RainSensorSensitivity not in RAM --> in EEPROM*/
               /* 19.01.10  VDR_414  FS    Update due to Testdrive*/
               /* 23.12.09  VDR_394  FS    REWORK: New CarCode Table to be implemented, Req: Email from 20091218*/
               /* 22.12.09  VDR_362  FS    Rework: Overflow of rb_parkpositioncounter_s MUST have been implemented */
               /* 18.12.09  VDR_403  FS    - rb_FixedCarCode deleted
                *                          - Set Auxillary Variable constantly to ALL-value that Ford Partnumber
                *                            can be received by Master for all CarCodes*/
               /* 19.11.09  VDR_396  FS    RainSensorEnable as required in SRS*/
               /* 17.11.09  VDR_394  FS    Default values windshield and comments*/
               /* 01.10.09  VDR_373  FS    "OneTime or Double Overwiped"*/
               /* 29.09.09  VDR_362  FS    Implement wipe cancelling when 4 seconds wiper has not moved*/
               /* 25.09.09  VDR_368  FS    Requirements from FRSI, SRD, ES and Testcases. See comments in code*/
               /* 28.09.09  VDR_360  FS    RainSensorDisable implementation for Ford*/
               /* 31.07.09  VDR_355  AL    Changes based on results of function test and     *
                          & VDR_356        Review of function from Bosch sensor             */
               /* 16.07.09  VDR_344 FS     Updating complete first version to                *
                                           first release version due to                      *
                                           Ford Meeting in Bietigheim                        */
               /* 28.08.15  VCO_268 SP     Cleanup the LIN modules  */
               /*02.10.2015 VDR_911 SP     HammingErr shld be part of RS_Error/LS_Error and shld not be used for Active Err*/
               /*30.05.2016 VDR_983 NB     Sporadic illegale instruction reset in the startup                              */
               /******************************************************************************/
               /*************************************************************************
               **                   Common and module include-file                     **
               **************************************************************************/
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/DEVICE/ior5f109be.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_projectDefs.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_E2ProjectConfig.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_main.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_lininclude.h"
               /*************************************************************************
               **                   Other files included                               **
               **************************************************************************/
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_io.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_timer.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_Check_sr.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_rainsens.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_diagnose.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_E2Handler.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_flashe2.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/RAIN/G5_rs_task.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_IRlight.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_DippedBeam_sr.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control_sr.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_spi_sr.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_utilities.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_AsicFramesLin.h"
               /*************************************************************************
               **                   Declaration of local module variables              **
               *************************************************************************/
               /* PRQA S 0759 1*//*<< 0759:union needed to reduce RAM usage >>*/
               static volatile Flag uF_StalkInPos_Flags_g;
               /*************************************************************************
               **                   Declaration of local module Macros **
               *************************************************************************/
               /*************************************************************************
               **                   Declaration of local module Functions              **
               *************************************************************************/
               extern byte rb_RainInt_IntensityOutput_g;
               extern unsigned int rb_overWipeCoef;
               static void CheckErrors(void);
               static void RainFunction(void);
               static void LightFunction(void);
               static void Humidity_Function(void);
               static void StandByMode(void);
               static void VoltageDetect(void);
               static void OutPutBrightnessValue(void);
               static byte rb_Verglasun_ClosedDebounce_mg;
               static unsigned int rw_CommandCloseWindowTimout_mg;
               static byte rb_AnyErrorCounterDebounce_mg;
               static unsigned int rw_AfterRSWipeCounter_mg;                   // Time after last wipe from RS
               static unsigned int rw_AfterRSWipeCounterAlt_mg;              //Time to the last wipe from RS
               static unsigned int rw_AfterWWSWipeCounter_mg;                  // Time after last wipe from WWS
               static  unsigned int rw_WipeCommandTimOut_mg;                    //timout for requested wipe
               static  byte rb_Err_State_Light_Sens_mg =0;// light error
               static  byte  rb_OutsideTemp_mg  = 0;
               static  byte rb_WipeWorkStatus_mg = 1;
               /******************For HUD**********************/
               static unsigned long HUDEverageValue[2] = {0,0};
               static unsigned long rb_storeHUDValueEvery500ms[10]={0,0,0,0,0,0,0,0,0,0};
               static void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_50ms);
               static unsigned long CalcHUDMean_1000ms(void);
               static void orderHUDValue(int n);
               static void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb);
               static unsigned long  AdjustOutHudValue(unsigned long rl_CurrentHud);
               static byte GetUpdateTimeForLightStatus(void);
               static  unsigned long RW_Amb_Fw_Result_End    = 0;
               static  byte rb_hud_data_update      = 0;
               /********************End***********************/
               static void OutPutSolarValue(void);
               static void OutPutTwliBriValue(void);
               static byte CRC8SAEJ1850(const byte * u8_data,byte u8_len);//crc8saej1850 
               static byte GetHudCrcj1850(unsigned long hudSrc);
               static byte GetOutdBriStsCrcj1850(byte OutdBriSts);
               static void GetLightTransmission(byte trans_550nm,byte trans_880nm);
               //static void Get_BCMVehType(byte CarType);
               static void Set_BCMLightOffset(byte offset);
               static void SendRLSSerNo(void);
               static void SendRLSMPartNo(void);
               static void SendRLSMPartNo10(void);
               static void OutPutHudValue(void);
               static void OutPutHudSendCount(void);
               static void TemperatureDetect(void);
               static void WipeWinterModeCheck(void);
               static byte IsByteOddParity(byte data);
               static void Rain_sensitivity(void);
               static void Get_Lin_Signal_From_GetLeWWS(void);
               static void Light_Sensitivity_In_GetLeWWS(void);
               static void Wiper_and_Park(void);
               static void Tunnel_Wipe_Decision(void);
               static void Exit_Wipe(void);
               static void Rain_Sensitivity_Judge(void);
               static void Standby_Judge(void);
               static void OutdBriCntr_Counter(void);
               static byte rb_AfterResetCounter_l;
               static unsigned int rw_IgnitionOffDelay_mg;
               static byte rb_tunnelWipeActive_g;  
               static byte rb_RLS_Sensitivity_Array_l[7];
               static byte rb_Verglasun_offenDebounce_mg;
               static byte Vehicle_Speed_Decision_Flag = 0;
               /**************************************************************************
                 Syntax   : void  GetLeWWS(void)
                 Object   : GetLeWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Schaltermoduls von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLeWWS(void)
               {
                 static byte rb_IgnitionOndelay_mg = 0;
                 static byte rb_IntervalOnOndelay_mg;
1 0     ( )    GetLeWWS
1 1     ( )( ) if((uLinIndicationFlags . w[0]. b6 != 0))
                 { 
                   {uLinIndicationFlags . w[0]. b6 = 0;};
                   rw_NoCommunicationCounter_g = 0;                                 // reset no communication counter
                   uF_SCIFlags_mg . Bit . B1 = 1;                                     // set connected to Master  
                   uF_Communication_mg . Bit . B1 = 1;    
                   rb_speed_in_kmh_g = CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . VehSpdForWipg_CEM_LIN1;//needsys   
1 2     ( )( )   if(rb_speed_in_kmh_g>=10)
                   {
                     uF_GainAdjustFlags_g . Bit . B1 = 1;
                   }   
                   else{}
                   uF_VoltageStatus_g . Bit . B2 = 1;
                   rw_IgnitionOffDelay_mg = 0;
1 3     ( )( )   if(rb_IgnitionOndelay_mg < 250)
                   {
                     rb_IgnitionOndelay_mg++;
                   }
                   else{}
1 4     ( )( )   if((((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0) == 0) &&(rb_AfterResetCounter_l> 10))
                   {
1 5     ( )( )     if((CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 1) || (((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x40)>0) != 0))
                     {
                       uF_StatusRainsensor_mg . Bit . B0 = 1;                            /*Rainsensor always active!*/
                     }
                     else
                     {
                       uF_StatusRainsensor_mg . Bit . B0 = 0;                           /*Rainsensor off!*/
                     }
                   }
                   else
                   {
                     uF_StatusRainsensor_mg . Bit . B0 = 0;                             //Rainsensor off!
                   }
1 6     ( )( )   if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 1)                            // copy automatic wiping mode
                   {
1 7     ( )( )     if(rb_IntervalOnOndelay_mg > 15)                               //debound 150ms when turn the auto wiper on
                     {
                       RSStatus . Bit . B7 = 1;
                     }
                     else
                     {
                       rb_IntervalOnOndelay_mg++;
                     }
                   }
                   else
                   {
                     RSStatus . Bit . B7 = 0;
                     rb_IntervalOnOndelay_mg = 0;
                   }
                   rb_LIN_SensitivityShift_g =  9;                                     //adaptation Variable for sensitivity factor
1 8     ( )( )   if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1 < 7)
                   {
                     rb_PotiStageFromBox_g = CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1;
                   }
                   else 
1 9     ( )( )     if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1 == 7)
                   {
                     rb_PotiStageFromBox_g = 3;
                   }
                   else{}
                 }  
                 else                                                                  //keine neue Master Nachricht!
                 {                                                                     // check if system is on -> to switch off 
1 10    ( )( )   if(rw_NoCommunicationCounter_g > ((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200))                               /***4S***/
                   {     
1 11    ( )( )     if ((uF_SCIFlags_mg . Bit . B4 == 0)||( uF_ASIC_ControlFlags_g . Bit . B4 == 0))  /*VDR_526*/
                     {
1 12    ( )( )       if ((rb_Verglasun_offenDebounce_mg > 100) 
                           && (((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x04)>0) == 1) 
                           && (uF_SCIFlags_mg . Bit . B4 == 0))
                       {
                         uF_ASIC_ControlFlags_g . Bit . B4 = 1;                             // Set Request for Standby Mode
                         /*******20191112_Zhiyuan HU_Only_for_Winter_Mode********/
                         Vehicle_Speed_Decision_Flag = 0;
                         /*******************End*******************************/
                       }
                       else
                       {
                         uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                       }       
                       uF_SCIFlags_mg . Bit . B2 = 1;                                         // Was Connected to Master
                     }
                     else 
                     {
1 13    ( )( )       if ((CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 0) || (rw_CommandCloseWindowTimout_mg > 6000))
                       {
                         uF_SCIFlags_mg . Bit . B2 = 1;                                       // no need of Standby mode 
                         uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                         uF_SCIFlags_mg . Bit . B0 = 0;                                /*VDR_526*/
                         uF_SCIFlags_mg . Bit . B4 = 0;                           /*VDR_526*/
                         rb_WakeupCounter_mg = 0; 
                       }
                       else
                       {
1 14    ( )( )         if (rb_WakeupCounter_mg == 0)                             /*VDR_526*/
                         { 
                           uF_SCIFlags_mg . Bit . B0 = 1; 
                         }
                       }
                     }
                     uF_SCIFlags_mg . Bit . B1 = 0;                                  // clear connected to Master
                   }
                   else
                   {
                     uF_SCIFlags_mg . Bit . B0 = 0;                                    /*VDR_526*/
                     rw_NoCommunicationCounter_g ++;
                     uF_SCIFlags_mg . Bit . B2 = 0;                                          // Was Connected to Master
1 15    ( )( )     if(rw_NoCommunicationCounter_g >= (((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200) - 3) )
                     {
                       rb_Release_IntervalMarker_Update_g = 0x00;
                       uF_StatusRainsensor2_mg . Bit . B3 = 1;
                     }
                   }
                 }
               }
               /**************************************************************************
                 Syntax   : void  GetLsWWS(void)
                 Object   : GetLsWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Wischermotorin von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLsWWS(void)
               {  
                 static byte rb_parkpositioncounter_s;
                 /*simulierte Wischzeit bei LSS aus*/
                 static const byte cab_WiperMotorRunntime_mg[8] ={142,142,133,125,117,111,105,100};  
2 0     ( )    GetLsWWS
                 Get_Lin_Signal_From_GetLeWWS();
                 Standby_Judge();
                 Light_Sensitivity_In_GetLeWWS();
2 1     ( )( ) if ((rb_WiperSpeed_g > 0)&&(uF_SCIFlags_mg . Bit . B6== 1))
                 {    
2 2     ( )( )   if (rw_WipeCommandTimOut_mg <= 400)
                   {
                     rw_WipeCommandTimOut_mg ++;                // reset Timout if wiper motor wants not wipe
                   }
                   else
                   {
                     rb_LimitMemomryNoWiperReaction_g = 1;
                   }      
                 }
2 3     ( )( ) if(((CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 0) && (uF_SCIFlags_mg . Bit . B6 == 1))
                      ||(rw_WipeCommandTimOut_mg > 400))
                 {
2 4     ( )( )   if((rb_WiperSpeed_g > 0)||(uF_StatusRainsensor_mg . Bit . B7 == 0))
                   {
2 5     ( )( )     if(rb_parkpositioncounter_s>10)            // Parkpositioncounter groesser 10
                     {
                       uF_StatusRainsensor_mg . Bit . B7 = 0;              // delete bit for Parkposition
                     }
                     rb_parkpositioncounter_s++;                // increase Parkpositionscounter
                   }
2 6     ( )( )   if(rb_parkpositioncounter_s > (cab_WiperMotorRunntime_mg[rb_WiperSpeed_g]))
                   {
                     rw_WipeCommandTimOut_mg = 0;
                     uF_StatusRainsensor_mg . Bit . B7 = 1;               
                     rb_parkpositioncounter_s = 0;            
                   }
                 }
                 else    
                 {
2 7     ( )( )   if((uF_SCIFlags_mg . Bit . B6 == 0)&&(rb_WiperSpeed_g > 0))
                   {
                     rbi_WiperStarted_g = 1;
                   }
2 8     ( )( )   if(uF_SCIFlags_mg . Bit . B6 == 1)            // In Parklagensignal ?
                   {
2 9     ( )( )     if(uF_StatusRainsensor_mg . Bit . B7 == 0)
                     {
                       rb_parkpositioncounter_s=0;              // Parkpositioncounter zuruecksetzen
                     }
                     else
                     {
2 10    ( )( )       if(rb_parkpositioncounter_s < 255)
                       {
                         rb_parkpositioncounter_s++;
                       }
                     }
                     uF_StatusRainsensor_mg . Bit . B7 = 1;                 // Parkposition True
2 11    ( )( )     if (rub_IntermDelayTime > 5)               // clear option for Wiper Started Flag!
                     {
                       rbi_WiperStarted_g = 0;
                     }
                   }
                   else
                   {
                     rb_LimitMemomryNoWiperReaction_g = 0;
                     rbi_WiperStarted_g = 0;
                     rw_WipeCommandTimOut_mg = 0;               // reset Timout if wiper motor wants not wipe
2 12    ( )( )     if(rb_parkpositioncounter_s>7)             // Parkpositioncounter groesser 8
                     {
                       uF_StatusRainsensor_mg . Bit . B7 = 0;              // loesche bit fuer Parkposition
                     }
                     else
                     {
                       rb_parkpositioncounter_s++;              // inkrementiere Parkpositionscounter
                     }
                   }
                 }
               }
               /**************************************************************************
                 Syntax   : void  CopyRLSData(void)
                 Object   : CopyRLSData()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Ausgangsdaten des Sensors in den
                 Ausgangsdatenpuffer des Vector Bus Treiber und setzt die internen Daten
                 gemaess SRS um.
               **************************************************************************/
               void CopyRLSData(void)
               {
3 0     ( )    CopyRLSData
                 Check_StartupActiveErrors();
3 1     ( )( ) if((uLinConfirmationFlags . w[0]. b6 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b6 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   OutdBriCntr_Counter();
                 }
3 2     ( )( ) if((uLinConfirmationFlags . w[0]. b5 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b5 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   OutPutHudSendCount();
                 }
3 3     ( )( ) if((uLinConfirmationFlags . w[0]. b4 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b4 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                 }
3 4     ( )( ) if((uLinConfirmationFlags . w[0]. b3 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b3 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   SendRLSMPartNo();
                 }
3 5     ( )( ) if((uLinConfirmationFlags . w[0]. b2 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b2 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                   SendRLSMPartNo10();
                 }
3 6     ( )( ) if((uLinConfirmationFlags . w[0]. b1 != 0))
                 {
                   {uLinConfirmationFlags . w[0]. b1 = 0;} ;
                   uF_SCIFlags_mg . Bit . B1 = 1; 
                   SendRLSSerNo();
                 }
                 /* Rain intensity VCO_423: Interval mode defined*/  
3 7     ( )( ) if(uF_StatusRainsensor_mg . Bit . B0 == 1)
                 {
                   rb_overWipeCoef = EEPROM_Struct_PD . EEPROMStructPD . RS_Intensity_OverWipeCoef;
                 }
                 else
                 {
                   rb_overWipeCoef = 100;
                 }
                 RainFunction();//Tunnel wiper,auto wiper,rain level, splash mode, rain sonser error
                 CheckErrors();//Other error signals send in this function
                 VoltageDetect();//Send high/low voltage error
                 TemperatureDetect();//send temperate error
                 LightFunction();//light request and the reason of light on                            
                 StandByMode();//Auto close window
                 OutPutBrightnessValue();//output FW IR SOLAR brightness
                 Humidity_Function();//dew point & Screen temperature & sensor teamperature & relative Humidity
                 CopyRLSDataAsic();
                 rb_WDG_BusTaskCounter_g++;//increment test counter for bus
               }
               static void RainFunction(void)
               {
                 static byte rb_TunnelWipeTimeOut_mg;   
                 byte Wiper_speed_l = 0;
4 0     ( )    RainFunction
                 Wiper_and_Park();
                 Tunnel_Wipe_Decision();
                 /*trigger the afterwipe at tunnel*/
4 1     ( )( ) if((rw_AfterRSWipeCounter_mg >= rw_AfterRSWipeCounterAlt_mg)
                      &&(rb_tunnelWipeActive_g == 1)
                        &&(rb_WiperSpeed_g == 0))
                 {
                   rb_TunnelWipeTimeOut_mg = 0;
                   uF_Communication_mg . Bit . B3 = 1;
                   rb_tunnelWipeActive_g = 0;
                   rw_AfterRSWipeCounterAlt_mg = 50000;
                   rw_AfterRSWipeCounter_mg = 50000;
4 2     ( )( )   if(uF_StatusRainsensor_mg . Bit . B0 == 1)
                   {
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;};
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;};
                   }
                 }
                 else 
4 3     ( )( )   if(uF_Communication_mg . Bit . B3 == 1)
                 {
4 4     ( )( )     if((uF_StatusRainsensor_mg . Bit . B7 == 0)||(rb_TunnelWipeTimeOut_mg >= 50))
                   {
                     uF_Communication_mg . Bit . B3 = 0;
                     rb_TunnelWipeTimeOut_mg = 0;
                   }
                   else
                   {
                     rb_TunnelWipeTimeOut_mg++;
                   }
4 5     ( )( )     if(uF_StatusRainsensor_mg . Bit . B0 == 1)
                   {
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;};
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;};
                   }
                 }
                 else
                 {
4 6     ( )( )     if((uF_StatusRainsensor_mg . Bit . B0 == 1) 
                      && (rb_WiperSpeed_g != 0) 
                        && (rb_WipeWorkStatus_mg == 1))
                   {
4 7     ( )( )       if((RSStatus . Bit . B5 == 0) && (RSStatus . Bit . B6 == 0))
                     {
4 8     ( )( )         if(rw_AfterWWSWipeCounter_mg > 500)
                       {
                         {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;};
                         {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;};
                       }
                       else          
                       {
                         {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 2;};
                         {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 2;};
                       }
                     }
                     else
                     {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 3;};
4 9     ( )( )         if(rb_WiperSpeed_g == 1)
                       {
                         Wiper_speed_l = 2;
                       }
                       else
                       {
                         Wiper_speed_l = rb_WiperSpeed_g;
                       }
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = Wiper_speed_l;};
                     }
                   }
                   else
                   {
                     Exit_Wipe();
                   }  
4 10    ( )( )     if(rb_WiperSpeed_g >0)
                   {
4 11    ( )( )       if(rb_WiperSpeedAlt_g == 0)
                     {
                       rw_AfterRSWipeCounterAlt_mg = rw_AfterRSWipeCounter_mg;
                     }
                     rw_AfterRSWipeCounter_mg = 0;
                   }
                 } 
                 rb_WiperSpeedAlt_g = rb_WiperSpeed_g;
                 uF_Communication_mg . Bit . B4 = uF_modi_lightsens_g . Bit . B2;      
4 12    ( )( ) if(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 == 1)
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainfallAmnt_CEM_LIN1 = 15;};
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainfallAmnt_CEM_LIN1 = rb_RainInt_IntensityOutput_g;};
                 }
               }
               static void LightFunction(void)
               {
                 byte rb_AnyErrorCounterDebounce_l; 
                 byte rb_TempLightOn_l = 0;
                 byte rb_OpModeState = 0;
                 byte rb_crc_StsOutdBriSts = 0;
                /* PRQA S 3415, 4112 1 */ /* << Getter functions must not have side effects >>*/
5 0     ( )    LightFunction
5 1     ( )( ) if ((((((( (rw_SPINoCommCounter_g > 0) || (get_rb_LightVetoCounter_g() > 0) || (get_rb_LightSignalErrorCnt_g() > 0) || (rb_ASIC_SPI_ErrorCodeCnt_g > 0) || (rb_StaticNoValidAD_cnt_g > 0) || (get_rb_VDD_LightSignalErrorCnt_g() > 0) || (get_rb_LEDx_LStop_error_cnt_g() > 0) || (rb_ClockFreq_Error_cnt_g > 0) || (rb_ASIC_ALS2Amb_ShortDetected_cnt_g > 0) || (rb_ASIC_ALS5FW_ShortDetected_cnt_g > 0) || (rb_ASIC_INRECIR_ShortDetected_cnt_g > 0) || (rb_ASIC_initTimeout_g > 0) || (rb_VIref_ErrCnt_g > 0) )) > 0))||(rb_Err_State_Light_Sens_mg > 0))||(((uF_VoltageStatus_g . Bit . B0) == 1))
                      || ((uF_VoltageStatus_g . Bit . B3) == 1)))
                 {
                   rb_AnyErrorCounterDebounce_mg = 250;
                 }
                 else
                 {
5 2     ( )( )   if (rb_AnyErrorCounterDebounce_mg > 0)
                   {
                     rb_AnyErrorCounterDebounce_mg -- ;
                   }
                 }
                 rb_AnyErrorCounterDebounce_l = rb_AnyErrorCounterDebounce_mg; 
5 3     ( )( ) if(rb_Err_State_Light_Sens_mg == 1)
                 {
                   rb_TempLightOn_l = 3;  
                 }
                 else 
5 4     ( )( )   if(((uF_modi_lightsens_g.AllBit & 0x2F) > 0) 
                         || (uF_Main_Flags_g . Bit . B7 > 0) 
                           || ((uF_LightInternalStatus_g . Bit . B6) !=0))
                 {
                   rb_TempLightOn_l = 1;
                 }
                 else
                 {
5 5     ( )( )     if ((rb_AnyErrorCounterDebounce_l == 0) && ((get_rb_LightVetoCounter_g()) == 0))
                   {
                     rb_TempLightOn_l = 2;
                   }
                   else
                   {
                     rb_TempLightOn_l = RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1;
                   }
                 }
5 6     ( )( ) if((uF_Main_Flags_g . Bit . B6 == 0)
                     && ((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x8A ) 
                         ||(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x98)))
                 {
                   rb_TempLightOn_l = 1;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;};   
                 } 
                 else
                 {
                   /* PRQA S 434, 436, 781 7 */ /* <<usind Micro Controller specific command > */
                   MK2L_bit . no4 = 1U;;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;};
                   MK2L_bit . no4 = 0U;;
                 } 
5 7     ( )( ) if(uF_ASIC_ControlFlags_g . Bit . B1 == 0)
                 {
                   rb_TempLightOn_l = 0;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;};
                 }
                 else{}
                 rb_crc_StsOutdBriSts =  GetOutdBriStsCrcj1850(rb_TempLightOn_l);
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriChks_CEM_LIN1 = rb_crc_StsOutdBriSts;};
5 8     ( )( ) if((uF_modi_lightsens_g . Bit . B4 == 1) && (((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x02)>0) == 1))
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 1;};
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 0;};
                 }
5 9     ( )( ) if((uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 0)
                 {
                   rb_OpModeState = 1;
                 }
                 else 
5 10    ( )( )   if(((uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 2) 
                         || ((uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 1))
                 {
                   rb_OpModeState = 0;
                 }
                 else 
5 11    ( )( )     if((uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 4)
                 {
                   rb_OpModeState = 3;
                 }
                 else{}
                 {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . LiOprnMod_CEM_LIN1 = rb_OpModeState;};
               }
               static void Humidity_Function(void)
               {
                 //static word rw_Temperature_Sensor_g;
                 static unsigned int rw_Temperature_Scheibe_g;
6 0     ( )    Humidity_Function
6 1     ( )( ) if (rbi_HumTempComError_g != 0)
                 {
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;};    
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (1360 & 0x07); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((1360 >> 3) & 0xff);};      //window temperature   
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 255;};     // relation hum
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = (2047 & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((2047 >> 8) & 0x07);};  //dew point temperature    
                 }
                 else
                 {
                   //l_bool_wr_CmptFrntWindTErr_CEM_LIN1(0);
                   {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 0;};  
6 2     ( )( )   if(rw_Temperature_raw_g < 0x2ad)                         // The temperature less than -40 the tool doesnot support 
                   {
                     rw_Temperature_Scheibe_g = 0x2ad;
                   }
                   else 
6 3     ( )( )     if(rw_Temperature_raw_g > 0x4321)
                   {
                     rw_Temperature_Scheibe_g = 0x4321;    
                   }
                   else
                   {
                     rw_Temperature_Scheibe_g = rw_Temperature_raw_g;
                   }    
6 4     ( )( )   if(rw_Temperature_raw_g == 0)
                   {
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (1351 & 0x07); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((1351 >> 3) & 0xff);};
                   }
                   else
                   {
6 5     ( )( )     if(((rw_Temperature_Scheibe_g -685)/10) < 1650)
                     {        
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (((rw_Temperature_Scheibe_g -685)/10) & 0x07); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((((rw_Temperature_Scheibe_g -685)/10) >> 3) & 0xff);};
                     }
                     else
                     {         
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (1350 & 0x07); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((1350 >> 3) & 0xff);};
                     }
                   } 
6 6     ( )( )   if (rw_DewPoint_g == 0)
                   {
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = (1651 & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((1651 >> 8) & 0x07);};
                   }    
                   else
                   {
6 7     ( )( )     if (rw_DewPoint_g < 1650)
                     {                                                                       
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((rw_DewPoint_g + 4) & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = (((rw_DewPoint_g + 4) >> 8) & 0x07);};        
                     }
                     else
                     {
                       {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = (1650 & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((1650 >> 8) & 0x07);};
                     }
                   }
6 8     ( )( )   if (rb_Humidity_g == 0)
                   {
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 201;};
                   }        
                   else
                   {        
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = rb_Humidity_raw_g - 1;};
                   }   
                 }
               }
               static void StandByMode(void)
               {
7 0     ( )    StandByMode
7 1     ( )( ) if((rb_Verglasun_ClosedDebounce_mg > 100) 
                    ||(CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 != 1) 
                      || (rw_CommandCloseWindowTimout_mg > 6000))
                 {
                   uF_SCIFlags_mg . Bit . B4 = 0;
                   uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                 }
                 else{}  
7 2     ( )( ) if(uF_SCIFlags_mg . Bit . B0 == 1)
                 {
                   ApplLinInit(0x01);
                   uF_SCIFlags_mg . Bit . B0 = 0;                      
                 }
                 else{}
7 3     ( )( ) if(uF_SCIFlags_mg . Bit . B4 == 1)
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 1;}; 
7 4     ( )( )   if (rw_CommandCloseWindowTimout_mg > 6000)
                   {
                     uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                   }
                   else
                   {
                     rw_CommandCloseWindowTimout_mg++;
                   }
                 }
                 else
                 {
                   rw_CommandCloseWindowTimout_mg = 0;
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 0;};
                 }
               }
               static void VoltageDetect(void)
               {
                 static byte rb_underVoltageTimer_s;
8 0     ( )    VoltageDetect
8 1     ( )( ) if(uF_VoltageStatus_g . Bit . B0 == 1)
                 {
8 2     ( )( )   if(rb_underVoltageTimer_s>249)                       // undervoltagetimer > 249 -> 2500 ms abwarten
                   {
                     uF_VoltageStatus_g . Bit . B7 = 1;
                   }
                   else
                   {
                     rb_underVoltageTimer_s++;                          // increase undervoltagetimer
                   }
                 }
                 else
                 {
                   rb_underVoltageTimer_s=0;                            // loesche Timer
                   uF_VoltageStatus_g . Bit . B7 = 0;
                 }
                 //if(rbi_UnderVoltage_g == TRUE)
                 //{
                 //  //l_u8_wr_L_Err_State_Volt(rbi_UnderVoltage_g);    //voltage error statue
                 //}
8 3     ( )( ) if(uF_VoltageStatus_g . Bit . B3 == 1)
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 1;};  //voltage error statue
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 0;};
                 }     
               }
               //SWRS4 89031 v4 Rain Sensor Diagnostics [CS Released]
               // 1 (1050mV - (3.6mV x 65))/3300mV  x 256 =63 ===>90
               // 1. (1050mV - (3.6mV x 70))/3300mV  x 256 =62 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1050mV 
               //2 (1140mV - (3.9mV x 65))/2417mV  x 1024 =485 ===>90
               //2. (1140mV - (3.9mV x 70))/2417mV  x 1024 =367 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1140mV 
               static void TemperatureDetect(void)
               {
                 static unsigned int rb_overTemperatureTimer_s;
                 byte rb_temperateOver_l = 0;
9 0     ( )    TemperatureDetect
9 1     ( )( ) if(((rb_InternalTemperature_g > 0) && (rb_InternalTemperature_g < 62)) 
                       || ((ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (ras_ASIC_MUX_MeasAD_g[3]. avg < 367)))
                 {
9 2     ( )( )   if(rb_overTemperatureTimer_s>10000)                       
                   {
                     rb_temperateOver_l = 1;
                   }
                   else
                   {
                     rb_overTemperatureTimer_s++;                          
                   }
                 }
                 else 
9 3     ( )( )   if(((rb_InternalTemperature_g > 0) && (rb_InternalTemperature_g< 63)) 
                         || ((ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (ras_ASIC_MUX_MeasAD_g[3]. avg < 485))) 
                 {
9 4     ( )( )     if(rb_overTemperatureTimer_s>10000)                       
                   {
                     rb_temperateOver_l = 1;//continue on
                   }
                   else
                   {
                     rb_overTemperatureTimer_s=0;                            
                     rb_temperateOver_l = 0;                         
                   }
                 }  
                 else
                 {
                   rb_overTemperatureTimer_s=0;                            
                   rb_temperateOver_l = 0;
                 }
                 // ASIC/MCU temperature detect,when over 95 degree,then set.
                 {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiTDetd_CEM_LIN1 = rb_temperateOver_l;}; 
               }
               static void OutPutHudSendCount(void)
               {
                 static byte rb_HUD_Cnt_s = 0;
                 //cnt count 
10 0    ( )    OutPutHudSendCount
                 {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = rb_HUD_Cnt_s;};
10 1    ( )( ) if(rb_HUD_Cnt_s < 15)
                 {
                   rb_HUD_Cnt_s ++;
                 }
                 else
                 {
                   rb_HUD_Cnt_s = 0;
                 }
               }
               static void OutPutHudValue(void)
               {
                 byte rb_hud_Crc8_l;
                 unsigned long rl_hud_Brightness_l;
                 unsigned long rl_hud_AMB_Brightness_l;
                 unsigned long rl_hud_FW_Brightness_l; 
                 unsigned long rl_eeprom_hud_max_l = 0;
                 byte rb_hud_High8Bit_l = 0;
                 unsigned int rw_hud_Low9Bit_l  = 0;
                 /*Get the Real Lux for FW and AMB  Illuminance = FW*6 + AMB*15*/
11 0    ( )    OutPutHudValue
                 rl_hud_AMB_Brightness_l = 15*((unsigned long)(get_rw_Amb_light16bit_g()));
                 rl_hud_FW_Brightness_l = (unsigned long)((3*((unsigned long)(get_rl_HUD_light32bit_g())))>>1);
                 /*Pre-Process for original value get average for "rl_HUD_AMB_Brightness" and "rl_HUD_FW_Brightness"*/
                 /*100ms average for AMB and FW        1000ms for sum average      */
                 GetFiveTableValue_50ms(rl_hud_AMB_Brightness_l,rl_hud_FW_Brightness_l);   
                 /*5000ms for average output*/
                 rl_hud_Brightness_l  = CalcHUDMean_1000ms();
                 /*Output to LIN Interface*/
                 rl_eeprom_hud_max_l = (unsigned long)((unsigned long)EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Resolution * ((unsigned long)EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Value));
11 1    ( )( ) if(rl_hud_Brightness_l >= rl_eeprom_hud_max_l)
                 {
                   rl_hud_Brightness_l = rl_eeprom_hud_max_l;        
                 }
                 else{}
11 2    ( )( ) if(rl_hud_Brightness_l > 126000)//currnet send data  length is shorter
                 {
                   rl_hud_Brightness_l = 126000;
                 } 
                 else{}
                 rw_hud_Low9Bit_l = (unsigned int)((rl_hud_Brightness_l&0x1ff));
                 rb_hud_High8Bit_l  = (byte)((rl_hud_Brightness_l>>9)&0xFF);
                 {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = (rw_hud_Low9Bit_l & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((rw_hud_Low9Bit_l >> 8) & 0x1);};
                 {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = rb_hud_High8Bit_l;};
                 //check crc 
                 rb_hud_Crc8_l = GetHudCrcj1850(rl_hud_Brightness_l);
                 {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = rb_hud_Crc8_l;};
                 /*end hud info relation*/  
               }
               static void OutPutTwliBriValue(void)
               {
12 0    ( )    OutPutTwliBriValue
12 1    ( )( ) if((get_rw_Amb_light16bit_g() * 20) < 16382)    
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((get_rw_Amb_light16bit_g() * 20) & 0x3F); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = (((get_rw_Amb_light16bit_g() * 20) >> 6) & 0xFF);};
                 }
                 else
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = (16382 & 0x3F); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((16382 >> 6) & 0xFF);};
                 } 
               }
               static void OutPutSolarValue(void)
               {
                 unsigned int rw_IrLightforSOSE_Corr1_l;
                 unsigned int rw_IrLightforSOSE_Corr2_l;
                 unsigned int rw_SoSe_SunInt_2D_Le_l;
                 unsigned int rw_SoSe_SunInt_2D_Re_l; 
13 0    ( )    OutPutSolarValue
13 1    ( )( ) if (((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x02)>0) == 1)
                 {
13 2    ( )( )   if ((EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ) > 0)
                   {
                     rw_IrLightforSOSE_Corr1_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ); 
                   }
                   else 
                   {
                     rw_IrLightforSOSE_Corr1_l = 0;  
                   }
13 3    ( )( )   if((rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_2_g))
                   {
                     rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr1_l;
                   }
                   else
                   {
                     rw_SoSe_SunInt_2D_Le_l = rw_Solar_light16bit_2_g ;
                   }
13 4    ( )( )   if((rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_1_g))
                   {
                     rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr1_l;
                   }
                   else
                   {
                     rw_SoSe_SunInt_2D_Re_l = rw_Solar_light16bit_1_g ;
                   }    
13 5    ( )( )   if ((EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ) > 0)
                   {
                     rw_IrLightforSOSE_Corr2_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ); 
                   }
                   else 
                   {
                     rw_IrLightforSOSE_Corr2_l = 0;  
                   }
13 6    ( )( )   if((rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Le_l) && (rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Re_l)) 
                   {
                     rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr2_l;
                     rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr2_l;
                   }
                   rw_SoSe_SunInt_2D_Le_l=(rw_SoSe_SunInt_2D_Le_l>>3)*5;
                   rw_SoSe_SunInt_2D_Le_l=((
13 7    ( )( )   rw_SoSe_SunInt_2D_Le_l>240)?240:rw_SoSe_SunInt_2D_Le_l);
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Le_l;};
                   rw_SoSe_SunInt_2D_Re_l=(rw_SoSe_SunInt_2D_Re_l>>3)*5;
                   rw_SoSe_SunInt_2D_Re_l=((
13 8    ( )( )   rw_SoSe_SunInt_2D_Re_l>240)?240:rw_SoSe_SunInt_2D_Re_l);
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Re_l;};       
                 }
                 else{}
13 9    ( )( ) if(uF_ASIC_ControlFlags_g . Bit . B2 == 0)
                 {
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 254;};
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 254;};
                 }
               }
               static void OutPutBrightnessValue(void)
               {
                 static byte rb_InitLightValCnt_l=100;
14 0    ( )    OutPutBrightnessValue
14 1    ( )( ) if((uF_ASIC_ControlFlags_g . Bit . B1 == 0)|| (uF_Main_Flags_g . Bit . B6 == 1))
                 {
14 2    ( )( )   if(rb_InitLightValCnt_l<100)
                   {
                     rb_InitLightValCnt_l++;
                   }
                   else
                   { 
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = (0 & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((0 >> 8) & 0x1);};
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0;};
               			{RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = 0xF1;};
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = (0 & 0x3F); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((0 >> 6) & 0xFF);};
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 1;};
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 254;};        // Init 
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 254;};         // Init
                   }
                 }
                 else
                 {
                   rb_InitLightValCnt_l=0;
14 3    ( )( )   if(rb_Err_State_Light_Sens_mg == 1)                    /*  VDR469   set for error*/
                   {
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = (0x1FF & 0xff); RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((0x1FF >> 8) & 0x1);};
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0xFF;};
                     {RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = 0xA3;};
                     {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = (16383 & 0x3F); RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((16383 >> 6) & 0xFF);};
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;};                            /* Init*/
                     {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;};                             /* Init*/
                   }
                   else
                   {  
                     OutPutHudValue(); 
                     OutPutTwliBriValue();
                     OutPutSolarValue();
                   }
                 } 
               }
               #pragma inline=forced
               static void CheckErrors(void)
               {
                 byte rb_hud_errorParity_l = 0;
15 0    ( )    CheckErrors
                 rb_RS_LS_Error1_g = ((uF_Diagnose_pre_Flag . Bit . B1) | 
                                      ((uF_Diagnose_pre_Flag . Bit . B0)<<1) | 
                                        ((uF_Check_lightsensor_g . Bit . B3)<<2) | 
                                          (uF_ASIC_Error_Flags_g . Bit . B3<<3) | 
                                            (uF_ASIC_Ctrl_Error_Flags_g . Bit . B5<<4) | 
                                              (uF_ASIC_Ctrl_Error_Flags_g . Bit . B0<<5) | 
                                                (uF_ASIC_Ctrl_Error_Flags_g . Bit . B1<<6) | 
                                                  (uF_ASIC_Ctrl_Error_Flags_g . Bit . B4<<7));
                 /*VCO_220 VIrefLo/Hi monitoring*/ /*VDR_878*/
                 rb_RS_LS_Error2_g = (uF_ASIC_Ctrl_Error_Flags_g . Bit . B3 | 
                                      ((uF_uC_Error_g . Bit . B1)<<1) | 
                                        (uF_ASIC_Error_Flags_g . Bit . B5<<2) |
                                          (uF_ASIC_Error_Flags_g . Bit . B7<<3) |
                                            (uF_ASIC_Error_Flags1_g . Bit . B0<<4));
                 /*VCO_225 RS functionality detection - error when not available*/
                 (uF_Diagnose_pre_Flag . Bit . B3) = 0;
                 rb_RainS_Error1_g = (RSStatus . Bit . B4 | 
                                      (uF_ASIC_Ctrl_Error_Flags_g . Bit . B2<<1) |
                                        (uF_ASIC_Error_Flags_g . Bit . B6<<2)|
                                          ((uF_Diagnose_pre_Flag . Bit . B3)<<3)|
                                            ((uF_uC_Error_g . Bit . B0)<<4));  
                 rb_LightS_Error1_g = ((uF_LightInternalStatus_g . Bit . B5) | 
                                       (rb_ASIC_ALSx_ShortDetected_Error_g<<1) | 
                                         ((uF_Diagnose_pre_Flag . Bit . B2)<<2) | 
                                           (uF_ASIC_Error_Flags_g . Bit . B4<<3)| 
                                             ((uF_Diagnose_pre_Flag . Bit . B4) << 4));
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErrActv_CEM_LIN1 = 1;};  
                 //15:RLFS 7:RLS
15 1    ( )( ) if((EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 15) || (EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 7))
                 {
                   /* VCO132: SM210 - ASIC Frequency Check (done at startup) - LS,RS_Failure */
                   /* VCO 140: SM150 - ADC test */
                   /* setze Lichtsensor RS-Fehler nach SRS */
                   /*SM240*/
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 = (rb_RS_LS_Error1_g != 0) || (rb_RS_LS_Error2_g != 0) || (rb_RainS_Error1_g != 0) || (uF_E2ConfigErrorFlags_g . Bit . B6 != 0);};
                 }
15 2    ( )( ) if(((rb_RS_LS_Error1_g != 0) 
                     || (rb_RS_LS_Error2_g != 0) 
                       || (rb_LightS_Error1_g != 0) 
                         || (uF_E2ConfigErrorFlags_g . Bit . B6 != 0) 
                           || (uF_LIN_DiagReq2_mg . Bit . B1)))
                 {
                   rb_Err_State_Light_Sens_mg = 1;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 0;};
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrErr_CEM_LIN1 = 1;};
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1 = 1;};
                 }
                 else
                 {
                   rb_Err_State_Light_Sens_mg = 0;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 3;};
                   {RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrErr_CEM_LIN1 = 0;};
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1 = 0;};
                 }
                 rb_hud_errorParity_l = IsByteOddParity(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1);
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrParChk_CEM_LIN1 = rb_hud_errorParity_l;};
               }
               void ApplLinInit(byte rb_LIN_State_l)
               {
                 byte rb_Index_l; 
                 static const byte LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[4] = {0,0,0,0};/*0x22*/
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};/*0x18*/
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[7] = {0,0,0,0,0,0,0};/*0x20*/
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[8] = {0,14,50,50,0,0,0,0};/*0x02*/
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[8] = {88,2,0,0,0,0,75,80};/*0x2C*/
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[8] = {0,0,0,1,0,0,0,0};/*0x15*/
16 0    ( )    ApplLinInit
                 rb_Index_l = 0;
                 do
                 {
                   RlsmCem_SerNrLin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1PartNrFr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1PartNrFr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1Fr03_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1Fr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[rb_Index_l];
                   RlsmCem_Lin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[rb_Index_l];
                   rb_Index_l++;
                 } while (
16 1    ( )( )   rb_Index_l < 8);
                 rw_AfterRSWipeCounter_mg = 50000;
                 rw_AfterRSWipeCounterAlt_mg = 50000;
                 rw_AfterWWSWipeCounter_mg = 50000;//Direktbitdelay bei Kl15 Aus hochsetzen!
                 sci_init(rb_LIN_State_l);
                 uF_SCIFlags_mg . Bit . B6 = 1;
                 uF_StatusRainsensor_mg . Bit . B7 = 1;
                 rb_PotiStageFromBox_g = 3;  
                 rw_WipeCommandTimOut_mg = 0; 
                 rb_AnyErrorCounterDebounce_mg = 200;  
                 rb_WipeWorkStatus_mg = 1;  
               }
               __callt void ApplLinSlavePreCopy(byte rb_MessageID_l)                                     /* callt function faster */
               {
17 0    ( )    ApplLinSlavePreCopy
17 1    ( )( ) if(rb_MessageID_l == (EEPROM_Struct_PD . EEPROMStructPD . IDRLSs_01 & 0x3F))
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . ErrRespRLSM_CEM_LIN1 = uF_Communication_mg . Bit . B6;};
                   //l_u8_wr_L_Signal_Error(rbi_latched_ResponseError_mg);
                   uF_Communication_mg . Bit . B6 = 0;
                 } 
                 else{}
               }
               /*HUD Algrithm shenzhen-team 2018-05-05*/
               static void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_50ms)
               {
                 static byte rb_k_cycleIn50ms=0;
                 static byte rb_k_cycleIn500ms=0;
18 0    ( )    GetFiveTableValue_500ms
                 rb_storeHUDValueEvery500ms[rb_k_cycleIn50ms] = rl_HUD_Brightness_50ms;
                 rb_k_cycleIn50ms++;
18 1    ( )( ) if(rb_k_cycleIn50ms >= 10)
                 {
                   rb_k_cycleIn50ms = 0;
                   orderHUDValue(10);
                   HUDEverageValue[rb_k_cycleIn500ms] = ((rb_storeHUDValueEvery500ms[3] 
                                                          + rb_storeHUDValueEvery500ms[4] 
                                                            + rb_storeHUDValueEvery500ms[5] 
                                                              + rb_storeHUDValueEvery500ms[6] 
                                                                + rb_storeHUDValueEvery500ms[7]) 
                                                                  / 5);
                   rb_k_cycleIn500ms++;
18 2    ( )( )   if(rb_k_cycleIn500ms >= 2)
                   {
                     rb_k_cycleIn500ms=0;  
                     rb_hud_data_update = 1;
                   }    
                 }
               }
               static unsigned long AdjustOutHudValue(unsigned long rl_CurrentHud)
               {
                 unsigned int currLevel = 0;
                 unsigned int rw_LastCurrDiff = 0;
                 unsigned long  rl_adjustAfterHud = 0;
19 0    ( )    AdjustOutHudValue
19 1    ( )( ) if(rl_CurrentHud >= 100)
                 {
                   return rl_CurrentHud;
                 }
                 else{}
                 currLevel = RW_Amb_Fw_Result_End / 10;  
19 2    ( )( ) if(rl_CurrentHud >= RW_Amb_Fw_Result_End)
                 {
                   rw_LastCurrDiff = rl_CurrentHud - RW_Amb_Fw_Result_End;
                 }
                 else
                 {
                   rw_LastCurrDiff = RW_Amb_Fw_Result_End - rl_CurrentHud;
                 }
19 3    ( )( ) if(rw_LastCurrDiff <= 15)
                 {
                   return  rl_CurrentHud;
                 }
                 else{}
19 4    ( )( ) if(rl_CurrentHud >= RW_Amb_Fw_Result_End)
                 {
                   currLevel = currLevel + (rw_LastCurrDiff / 15);
                   rw_LastCurrDiff = rw_LastCurrDiff % 3;
19 5    ( )( )   if(currLevel > 9)
                   {
                     rl_adjustAfterHud = 92 + (unsigned long)rw_LastCurrDiff;
                   }
                   else
                   {
                     rl_adjustAfterHud = 5 + (currLevel * 10) + (unsigned long)rw_LastCurrDiff;
                   }
                 }
                 else
                 {
19 6    ( )( )   if(currLevel >= (rw_LastCurrDiff / 15))
                   {
                     currLevel = currLevel - (rw_LastCurrDiff / 15);
                     rw_LastCurrDiff = rw_LastCurrDiff % 3;
19 7    ( )( )     if(currLevel > 9)
                     {
                       rl_adjustAfterHud = 92 - (unsigned long)rw_LastCurrDiff;
                     }
                     else
                     {
                       rl_adjustAfterHud = ((5 + (currLevel * 10)) - (unsigned long)rw_LastCurrDiff);
                     }
                   }
                   else
                   {
                     rw_LastCurrDiff = rw_LastCurrDiff % 3;
                     rl_adjustAfterHud = 5 - (unsigned long)rw_LastCurrDiff;
                   }
                 }
                 return  rl_adjustAfterHud;    
               }
               static byte GetUpdateTimeForLightStatus(void)
               {
                 unsigned char  hud_refresh_time = 1;  
                 //1 in tunnel and day for 1s  get data;in night and darkstart for 3s  get data 
                 //2 if in tunnel and speed less 10,then 3s will upate
20 0    ( )    GetUpdateTimeForLightStatus
20 1    ( )( ) if(((uF_LightInternalStatus_g . Bit . B0) == 1) && (uF_Main_Flags_g . Bit . B6 == 0))
                 {
20 2    ( )( )   if((uF_modi_lightsens_g.AllBit & (byte) 2) > 0)
                   {
                     hud_refresh_time = 3;
                   }
                   else 
20 3    ( )( )     if ((uF_modi_lightsens_g.AllBit & (byte) 4) > 0)
                   {
20 4    ( )( )       if(rb_speed_in_kmh_g >= 10)
                     {
                       hud_refresh_time = 1;
                     }
                     else
                     {
                       hud_refresh_time = 3;
                     }   
                   }
                   else 
20 5    ( )( )       if ((uF_modi_lightsens_g.AllBit & (byte) 1) > 0)
                   {
                     hud_refresh_time = 3;
                   }
                   else
                   {
                     hud_refresh_time = 1;  
                   }
                 }
                 else
                 {
                   hud_refresh_time = 1;  
                 }  
                 return  hud_refresh_time;
               }
               static unsigned long CalcHUDMean_1000ms(void)
               {  
                 static  unsigned char RW_Update_Time_Count = 0;
                 unsigned long  rl_current_hud_lux = 0;
                 unsigned char  rb_hud_refresh_time = 1;
21 0    ( )    CalcHUDMean_1000ms
21 1    ( )( ) if(rb_hud_data_update == 1)
                 {
                   rb_hud_data_update = 0;
                   rb_hud_refresh_time = GetUpdateTimeForLightStatus();
21 2    ( )( )   if(RW_Update_Time_Count < rb_hud_refresh_time)
                   {
                     RW_Update_Time_Count++;  
                   }
                   else{}
                   //internal data updata time is 1s
                   //Data send to BCM is decided for  RW_Update_Time_Count and rb_hud_refresh_time
                   //if rl_current_hud_lux and RW_Amb_Fw_Result_End  are less than 100, we will get average value
                   rl_current_hud_lux = (HUDEverageValue[0] + HUDEverageValue[1])/2; 
21 3    ( )( )   if((rl_current_hud_lux < 100) && (RW_Amb_Fw_Result_End < 100))
                   {        
                     rl_current_hud_lux = (RW_Amb_Fw_Result_End +rl_current_hud_lux)/2;
                   }  
21 4    ( )( )   if(rb_hud_refresh_time <= RW_Update_Time_Count)//refresh time is reached
                   {   
                     RW_Update_Time_Count = 0;        
                     RW_Amb_Fw_Result_End = AdjustOutHudValue(rl_current_hud_lux);         
                   }
                   else{}    
                 }  
                 return RW_Amb_Fw_Result_End;
               }
               /*****Bubble Sort**********/
               static void orderHUDValue(int n)
               {
                 unsigned long rb_temp_l = 0;
                 int i =0;
                 int j = 0;
22 0    ( )    orderHUDValue
22 1    ( )( ) for(i = 0;i < n;i++)
                 {
22 2    ( )( )   for(j = 1;j < (n-i);j++)
                   {    
22 3    ( )( )     if(rb_storeHUDValueEvery500ms[j-1] > rb_storeHUDValueEvery500ms[j])
                     {
                       rb_temp_l = rb_storeHUDValueEvery500ms[j];
                       rb_storeHUDValueEvery500ms[j] = rb_storeHUDValueEvery500ms[j-1];
                       rb_storeHUDValueEvery500ms[j-1] = rb_temp_l ;
                     }
                     else{}
                   }
                 }
               }
               static void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb)
               {
                 static unsigned long FW_Average_In_50ms = 0;
                 static unsigned long AMB_Average_In_50ms = 0;
                 static unsigned long FW_Average_In_50ms_Old = 0;
                 static unsigned long AMB_Average_In_50ms_Old = 0;
                 static unsigned long rb_storeFW_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
                 static unsigned long rb_storeAMB_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
                 static unsigned char rb_k_cycleIn50ms=0;
                 unsigned char rb_count = 0;
23 0    ( )    GetFiveTableValue_50ms
                 rb_storeFW_ValueEvery50ms[rb_k_cycleIn50ms] = Fw;
                 rb_storeAMB_ValueEvery50ms[rb_k_cycleIn50ms] = Amb;
                 rb_k_cycleIn50ms++;
23 1    ( )( ) if(rb_k_cycleIn50ms >= 5)
                 {
                   rb_k_cycleIn50ms = 0;
                   FW_Average_In_50ms = rb_storeFW_ValueEvery50ms[0];
23 2    ( )( )   for(rb_count = 1;rb_count < 5;rb_count++)
                   {
                     FW_Average_In_50ms =(FW_Average_In_50ms+ rb_storeFW_ValueEvery50ms[rb_count])/2;
                   }
                   AMB_Average_In_50ms=rb_storeAMB_ValueEvery50ms[0];
23 3    ( )( )   for(rb_count = 1;rb_count < 5;rb_count++)
                   {
                     AMB_Average_In_50ms =(AMB_Average_In_50ms+ rb_storeAMB_ValueEvery50ms[rb_count])/2;
                   } 
                   FW_Average_In_50ms = (FW_Average_In_50ms_Old+FW_Average_In_50ms)/2 ;
                   AMB_Average_In_50ms = (AMB_Average_In_50ms_Old +AMB_Average_In_50ms)/2; 
                   GetFiveTableValue_500ms(FW_Average_In_50ms + AMB_Average_In_50ms);
                   FW_Average_In_50ms_Old = FW_Average_In_50ms;
                   AMB_Average_In_50ms_Old = AMB_Average_In_50ms;
                 }  
               }
               /******************************************End*********************************************/
               /*byte resultCrcTest = 0;
               void TestCrcJ1850Info(void)
               {
                   byte buffer[4]={0x00,0x00,0x00,0x00};//0x59
                   byte buffer1[3]={0xF2,0x01,0x83};//0x37
                   byte buffer2[4]={0x0F,0xAA,0x00,0x55};//0x79
                   byte buffer3[4]={0x00,0xFF,0x55,0x11};//0xB8
                   byte buffer4[9]={0x33,0x22,0x55,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};//0xcb
                   byte buffer5[3]={0x92,0x6B,0x55};//0x8C
                   byte buffer6[4]={0xFF,0xFF,0xFF,0xFF};//0x74
                   resultCrcTest =  CRC8SAEJ1850(buffer,4); //ok
                   resultCrcTest =  CRC8SAEJ1850(buffer1,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer2,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer3,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer4,9);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer5,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer6,4);//ok
               }*/
               static byte CRC8SAEJ1850(const byte * u8_data,byte u8_len)
               {
                 byte i, j;
                 byte u8_crc8;
                 byte u8_poly;
24 0    ( )    CRC8SAEJ1850
                 u8_crc8 = 0xFF;
                 u8_poly = 0x1D;
24 1    ( )( ) for (i = 0; i < u8_len; i++)
                 {
                   u8_crc8 ^= u8_data[i];
24 2    ( )( )   for (j = 0; j < 8; j++)
                   {
24 3    ( )( )     if ((u8_crc8 & 0x80) > 0)
                     {
                       u8_crc8 = (u8_crc8 << 1) ^ u8_poly;
                     }
                     else
                     {
                       u8_crc8 <<= 1;
                     }
                   }
                 }
                 u8_crc8 ^= (byte)0xFF;
                 return u8_crc8;
               }
               static byte GetOutdBriStsCrcj1850(byte OutdBriSts)
               {  
                 byte buffer[1];
25 0    ( )    GetOutdBriStsCrcj1850
                 buffer[0] = OutdBriSts;
                 //TestCrcJ1850Info();
                 return CRC8SAEJ1850(buffer,1);  
               }
               static byte GetHudCrcj1850(unsigned long hudSrc)
               {     
                 //byte buffer[2];
                 //buffer[0] = hudSrc&0xFF;
                 //buffer[1] = (hudSrc>>8)&0xFF;      
                 //return CRC8SAEJ1850(buffer,2);
                 /**********Zhiyuan HU 20190313**************/
                 byte buffer[3];
26 0    ( )    GetHudCrcj1850
                 buffer[0] = hudSrc&0xFF;
                 buffer[1] = (hudSrc>>8)&0xFF;
                 buffer[2] = (hudSrc>>16)&0xFF;
                 return CRC8SAEJ1850(buffer,3);
                 /**********Zhiyuan HU 20190313**************/
               }
               static void GetLightTransmission(byte trans_550nm,byte trans_880nm)
               {
                 byte rb_880nm_Transmission_local_Coding = 0;
                 byte rb_550nm_Transmission_local_Coding = 0;
                 //byte rb_550nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 //byte rb_880nm_Transmission_local_Coding_outOfRangeFlag = 0;
27 0    ( )    GetLightTransmission
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErr_CEM_LIN1 = 0;};
27 1    ( )( ) if(((trans_550nm >= 15) && (trans_550nm <= 90)) && ((trans_880nm >= 15) && (trans_880nm <= 90)))
                 {
                   rb_550nm_Transmission_local_Coding = ((trans_550nm - 15 ) + 2) / 5;
                   rb_880nm_Transmission_local_Coding = ((trans_880nm - 15 ) + 2) / 5;
27 2    ( )( )   if((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte2_g != ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding)) 
                      && ((uF_Main_Flags_g . Bit . B2 == 0)||(uF_Main_Flags_g . Bit . B1 == 1)))
                   {
                     rab_EEPROM_Bytes_toWrite_g[0] = ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding);
                     rw_EEPROM_Address_to_Write_g = (268); /*set adress to write*/
                     rb_I2C_EEPROM_bytesToWrite_g = 1;         /*set number of bytes to 1*/
                     uF_Main_Flags_g . Bit . B2 = 1;
                     uF_Main_Flags_g . Bit . B1 = 0;
                   }
                 }
               }
               static void Set_BCMLightOffset(byte offset)
               {
                 static byte rb_lightValueDebounce = 0;
                 byte rb_OldSensorLs ;
                 byte rb_Kodierbyte0_Update_g; 
28 0    ( )    Set_BCMLightOffset
28 1    ( )( ) if(rb_lightValueDebounce < 20)//if 100MS run once ,2s delay check
                 {
                   rb_lightValueDebounce ++;
                   return ;
                 }
                 /*check if the E2PROM data has been loaded*/
28 2    ( )( ) if(uF_Main_Flags_g . Bit . B6 == 1)
                 {
                   return ;
                 }
                 rb_OldSensorLs = (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g& 0x38)>>3;
                 rb_Kodierbyte0_Update_g = EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g; 
28 3    ( )( ) if((offset < 8) 
                    && (rb_OldSensorLs != offset) 
                      && ((uF_Main_Flags_g . Bit . B2 == 0)||(uF_Main_Flags_g . Bit . B1 == 1)))
                 {
                   rb_Kodierbyte0_Update_g &=0xC7; 
                   rb_Kodierbyte0_Update_g |=(offset << 3); 
                   rab_EEPROM_Bytes_toWrite_g[0] = rb_Kodierbyte0_Update_g;
                   rw_EEPROM_Address_to_Write_g = (268)+2; 
                   rb_I2C_EEPROM_bytesToWrite_g = 1;         
                   uF_Main_Flags_g . Bit . B2 = 1;
                   uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               static void SendRLSSerNo(void)
               {
                 unsigned long d = 0;
                 byte a,b,c,e,f,g,h;
29 0    ( )    SendRLSSerNo
                 a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(0)]));
                 b = a / 16;
                 c = a % 16;
                 d = (b * 10000000) + (c * 1000000);
                 a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(1)]));
                 b = a / 16;
                 c = a % 16;
                 d = (b * 100000) + (c * 10000) + d;
                 a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(2)]));
                 b = a / 16;
                 c = a % 16;
                 d = (b * 1000) + (c * 100) + d;
                 a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(3)]));
                 b = a / 16;
                 c = a % 16;
                 d = (b * 10) + (c * 1) + d;
                 e = (d >> 0) & 0xff;
                 f = (d >> 8) & 0xff;
                 g = (d >> 16) & 0xff;
                 h = (d >> 24) & 0xff;
                 {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr1_CEM_LIN1 = h;};
                 {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr2_CEM_LIN1 = g;};
                 {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr3_CEM_LIN1 = f;};
                 {RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr4_CEM_LIN1 = e;};
               }
               static void SendRLSMPartNo(void)
               {
30 0    ( )    SendRLSMPartNo
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr1_CEM_LIN1 = 0;};
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr2_CEM_LIN1 = 0;};
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr3_CEM_LIN1 = 0;};
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr4_CEM_LIN1 = 0;};
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn1_CEM_LIN1 = 0x20;};
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn2_CEM_LIN1 = 0x20;};
                 {RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn3_CEM_LIN1 = 0x20;};
               }
               static void SendRLSMPartNo10(void)
               {
31 0    ( )    SendRLSMPartNo10
31 1    ( )( ) if(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 15)
                 {
                   //15:RLFS
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x89;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x07;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x24;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x28;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 0x46;};
                 }
                 else 
31 2    ( )( )   if(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 7)
                 {
                   //7:RLS
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x99;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x81;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 66;};
                 }
                 else 
31 3    ( )( )     if(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 14)
                 {
                   //14:LFS
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x99;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x81;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x23;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 66;};
                 }
                 else 
31 4    ( )( )       if(EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 6)
                 {
                   //6:LS
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x88;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x99;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x81;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x13;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;};
                   {RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 66;};
                 }
                 else{}
               }
               /*T < 0 degree and Speed is under 5KM/H.*/
               static void WipeWinterModeCheck(void)
               {  
32 0    ( )    WipeWinterModeCheck
32 1    ( )( ) if(rb_speed_in_kmh_g > 5)
                 {
                   Vehicle_Speed_Decision_Flag = 1;
                 }
32 2    ( )( ) if((Vehicle_Speed_Decision_Flag == 0) && (rb_OutsideTemp_mg < 80))
                 {
                   rb_WipeWorkStatus_mg = 2;
                 }
                 else
                 {
                   rb_WipeWorkStatus_mg = 1;
                 } 
               }
               static byte IsByteOddParity(byte data)
               {
                 byte parity = 0;
33 0    ( )    IsByteOddParity
33 1    ( )( ) while (data != 0)
                 {
                   parity = !parity;
                   data = 0;
                 }
                 return (!parity);
               }
               static void Rain_sensitivity(void)
               { 
34 0    ( )    Rain_sensitivity
34 1    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty0_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[0] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[0] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty0_CEM_LIN1*2;
                 }
34 2    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty1_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[1] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[1] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty1_CEM_LIN1*2; 
                 }
34 3    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty2_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[2] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[2] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty2_CEM_LIN1*2;
                 }
34 4    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty3_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[3] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[3] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty3_CEM_LIN1*2; 
                 }
34 5    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty4_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[4] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[4] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty4_CEM_LIN1*2;
                 }
34 6    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty5_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[5] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[5] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty5_CEM_LIN1*2;
                 }
34 7    ( )( ) if(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty6_CEM_LIN1 == 0)
                 {
                   rb_RLS_Sensitivity_Array_l[6] = 1;
                 }
                 else
                 {
                   rb_RLS_Sensitivity_Array_l[6] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty6_CEM_LIN1*2;
                 }      
                 Rain_Sensitivity_Judge();
               }
               static void Get_Lin_Signal_From_GetLeWWS(void)
               {  
35 0    ( )    Get_Lin_Signal_From_GetLeWWS
35 1    ( )( ) if((uLinIndicationFlags . w[0]. b5 != 0))
                 {
                   {uLinIndicationFlags . w[0]. b5 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
35 2    ( )( )   if(CemCem_Lin1Fr02_CEM_LIN1 . cemcem_lin1fr02_cem_lin1 . AmbTForVisy_CEM_LIN1 != 255)
                   {
                     rb_OutsideTemp_mg = CemCem_Lin1Fr02_CEM_LIN1 . cemcem_lin1fr02_cem_lin1 . AmbTForVisy_CEM_LIN1;
                   }
                   WipeWinterModeCheck(); 
                 }
35 3    ( )( ) if((uLinIndicationFlags . w[0]. b4 != 0))
                 {
                   {uLinIndicationFlags . w[0]. b4 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErrActv_CEM_LIN1 = 1;};     
                   //Get_BCMVehType(l_u8_rd_VehTyp_CEM_LIN1());
                   GetLightTransmission(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValFrnt_CEM_LIN1,CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValAmb_CEM_LIN1);
                   Rain_sensitivity();
                 }
35 4    ( )( ) if((uLinIndicationFlags . w[0]. b3 != 0))
                 {
                   {uLinIndicationFlags . w[0]. b3 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   Set_BCMLightOffset(CemCem_Lin1Fr04_CEM_LIN1 . cemcem_lin1fr04_cem_lin1 . RainSnsrLiThd_CEM_LIN1);
                 }
35 5    ( )( ) if((uLinIndicationFlags . w[0]. b2 != 0))
                 {
                   {uLinIndicationFlags . w[0]. b2 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
                 }
35 6    ( )( ) if((uLinIndicationFlags . w[0]. b1 != 0))
                 { 
                   {uLinIndicationFlags . w[0]. b1 = 0;};
                   uF_SCIFlags_mg . Bit . B1 = 1;
                   uF_SCIFlags_mg . Bit . B6 = !(CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WiprInWipgAr_CEM_LIN1);        // wiper position
35 7    ( )( )   if (CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 == 1)                                 /* Washpump activ? 0x5:Front washing*/
                   {
                     RSStatus . Bit . B1 = 1;                                       /* set Washing activ bit */
                   }
                   else 
35 8    ( )( )     if (uF_StatusRainsensor_mg . Bit . B7 == 1)                                /* In Parkposition ? */
                   {
                     RSStatus . Bit . B1 = 0;                                      /* Clear Washing active bit */
                   }
                   else{}                                                              /*Do nothing, Dummy-else for Misra Check*/
                 }  
               }
               static void Light_Sensitivity_In_GetLeWWS(void)
               {
                 static const byte cab_PotistageMapping_mg[8] = {4,5,6,7,3,2,1,0}; /*mapping for potistages!*/  
                 byte rb_Empfindlichkeit_LS_l;
36 0    ( )    Light_Sensitivity_In_GetLeWWS
                 rb_Empfindlichkeit_LS_l = 3;
36 1    ( )( ) if((cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)>3)
                 {
                   rb_LSPotiStage_g = (cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)-3;
36 2    ( )( )   if(rb_LSPotiStage_g>7)
                   {
                     rb_LSPotiStage_g=7;
                   }
                 }
                 else
                 {
                   rb_LSPotiStage_g = 0;
                 }
36 3    ( )( ) if (rb_AfterResetCounter_l<250)
                 {
                   rb_AfterResetCounter_l++;
                 }
                 else{}
36 4    ( )( ) if(rw_IgnitionOffDelay_mg < 1000)                                     /* 10sec delay */
                 {
                   rw_IgnitionOffDelay_mg++;
                 }
                 else
                 {
                   rb_Release_IntervalMarker_Update_g |= 0xA0;
                   uF_StatusRainsensor2_mg . Bit . B2 = 0;
                 }
               }
               static void Wiper_and_Park(void)
               {
                 static byte rb_OutOffParkCounter_mg;
37 0    ( )    Wiper_and_Park
37 1    ( )( ) if(CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 0)
                 {
                   rw_AfterRSWipeCounter_mg = 50000;
                   rw_AfterWWSWipeCounter_mg = 50000;
                   rw_WipeCommandTimOut_mg = 0;
                 }
                 else{}
37 2    ( )( ) if(uF_SCIFlags_mg . Bit . B6 == 0)     
                 {
37 3    ( )( )   if (rb_OutOffParkCounter_mg > 18) 
                   {
                     rw_AfterWWSWipeCounter_mg = 0;
                   }
                   else
                   {
                     rb_OutOffParkCounter_mg ++;
                   }
                 }
                 else
                 {                                            //wiper in park position
                   rb_OutOffParkCounter_mg = 0;
37 4    ( )( )   if (rw_AfterWWSWipeCounter_mg < 50000)
                   {
                     rw_AfterWWSWipeCounter_mg++;
                   }
                 }
37 5    ( )( ) if (rw_AfterRSWipeCounter_mg < 50000)        //Delay for Tunnel wipe function
                 {
                   rw_AfterRSWipeCounter_mg++;   
                 }  
               }
               static void Tunnel_Wipe_Decision(void)
               {
38 0    ( )    Tunnel_Wipe_Decision
38 1    ( )( ) if((rw_AfterRSWipeCounterAlt_mg <= (((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv>>4))*100))
                    &&(rb_speed_in_kmh_g > 29)
                      &&(uF_modi_lightsens_g . Bit . B2 == 1)
                        &&(rub_RSIntermDelayInit == 0xFF))
                 {
38 2    ( )( )   if ((uF_Communication_mg . Bit . B4 == 0) && (rw_AfterRSWipeCounter_mg < (((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv&0x0F))*100)))
                   {
                     rb_tunnelWipeActive_g = 1;
                   }
                 }
                 else
                 {
                   rb_tunnelWipeActive_g = 0;
                 }  
               }
               static void Exit_Wipe(void)
               {
39 0    ( )    Exit_Wipe
39 1    ( )( ) if(uF_SCIFlags_mg . Bit . B6 == 0)
                 {
                 }
                 else
                 {
39 2    ( )( )   if(rw_AfterWWSWipeCounter_mg > 3000)
                   {
39 3    ( )( )     if(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 > 0)
                     {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;};
                     }
                   }
                   else 
39 4    ( )( )     if(rw_AfterWWSWipeCounter_mg > 500)
                   {
39 5    ( )( )       if(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 > 1)
                     {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;};
                     }
                   }
                   else
                   {
39 6    ( )( )       if(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 > 2)
                     {
                       {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 2;};
                     }
                   }
                 }
39 7    ( )( ) if(uF_StatusRainsensor_mg . Bit . B0 == 0)
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;};
                 }
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;};
39 8    ( )( ) if(rb_WipeWorkStatus_mg == 2)
                 {
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;};
                   {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;};
                 }
               }
               static void Rain_Sensitivity_Judge(void)
               {
                 byte rb_Loop_Counter = 0;
40 0    ( )    Rain_Sensitivity_Judge
40 1    ( )( ) if((rb_RLS_Sensitivity_Array_l[0] < rb_RLS_Sensitivity_Array_l[1]) 
                      && (rb_RLS_Sensitivity_Array_l[1] < rb_RLS_Sensitivity_Array_l[2]) 
                        && (rb_RLS_Sensitivity_Array_l[2] < rb_RLS_Sensitivity_Array_l[3]) 
                          && (rb_RLS_Sensitivity_Array_l[3] < rb_RLS_Sensitivity_Array_l[4])
                            && (rb_RLS_Sensitivity_Array_l[4] < rb_RLS_Sensitivity_Array_l[5]) 
                              && (rb_RLS_Sensitivity_Array_l[5] < rb_RLS_Sensitivity_Array_l[6]))
                 {
40 2    ( )( )   if((rb_RLS_Sensitivity_Array_l[0] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[0]) 
                       || (rb_RLS_Sensitivity_Array_l[1] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[1]) 
                         || (rb_RLS_Sensitivity_Array_l[2] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[2]) 
                           || (rb_RLS_Sensitivity_Array_l[3] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[3]) 
                             || (rb_RLS_Sensitivity_Array_l[4] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[4]))
                   {
40 3    ( )( )     if((uF_Main_Flags_g . Bit . B1 == 1) || (uF_Main_Flags_g . Bit . B2 == 0))
                     {
40 4    ( )( )       for(rb_Loop_Counter = 0;rb_Loop_Counter < 5;rb_Loop_Counter++)
                       {
                         rab_EEPROM_Bytes_toWrite_g[rb_Loop_Counter] = rb_RLS_Sensitivity_Array_l[rb_Loop_Counter];
                       }  
                       rw_EEPROM_Address_to_Write_g = 597;
                       rb_I2C_EEPROM_bytesToWrite_g = 5;         /*set number of bytes to 5*/
                       uF_Main_Flags_g . Bit . B2 = 1;    //set flag for bytes to write
                       uF_Main_Flags_g . Bit . B1 = 0;   //clear bytes written (reset EEPROM bytes Written!)          
                     }
                     else{}
                   }
                   else{}
40 5    ( )( )   if((rb_RLS_Sensitivity_Array_l[5] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[5]) 
                      || (rb_RLS_Sensitivity_Array_l[6] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[6])) 
                   {
40 6    ( )( )     if((uF_Main_Flags_g . Bit . B1 == 1) || (uF_Main_Flags_g . Bit . B2 == 0))
                     {
40 7    ( )( )       for(rb_Loop_Counter = 0;rb_Loop_Counter < 2;rb_Loop_Counter++)
                       {
                         rab_EEPROM_Bytes_toWrite_g[rb_Loop_Counter] = rb_RLS_Sensitivity_Array_l[rb_Loop_Counter + 5];
                       }  
                       rw_EEPROM_Address_to_Write_g = 602;
                       rb_I2C_EEPROM_bytesToWrite_g = 2;         /*set number of bytes to 4*/
                       uF_Main_Flags_g . Bit . B2 = 1;    //set flag for bytes to write
                       uF_Main_Flags_g . Bit . B1 = 0;   //clear bytes written (reset EEPROM bytes Written!)      
                     }
                     else{}
                   }
                   else{}
                 }
                 else{}
               }
               static void Standby_Judge(void)
               {
41 0    ( )    Standby_Judge
41 1    ( )( ) if (CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 1)
                 {
41 2    ( )( )   if (rb_Verglasun_offenDebounce_mg < 0xff)
                   {
                     rb_Verglasun_offenDebounce_mg ++;
                   }
                   rb_Verglasun_ClosedDebounce_mg = 0;
                 }
                 else 
41 3    ( )( )   if(CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 0)
                 {
                   rw_StandbyTimeOutCnt_g = 0;
41 4    ( )( )     if (rb_Verglasun_ClosedDebounce_mg < 0xff)
                   {
                     rb_Verglasun_ClosedDebounce_mg ++;
                   }
                   rb_Verglasun_offenDebounce_mg = 0;
                 }
                 else{}
               }
               static void OutdBriCntr_Counter(void)
               {
                 static byte rb_Cnt_l = 0;
42 0    ( )    OutdBriCntr_Counter
                 {RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriCntr_CEM_LIN1 = rb_Cnt_l;};
42 1    ( )( ) if(rb_Cnt_l < 15)
                 {
                   rb_Cnt_l ++;
                 }
                 else
                 {
                   rb_Cnt_l = 0;
                 }
               }
