               /* PRQA S 3619 EOF */ /* << IAR-Compiler allows whitespaces>> */
               /* PRQA S 3116 EOF */ /* << pragma directives needed, compiler specific>>*/
               /*************************************************************************
                 Company : Valeo Wiper System
                 Project : RLT Sensor, RDN Sensor
                 Component : RLS_LINST.c
                 Documentation reference   : Software Requrement Specification
                 Overview of the component : LIN- Data Link layer
                 Evolution of the component : see PVCS Version control system
                               Initials   date   modification
               *************************************************************************/
               /* History                                                                    */
               /*----------------------------------------------------------------------------*/
               /* Date      VDR_Number     Description                                       */
               /* DD.MM.YY*/
               /*----------------------------------------------------------------------------*/
               /* 05.09.11 VDR_705  PCG  - Send detection of Rain Sensor at any time not only when active */
               /* 31.08.11 VDR_700  PCG  - Set Light Sensitivity "0" like LS "4". Set default to "4" instead of "0" 
                                         - Reorganize signals related to Message CEM_L8_FrP04 */
               /* 13.05.11 VDR_659  PCG  - QA-C                       */
               /* 12.05.11 VDR_634  PCG  - removed changes from 10.May.11 */
               /* 10.05.11 VDR_634  PCG  - set adapterrrainsensacrive failure when no master msg is received */
               /* 24.03.11 VDR_647  FS   - Variable name changed*/ 
               /* 18.03.11 VDR_66   PCG  - RLS_VDR_633 RLS_VOLVO_Y555 the first frame of RSM partnumber is set to 0 at startup */
               /* 17.02.11 VCO_70   PCG  - reduced low limit for WS Transmission due to Blue shade band*/
               /* 15.02.11 VDR_580  PCG  - splash bit no more depending on directmode */
               /* 17.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 04.11.10 VDR_583  PCG  - Corrected Volvo Part Number. SWRS-RSM-001:Req14v1  */
               /* 11.08.10 VCO_73   PCG  - Implemented Rain Sensor Sensitivity up to 8 sensitivities. SWRS-RSM-001:Req34v1 */
               /* 06.08.10 VCO_71   PCG  - Implemented Rain Sensor Norm Value: adjust RSM sensitivity when placed on 
               *                            different vehicles. SWRS-RSM-001: Req38v1  */
               /* 06.08.10 VCO_73   PCG  - Implemented VCC Part Number: 31314540. SWRS-RSM-001:Req14v1  */
               /* 05.08.10 VCO_72   PCG  - Implemented Light Sensor Sensitivity: RainSnsrLiSnvty. SWRS-RSM-001:Req51v2  */
               /* 03.08.10 VCO_69   PCG  - Implemented new output signal RainSnsrLiMod. SWRS-RSM-001:Req39v2 */
               /* 03.08.10 VCO_66   PCG  - Implemented CarCode table values according mail 26.03.2010*/
               /* 02.08.10 VCO_67   PCG  - Implemented Rain Sensor active when Terminal_X is set regardless 
               *                            Switch Position. SWRS-RSM-001:Req31v1 */
               /* 02.08.10 VCO_68   PCG  - Implement New message CEM_L8_FrP04. SWRS-RSM-001:Req19v1 */
               /* 30.06.10 VDR_540  FS   - Butterfly Option integrated*/
               /* 10.06.10 VCO_49   FS   - Implement long EEPROM PLUS Logging Issues from 11.June --> Park Position corrected*/
               /* 10.06.10 VCO_59   FS   - Logging files --> Rework ParkPosition Evaluation*/
               /* 26.05.10  VCO_055     AL      reomve debouncing of RAM and ROM error*/
               /* 29.04.10 VDR_473  FS   - QA-C*/
               /* 26.04.10 VCO_48   FS   - Use "AB" Index instead of only "B" of the partnumer within EEPROM*/
               /* 26.04.10 VCO_48   FS   - First Frame of Part number not correct*/
               /* 26.03.10  VCO_48   FS   - Update due to Test Drive
                *                           Park contact has been send to late via LIN
                                        --> Update in this file and trigger on WiperSpeed_Running Signal
                                          - Update internal SCS_Signals, that both ldf can work the same*/
               /* 25.03.10  VCO_44   FS   - Implement strategy for Partnumber Read Out
                *                         - delete some parts of VCO_33
                *                         - Switch Stalk Information dependent from CarCode*/
               /* 11.02.10  VDR_437  FS   - Index of Ford Partnumber from EEPROM included *
                 *                        - Mapping of RainSensorSensitivity not in RAM --> in EEPROM*/
               /* 19.01.10  VDR_414  FS    Update due to Testdrive*/
               /* 23.12.09  VDR_394  FS    REWORK: New CarCode Table to be implemented, Req: Email from 20091218*/
               /* 22.12.09  VDR_362  FS    Rework: Overflow of rb_parkpositioncounter_s MUST have been implemented */
               /* 18.12.09  VDR_403  FS    - rb_FixedCarCode deleted
                *                          - Set Auxillary Variable constantly to ALL-value that Ford Partnumber
                *                            can be received by Master for all CarCodes*/
               /* 19.11.09  VDR_396  FS    RainSensorEnable as required in SRS*/
               /* 17.11.09  VDR_394  FS    Default values windshield and comments*/
               /* 01.10.09  VDR_373  FS    "OneTime or Double Overwiped"*/
               /* 29.09.09  VDR_362  FS    Implement wipe cancelling when 4 seconds wiper has not moved*/
               /* 25.09.09  VDR_368  FS    Requirements from FRSI, SRD, ES and Testcases. See comments in code*/
               /* 28.09.09  VDR_360  FS    RainSensorDisable implementation for Ford*/
               /* 31.07.09  VDR_355  AL    Changes based on results of function test and     *
                          & VDR_356        Review of function from Bosch sensor             */
               /* 16.07.09  VDR_344 FS     Updating complete first version to                *
                                           first release version due to                      *
                                           Ford Meeting in Bietigheim                        */
               /* 28.08.15  VCO_268 SP     Cleanup the LIN modules  */
               /*02.10.2015 VDR_911 SP     HammingErr shld be part of RS_Error/LS_Error and shld not be used for Active Err*/
               /*30.05.2016 VDR_983 NB     Sporadic illegale instruction reset in the startup                              */
               /******************************************************************************/
               /*************************************************************************
               **                   Common and module include-file                     **
               **************************************************************************/
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/DEVICE/ior5f109be.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_projectDefs.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_E2ProjectConfig.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_main.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_lininclude.h"
               /*************************************************************************
               **                   Other files included                               **
               **************************************************************************/
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_io.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_Appli_timer.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_Check_sr.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_rainsens.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/DIAGNOSTICS/G5_diagnose.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_E2Handler.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/EEPROM/G5_flashe2.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/RAIN/G5_rs_task.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_IRlight.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/LIGHT/G5_DippedBeam_sr.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_ASIC_Control_sr.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/PERIPHERALS/G5_spi_sr.h"
               #include "C:/USERS/ZHU1/DOWNLOADS/SW_NEED_CHANGE_MANAGEMANT/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SWDEV/01_SRCCODE/APPLICATION/OS/G5_utilities.h"
               #include "C:/Users/zhu1/Downloads/SW_Need_Change_Managemant/GEEA2.0/E4-2_SW/RLS_SYS_RLS_GP_RLXS_GEN5_DEV_APL_GEELY2.0_RLFS_FOR_E4_03/05_SwDev/01_SrcCode/Application/CustomerInterface/G5_AsicFramesLin.h"
               /*************************************************************************
               **                   Declaration of local module variables              **
               *************************************************************************/
               /* PRQA S 0759 1*//*<< 0759:union needed to reduce RAM usage >>*/
               static volatile Flag uF_StalkInPos_Flags_g;
               /*************************************************************************
               **                   Declaration of local module Macros **
               *************************************************************************/
               /*************************************************************************
               **                   Declaration of local module Functions              **
               *************************************************************************/
               extern byte rb_RainInt_IntensityOutput_g;
               extern unsigned int rb_overWipeCoef;
               static void CheckErrors(void);
               static void RainFunction(void);
               static void LightFunction(void);
               static void Humidity_Function(void);
               static void StandByMode(void);
               static void VoltageDetect(void);
               static void OutPutBrightnessValue(void);
               static byte rb_Verglasun_ClosedDebounce_mg;
               static unsigned int rw_CommandCloseWindowTimout_mg;
               static byte rb_AnyErrorCounterDebounce_mg;
               static unsigned int rw_AfterRSWipeCounter_mg;                   // Time after last wipe from RS
               static unsigned int rw_AfterRSWipeCounterAlt_mg;              //Time to the last wipe from RS
               static unsigned int rw_AfterWWSWipeCounter_mg;                  // Time after last wipe from WWS
               static  unsigned int rw_WipeCommandTimOut_mg;                    //timout for requested wipe
               static  byte rb_Err_State_Light_Sens_mg =0;// light error
               static  byte  rb_OutsideTemp_mg  = 0;
               static  byte rb_WipeWorkStatus_mg = 1;
               /******************For HUD**********************/
               static unsigned long HUDEverageValue[2] = {0,0};
               static unsigned long rb_storeHUDValueEvery500ms[10]={0,0,0,0,0,0,0,0,0,0};
               static void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_50ms);
               static unsigned long CalcHUDMean_1000ms(void);
               static void orderHUDValue(int n);
               static void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb);
               static unsigned long  AdjustOutHudValue(unsigned long rl_CurrentHud);
               static byte GetUpdateTimeForLightStatus(void);
               static  unsigned long RW_Amb_Fw_Result_End    = 0;
               static  byte rb_hud_data_update      = 0;
               /********************End***********************/
               static void OutPutSolarValue(void);
               static void OutPutTwliBriValue(void);
               static byte CRC8SAEJ1850(const byte * u8_data,byte u8_len);//crc8saej1850 
               static byte GetHudCrcj1850(unsigned long hudSrc);
               static byte GetOutdBriStsCrcj1850(byte OutdBriSts);
               static void GetLightTransmission(byte trans_550nm,byte trans_880nm);
               //static void Get_BCMVehType(byte CarType);
               static void Set_BCMLightOffset(byte offset);
               static void SendRLSSerNo(void);
               static void SendRLSMPartNo(void);
               static void SendRLSMPartNo10(void);
               static void OutPutHudValue(void);
               static void OutPutHudSendCount(void);
               static void TemperatureDetect(void);
               static void WipeWinterModeCheck(void);
               static byte IsByteOddParity(byte data);
               static void Rain_sensitivity(void);
               static void Get_Lin_Signal_From_GetLeWWS(void);
               static void Light_Sensitivity_In_GetLeWWS(void);
               static void Wiper_and_Park(void);
               static void Tunnel_Wipe_Decision(void);
               static void Exit_Wipe(void);
               static void Rain_Sensitivity_Judge(void);
               static void Standby_Judge(void);
               static void OutdBriCntr_Counter(void);
               static byte rb_AfterResetCounter_l;
               static unsigned int rw_IgnitionOffDelay_mg;
               static byte rb_tunnelWipeActive_g;  
               static byte rb_RLS_Sensitivity_Array_l[7];
               static byte rb_Verglasun_offenDebounce_mg;
               static byte Vehicle_Speed_Decision_Flag = 0;
               /**************************************************************************
                 Syntax   : void  GetLeWWS(void)
                 Object   : GetLeWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Schaltermoduls von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLeWWS(void)
               {
                 static byte rb_IgnitionOndelay_mg = 0;
                 static byte rb_IntervalOnOndelay_mg;
1 0     ( )    GetLeWWS
1 1     ( )( )   if((
1 1.1   ( )( )   uLinIndicationFlags . w[0]. b6 != 0))
                 { 
                   {
1 2                uLinIndicationFlags . w[0]. b6 = 0;}
1 3                ;
1 4                rw_NoCommunicationCounter_g = 0;                                 // reset no communication counter
1 5                uF_SCIFlags_mg . Bit . B1 = 1;                                     // set connected to Master  
1 6                uF_Communication_mg . Bit . B1 = 1;    
1 7                rb_speed_in_kmh_g = CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . VehSpdForWipg_CEM_LIN1;//needsys   
1 8     ( )( )     if(
1 8.1   ( )( )     rb_speed_in_kmh_g>=10)
                   {
1 9                  uF_GainAdjustFlags_g . Bit . B1 = 1;
                   }   
                   else{}
1 10               uF_VoltageStatus_g . Bit . B2 = 1;
1 11               rw_IgnitionOffDelay_mg = 0;
1 12    ( )( )     if(
1 12.1  ( )( )     rb_IgnitionOndelay_mg < 250)
                   {
1 13                 rb_IgnitionOndelay_mg++;
                   }
                   else{}
1 14    ( )( )     if((
1 14.1  ( )( )     (
1 15    ( )( ) 
1 15.1  ( )( )     (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x40)>0) == 0) &&(
1 14.2  ( )( )     rb_AfterResetCounter_l> 10))
                   {
1 16    ( )( )       if((
1 16.1  ( )( )       CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 1) || (
1 16.2  ( )( )       (
1 17    ( )( ) 
1 17.1  ( )( )       (EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x40)>0) != 0))
                     {
1 18                   uF_StatusRainsensor_mg . Bit . B0 = 1;                            /*Rainsensor always active!*/
                     }
                     else
                     {
1 19                   uF_StatusRainsensor_mg . Bit . B0 = 0;                           /*Rainsensor off!*/
                     }
                   }
                   else
                   {
1 20                 uF_StatusRainsensor_mg . Bit . B0 = 0;                             //Rainsensor off!
                   }
1 21    ( )( )     if(
1 21.1  ( )( )     CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 1)                            // copy automatic wiping mode
                   {
1 22    ( )( )       if(
1 22.1  ( )( )       rb_IntervalOnOndelay_mg > 15)                               //debound 150ms when turn the auto wiper on
                     {
1 23                   RSStatus . Bit . B7 = 1;
                     }
                     else
                     {
1 24                   rb_IntervalOnOndelay_mg++;
                     }
                   }
                   else
                   {
1 25                 RSStatus . Bit . B7 = 0;
1 26                 rb_IntervalOnOndelay_mg = 0;
                   }
1 27               rb_LIN_SensitivityShift_g =  9;                                     //adaptation Variable for sensitivity factor
1 28    ( )( )     if(
1 28.1  ( )( )     CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1 < 7)
                   {
1 29                 rb_PotiStageFromBox_g = CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1;
                   }
                   else 
1 30    ( )( )       if(
1 30.1  ( )( )       CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . WiprMotIntlCmd_CEM_LIN1 == 7)
                   {
1 31                   rb_PotiStageFromBox_g = 3;
                   }
                   else{}
                 }  
                 else                                                                  //keine neue Master Nachricht!
                 {                                                                     // check if system is on -> to switch off 
1 32    ( )( )     if(
1 32.1  ( )( )     rw_NoCommunicationCounter_g > ((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200))                               /***4S***/
                   {     
1 33    ( )( )       if ((
1 33.1  ( )( )       uF_SCIFlags_mg . Bit . B4 == 0)||( 
1 33.2  ( )( )       uF_ASIC_ControlFlags_g . Bit . B4 == 0))  /*VDR_526*/
                     {
1 34    ( )( )         if ((
1 34.1  ( )( )         rb_Verglasun_offenDebounce_mg > 100) 
                           && (
1 34.2  ( )( )         (
1 35    ( )( ) 
1 35.1  ( )( )         (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x04)>0) == 1) 
                           && (
1 34.3  ( )( )         uF_SCIFlags_mg . Bit . B4 == 0))
                       {
1 36                     uF_ASIC_ControlFlags_g . Bit . B4 = 1;                             // Set Request for Standby Mode
                         /*******20191112_Zhiyuan HU_Only_for_Winter_Mode********/
1 37                     Vehicle_Speed_Decision_Flag = 0;
                         /*******************End*******************************/
                       }
                       else
                       {
1 38                     uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                       }       
1 39                   uF_SCIFlags_mg . Bit . B2 = 1;                                         // Was Connected to Master
                     }
                     else 
                     {
1 40    ( )( )         if ((
1 40.1  ( )( )         CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 0) || (
1 40.2  ( )( )         rw_CommandCloseWindowTimout_mg > 6000))
                       {
1 41                     uF_SCIFlags_mg . Bit . B2 = 1;                                       // no need of Standby mode 
1 42                     uF_ASIC_ControlFlags_g . Bit . B4 = 0;
1 43                     uF_SCIFlags_mg . Bit . B0 = 0;                                /*VDR_526*/
1 44                     uF_SCIFlags_mg . Bit . B4 = 0;                           /*VDR_526*/
1 45                     rb_WakeupCounter_mg = 0; 
                       }
                       else
                       {
1 46    ( )( )           if (
1 46.1  ( )( )           rb_WakeupCounter_mg == 0)                             /*VDR_526*/
                         { 
1 47                       uF_SCIFlags_mg . Bit . B0 = 1; 
                         }
                       }
                     }
1 48                 uF_SCIFlags_mg . Bit . B1 = 0;                                  // clear connected to Master
                   }
                   else
                   {
1 49                 uF_SCIFlags_mg . Bit . B0 = 0;                                    /*VDR_526*/
1 50                 rw_NoCommunicationCounter_g ++;
1 51                 uF_SCIFlags_mg . Bit . B2 = 0;                                          // Was Connected to Master
1 52    ( )( )       if(
1 52.1  ( )( )       rw_NoCommunicationCounter_g >= (((((EEPROM_Struct_AD . EEPROMStructAD . p_t_autobahn_delay_on_g>>5)&0x07)*100)+200) - 3) )
                     {
1 53                   rb_Release_IntervalMarker_Update_g = 0x00;
1 54                   uF_StatusRainsensor2_mg . Bit . B3 = 1;
                     }
                   }
                 }
               }
               /**************************************************************************
                 Syntax   : void  GetLsWWS(void)
                 Object   : GetLsWWS()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c cyclic 10ms
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Eingangsdaten vom Wischermotorin von den
                 entsprechenden Puffern des Vector Bus Treiber in die RAM-Zellen und
                 setzt die internen Daten gemaess SRS um.
               **************************************************************************/
               void GetLsWWS(void)
               {  
                 static byte rb_parkpositioncounter_s;
                 /*simulierte Wischzeit bei LSS aus*/
                 static const byte cab_WiperMotorRunntime_mg[8] ={142,142,133,125,117,111,105,100};  
2 0     ( )    GetLsWWS
2 1              Get_Lin_Signal_From_GetLeWWS();
2 2              Standby_Judge();
2 3              Light_Sensitivity_In_GetLeWWS();
2 4     ( )( )   if ((
2 4.1   ( )( )   rb_WiperSpeed_g > 0)&&(
2 4.2   ( )( )   uF_SCIFlags_mg . Bit . B6== 1))
                 {    
2 5     ( )( )     if (
2 5.1   ( )( )     rw_WipeCommandTimOut_mg <= 400)
                   {
2 6                  rw_WipeCommandTimOut_mg ++;                // reset Timout if wiper motor wants not wipe
                   }
                   else
                   {
2 7                  rb_LimitMemomryNoWiperReaction_g = 1;
                   }      
                 }
2 8     ( )( )   if(((
2 8.1   ( )( )   CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 0) && (
2 8.2   ( )( )   uF_SCIFlags_mg . Bit . B6 == 1))
                      ||(
2 8.3   ( )( )   rw_WipeCommandTimOut_mg > 400))
                 {
2 9     ( )( )     if((
2 9.1   ( )( )     rb_WiperSpeed_g > 0)||(
2 9.2   ( )( )     uF_StatusRainsensor_mg . Bit . B7 == 0))
                   {
2 10    ( )( )       if(
2 10.1  ( )( )       rb_parkpositioncounter_s>10)            // Parkpositioncounter groesser 10
                     {
2 11                   uF_StatusRainsensor_mg . Bit . B7 = 0;              // delete bit for Parkposition
                     }
2 12                 rb_parkpositioncounter_s++;                // increase Parkpositionscounter
                   }
2 13    ( )( )     if(
2 13.1  ( )( )     rb_parkpositioncounter_s > (cab_WiperMotorRunntime_mg[rb_WiperSpeed_g]))
                   {
2 14                 rw_WipeCommandTimOut_mg = 0;
2 15                 uF_StatusRainsensor_mg . Bit . B7 = 1;               
2 16                 rb_parkpositioncounter_s = 0;            
                   }
                 }
                 else    
                 {
2 17    ( )( )     if((
2 17.1  ( )( )     uF_SCIFlags_mg . Bit . B6 == 0)&&(
2 17.2  ( )( )     rb_WiperSpeed_g > 0))
                   {
2 18                 rbi_WiperStarted_g = 1;
                   }
2 19    ( )( )     if(
2 19.1  ( )( )     uF_SCIFlags_mg . Bit . B6 == 1)            // In Parklagensignal ?
                   {
2 20    ( )( )       if(
2 20.1  ( )( )       uF_StatusRainsensor_mg . Bit . B7 == 0)
                     {
2 21                   rb_parkpositioncounter_s=0;              // Parkpositioncounter zuruecksetzen
                     }
                     else
                     {
2 22    ( )( )         if(
2 22.1  ( )( )         rb_parkpositioncounter_s < 255)
                       {
2 23                     rb_parkpositioncounter_s++;
                       }
                     }
2 24                 uF_StatusRainsensor_mg . Bit . B7 = 1;                 // Parkposition True
2 25    ( )( )       if (
2 25.1  ( )( )       rub_IntermDelayTime > 5)               // clear option for Wiper Started Flag!
                     {
2 26                   rbi_WiperStarted_g = 0;
                     }
                   }
                   else
                   {
2 27                 rb_LimitMemomryNoWiperReaction_g = 0;
2 28                 rbi_WiperStarted_g = 0;
2 29                 rw_WipeCommandTimOut_mg = 0;               // reset Timout if wiper motor wants not wipe
2 30    ( )( )       if(
2 30.1  ( )( )       rb_parkpositioncounter_s>7)             // Parkpositioncounter groesser 8
                     {
2 31                   uF_StatusRainsensor_mg . Bit . B7 = 0;              // loesche bit fuer Parkposition
                     }
                     else
                     {
2 32                   rb_parkpositioncounter_s++;              // inkrementiere Parkpositionscounter
                     }
                   }
                 }
               }
               /**************************************************************************
                 Syntax   : void  CopyRLSData(void)
                 Object   : CopyRLSData()
                 Parameters : none
                 Return  : none
                 Calls   : in main.c
               ***************************************************************************
                 Inputs validation conditions:
                 none
               ***************************************************************************
                 Pseudo-code : schreibt die Ausgangsdaten des Sensors in den
                 Ausgangsdatenpuffer des Vector Bus Treiber und setzt die internen Daten
                 gemaess SRS um.
               **************************************************************************/
               void CopyRLSData(void)
               {
3 0     ( )    CopyRLSData
3 1              Check_StartupActiveErrors();
3 2     ( )( )   if((
3 2.1   ( )( )   uLinConfirmationFlags . w[0]. b6 != 0))
                 {
                   {
3 3                uLinConfirmationFlags . w[0]. b6 = 0;} 
3 4                ;
3 5                uF_SCIFlags_mg . Bit . B1 = 1;
3 6                OutdBriCntr_Counter();
                 }
3 7     ( )( )   if((
3 7.1   ( )( )   uLinConfirmationFlags . w[0]. b5 != 0))
                 {
                   {
3 8                uLinConfirmationFlags . w[0]. b5 = 0;} 
3 9                ;
3 10               uF_SCIFlags_mg . Bit . B1 = 1;
3 11               OutPutHudSendCount();
                 }
3 12    ( )( )   if((
3 12.1  ( )( )   uLinConfirmationFlags . w[0]. b4 != 0))
                 {
                   {
3 13               uLinConfirmationFlags . w[0]. b4 = 0;} 
3 14               ;
3 15               uF_SCIFlags_mg . Bit . B1 = 1; 
                 }
3 16    ( )( )   if((
3 16.1  ( )( )   uLinConfirmationFlags . w[0]. b3 != 0))
                 {
                   {
3 17               uLinConfirmationFlags . w[0]. b3 = 0;} 
3 18               ;
3 19               uF_SCIFlags_mg . Bit . B1 = 1;
3 20               SendRLSMPartNo();
                 }
3 21    ( )( )   if((
3 21.1  ( )( )   uLinConfirmationFlags . w[0]. b2 != 0))
                 {
                   {
3 22               uLinConfirmationFlags . w[0]. b2 = 0;} 
3 23               ;
3 24               uF_SCIFlags_mg . Bit . B1 = 1; 
3 25               SendRLSMPartNo10();
                 }
3 26    ( )( )   if((
3 26.1  ( )( )   uLinConfirmationFlags . w[0]. b1 != 0))
                 {
                   {
3 27               uLinConfirmationFlags . w[0]. b1 = 0;} 
3 28               ;
3 29               uF_SCIFlags_mg . Bit . B1 = 1; 
3 30               SendRLSSerNo();
                 }
                 /* Rain intensity VCO_423: Interval mode defined*/  
3 31    ( )( )   if(
3 31.1  ( )( )   uF_StatusRainsensor_mg . Bit . B0 == 1)
                 {
3 32               rb_overWipeCoef = EEPROM_Struct_PD . EEPROMStructPD . RS_Intensity_OverWipeCoef;
                 }
                 else
                 {
3 33               rb_overWipeCoef = 100;
                 }
3 34             RainFunction();//Tunnel wiper,auto wiper,rain level, splash mode, rain sonser error
3 35             CheckErrors();//Other error signals send in this function
3 36             VoltageDetect();//Send high/low voltage error
3 37             TemperatureDetect();//send temperate error
3 38             LightFunction();//light request and the reason of light on                            
3 39             StandByMode();//Auto close window
3 40             OutPutBrightnessValue();//output FW IR SOLAR brightness
3 41             Humidity_Function();//dew point & Screen temperature & sensor teamperature & relative Humidity
3 42             CopyRLSDataAsic();
3 43             rb_WDG_BusTaskCounter_g++;//increment test counter for bus
               }
               static void RainFunction(void)
               {
                 static byte rb_TunnelWipeTimeOut_mg;   
                 byte Wiper_speed_l = 0;
4 0     ( )    RainFunction
4 1              Wiper_and_Park();
4 2              Tunnel_Wipe_Decision();
                 /*trigger the afterwipe at tunnel*/
4 3     ( )( )   if((
4 3.1   ( )( )   rw_AfterRSWipeCounter_mg >= rw_AfterRSWipeCounterAlt_mg)
                      &&(
4 3.2   ( )( )   rb_tunnelWipeActive_g == 1)
                        &&(
4 3.3   ( )( )   rb_WiperSpeed_g == 0))
                 {
4 4                rb_TunnelWipeTimeOut_mg = 0;
4 5                uF_Communication_mg . Bit . B3 = 1;
4 6                rb_tunnelWipeActive_g = 0;
4 7                rw_AfterRSWipeCounterAlt_mg = 50000;
4 8                rw_AfterRSWipeCounter_mg = 50000;
4 9     ( )( )     if(
4 9.1   ( )( )     uF_StatusRainsensor_mg . Bit . B0 == 1)
                   {
                     {
4 10                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;}
4 11                 ;
                     {
4 12                 RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;}
4 13                 ;
                   }
                 }
                 else 
4 14    ( )( )     if(
4 14.1  ( )( )     uF_Communication_mg . Bit . B3 == 1)
                 {
4 15    ( )( )       if((
4 15.1  ( )( )       uF_StatusRainsensor_mg . Bit . B7 == 0)||(
4 15.2  ( )( )       rb_TunnelWipeTimeOut_mg >= 50))
                   {
4 16                   uF_Communication_mg . Bit . B3 = 0;
4 17                   rb_TunnelWipeTimeOut_mg = 0;
                   }
                   else
                   {
4 18                   rb_TunnelWipeTimeOut_mg++;
                   }
4 19    ( )( )       if(
4 19.1  ( )( )       uF_StatusRainsensor_mg . Bit . B0 == 1)
                   {
                     {
4 20                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;}
4 21                   ;
                     {
4 22                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;}
4 23                   ;
                   }
                 }
                 else
                 {
4 24    ( )( )       if((
4 24.1  ( )( )       uF_StatusRainsensor_mg . Bit . B0 == 1) 
                      && (
4 24.2  ( )( )       rb_WiperSpeed_g != 0) 
                        && (
4 24.3  ( )( )       rb_WipeWorkStatus_mg == 1))
                   {
4 25    ( )( )         if((
4 25.1  ( )( )         RSStatus . Bit . B5 == 0) && (
4 25.2  ( )( )         RSStatus . Bit . B6 == 0))
                     {
4 26    ( )( )           if(
4 26.1  ( )( )           rw_AfterWWSWipeCounter_mg > 500)
                       {
                         {
4 27                       RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;}
4 28                       ;
                         {
4 29                       RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 1;}
4 30                       ;
                       }
                       else          
                       {
                         {
4 31                       RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 2;}
4 32                       ;
                         {
4 33                       RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 2;}
4 34                       ;
                       }
                     }
                     else
                     {
                       {
4 35                     RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 3;}
4 36                     ;
4 37    ( )( )           if(
4 37.1  ( )( )           rb_WiperSpeed_g == 1)
                       {
4 38                       Wiper_speed_l = 2;
                       }
                       else
                       {
4 39                       Wiper_speed_l = rb_WiperSpeed_g;
                       }
                       {
4 40                     RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = Wiper_speed_l;}
4 41                     ;
                     }
                   }
                   else
                   {
4 42                   Exit_Wipe();
                   }  
4 43    ( )( )       if(
4 43.1  ( )( )       rb_WiperSpeed_g >0)
                   {
4 44    ( )( )         if(
4 44.1  ( )( )         rb_WiperSpeedAlt_g == 0)
                     {
4 45                     rw_AfterRSWipeCounterAlt_mg = rw_AfterRSWipeCounter_mg;
                     }
4 46                   rw_AfterRSWipeCounter_mg = 0;
                   }
                 } 
4 47             rb_WiperSpeedAlt_g = rb_WiperSpeed_g;
4 48             uF_Communication_mg . Bit . B4 = uF_modi_lightsens_g . Bit . B2;      
4 49    ( )( )   if(
4 49.1  ( )( )   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 == 1)
                 {
                   {
4 50               RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainfallAmnt_CEM_LIN1 = 15;}
4 51               ;
                 }
                 else
                 {
                   {
4 52               RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainfallAmnt_CEM_LIN1 = rb_RainInt_IntensityOutput_g;}
4 53               ;
                 }
               }
               static void LightFunction(void)
               {
                 byte rb_AnyErrorCounterDebounce_l; 
                 byte rb_TempLightOn_l = 0;
                 byte rb_OpModeState = 0;
                 byte rb_crc_StsOutdBriSts = 0;
                /* PRQA S 3415, 4112 1 */ /* << Getter functions must not have side effects >>*/
5 0     ( )    LightFunction
5 1     ( )( )   if (((((
5 1.1   ( )( )   (( 
5 2     ( )( )   (
5 2.1   ( )( )   rw_SPINoCommCounter_g > 0) || (
5 2.2   ( )( )   get_rb_LightVetoCounter_g() > 0) || (
5 2.3   ( )( )   get_rb_LightSignalErrorCnt_g() > 0) || (
5 2.4   ( )( )   rb_ASIC_SPI_ErrorCodeCnt_g > 0) || (
5 2.5   ( )( )   rb_StaticNoValidAD_cnt_g > 0) || (
5 2.6   ( )( )   get_rb_VDD_LightSignalErrorCnt_g() > 0) || (
5 2.7   ( )( )   get_rb_LEDx_LStop_error_cnt_g() > 0) || (
5 2.8   ( )( )   rb_ClockFreq_Error_cnt_g > 0) || (
5 2.9   ( )( )   rb_ASIC_ALS2Amb_ShortDetected_cnt_g > 0) || (
5 2.10  ( )( )   rb_ASIC_ALS5FW_ShortDetected_cnt_g > 0) || (
5 2.11  ( )( )   rb_ASIC_INRECIR_ShortDetected_cnt_g > 0) || (
5 2.12  ( )( )   rb_ASIC_initTimeout_g > 0) || (
5 2.13  ( )( )   rb_VIref_ErrCnt_g > 0) )) > 0))||(
5 1.2   ( )( )   rb_Err_State_Light_Sens_mg > 0))||((
5 1.3   ( )( )   (uF_VoltageStatus_g . Bit . B0) == 1))
                      || (
5 1.4   ( )( )   (uF_VoltageStatus_g . Bit . B3) == 1)))
                 {
5 3                rb_AnyErrorCounterDebounce_mg = 250;
                 }
                 else
                 {
5 4     ( )( )     if (
5 4.1   ( )( )     rb_AnyErrorCounterDebounce_mg > 0)
                   {
5 5                  rb_AnyErrorCounterDebounce_mg -- ;
                   }
                 }
5 6              rb_AnyErrorCounterDebounce_l = rb_AnyErrorCounterDebounce_mg; 
5 7     ( )( )   if(
5 7.1   ( )( )   rb_Err_State_Light_Sens_mg == 1)
                 {
5 8                rb_TempLightOn_l = 3;  
                 }
                 else 
5 9     ( )( )     if((
5 9.1   ( )( )     (uF_modi_lightsens_g.AllBit & 0x2F) > 0) 
                         || (
5 9.2   ( )( )     uF_Main_Flags_g . Bit . B7 > 0) 
                           || (
5 9.3   ( )( )     (uF_LightInternalStatus_g . Bit . B6) !=0))
                 {
5 10                 rb_TempLightOn_l = 1;
                 }
                 else
                 {
5 11    ( )( )       if ((
5 11.1  ( )( )       rb_AnyErrorCounterDebounce_l == 0) && (
5 11.2  ( )( )       (get_rb_LightVetoCounter_g()) == 0))
                   {
5 12                   rb_TempLightOn_l = 2;
                   }
                   else
                   {
5 13                   rb_TempLightOn_l = RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1;
                   }
                 }
5 14    ( )( )   if((
5 14.1  ( )( )   uF_Main_Flags_g . Bit . B6 == 0)
                     && ((
5 14.2  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x8A ) 
                         ||(
5 14.3  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 0x98)))
                 {
5 15               rb_TempLightOn_l = 1;
                   {
5 16               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;}
5 17               ;   
                 } 
                 else
                 {
                   /* PRQA S 434, 436, 781 7 */ /* <<usind Micro Controller specific command > */
5 18               MK2L_bit . no4 = 1U;
5 19               ;
                   {
5 20               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;}
5 21               ;
5 22               MK2L_bit . no4 = 0U;
5 23               ;
                 } 
5 24    ( )( )   if(
5 24.1  ( )( )   uF_ASIC_ControlFlags_g . Bit . B1 == 0)
                 {
5 25               rb_TempLightOn_l = 0;
                   {
5 26               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriSts_CEM_LIN1 = rb_TempLightOn_l;}
5 27               ;
                 }
                 else{}
5 28             rb_crc_StsOutdBriSts =  GetOutdBriStsCrcj1850(rb_TempLightOn_l);
                 {
5 29             RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriChks_CEM_LIN1 = rb_crc_StsOutdBriSts;}
5 30             ;
5 31    ( )( )   if((
5 31.1  ( )( )   uF_modi_lightsens_g . Bit . B4 == 1) && (
5 31.2  ( )( )   (
5 32    ( )( ) 
5 32.1  ( )( )   (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x02)>0) == 1))
                 {
                   {
5 33               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 1;}
5 34               ;
                 }
                 else
                 {
                   {
5 35               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainLi_CEM_LIN1 = 0;}
5 36               ;
                 }
5 37    ( )( )   if(
5 37.1  ( )( )   (uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 0)
                 {
5 38               rb_OpModeState = 1;
                 }
                 else 
5 39    ( )( )     if((
5 39.1  ( )( )     (uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 2) 
                         || (
5 39.2  ( )( )     (uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 1))
                 {
5 40                 rb_OpModeState = 0;
                 }
                 else 
5 41    ( )( )       if(
5 41.1  ( )( )       (uF_modi_lightsens_g.AllBit & 0x0F) == (byte) 4)
                 {
5 42                   rb_OpModeState = 3;
                 }
                 else{}
                 {
5 43             RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . LiOprnMod_CEM_LIN1 = rb_OpModeState;}
5 44             ;
               }
               static void Humidity_Function(void)
               {
                 //static word rw_Temperature_Sensor_g;
                 static unsigned int rw_Temperature_Scheibe_g;
6 0     ( )    Humidity_Function
6 1     ( )( )   if (
6 1.1   ( )( )   rbi_HumTempComError_g != 0)
                 {
                   {
6 2                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 1;}
6 3                ;    
                   {
6 4                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (1360 & 0x07); 
6 5                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((1360 >> 3) & 0xff);}
6 6                ;      //window temperature   
                   {
6 7                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 255;}
6 8                ;     // relation hum
                   {
6 9                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = (2047 & 0xff); 
6 10               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((2047 >> 8) & 0x07);}
6 11               ;  //dew point temperature    
                 }
                 else
                 {
                   //l_bool_wr_CmptFrntWindTErr_CEM_LIN1(0);
                   {
6 12               RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrErr_CEM_LIN1 = 0;}
6 13               ;  
6 14    ( )( )     if(
6 14.1  ( )( )     rw_Temperature_raw_g < 0x2ad)                         // The temperature less than -40 the tool doesnot support 
                   {
6 15                 rw_Temperature_Scheibe_g = 0x2ad;
                   }
                   else 
6 16    ( )( )       if(
6 16.1  ( )( )       rw_Temperature_raw_g > 0x4321)
                   {
6 17                   rw_Temperature_Scheibe_g = 0x4321;    
                   }
                   else
                   {
6 18                   rw_Temperature_Scheibe_g = rw_Temperature_raw_g;
                   }    
6 19    ( )( )     if(
6 19.1  ( )( )     rw_Temperature_raw_g == 0)
                   {
                     {
6 20                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (1351 & 0x07); 
6 21                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((1351 >> 3) & 0xff);}
6 22                 ;
                   }
                   else
                   {
6 23    ( )( )       if(
6 23.1  ( )( )       ((rw_Temperature_Scheibe_g -685)/10) < 1650)
                     {        
                       {
6 24                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (((rw_Temperature_Scheibe_g -685)/10) & 0x07); 
6 25                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((((rw_Temperature_Scheibe_g -685)/10) >> 3) & 0xff);}
6 26                   ;
                     }
                     else
                     {         
                       {
6 27                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_0 = (1350 & 0x07); 
6 28                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindT_CEM_LIN1_1 = ((1350 >> 3) & 0xff);}
6 29                   ;
                     }
                   } 
6 30    ( )( )     if (
6 30.1  ( )( )     rw_DewPoint_g == 0)
                   {
                     {
6 31                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = (1651 & 0xff); 
6 32                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((1651 >> 8) & 0x07);}
6 33                 ;
                   }    
                   else
                   {
6 34    ( )( )       if (
6 34.1  ( )( )       rw_DewPoint_g < 1650)
                     {                                                                       
                       {
6 35                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = ((rw_DewPoint_g + 4) & 0xff); 
6 36                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = (((rw_DewPoint_g + 4) >> 8) & 0x07);}
6 37                   ;        
                     }
                     else
                     {
                       {
6 38                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_0 = (1650 & 0xff); 
6 39                   RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . CmptFrntWindDewT_CEM_LIN1_1 = ((1650 >> 8) & 0x07);}
6 40                   ;
                     }
                   }
6 41    ( )( )     if (
6 41.1  ( )( )     rb_Humidity_g == 0)
                   {
                     {
6 42                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = 201;}
6 43                 ;
                   }        
                   else
                   {        
                     {
6 44                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . RelHumSnsrRelHum_CEM_LIN1 = rb_Humidity_raw_g - 1;}
6 45                 ;
                   }   
                 }
               }
               static void StandByMode(void)
               {
7 0     ( )    StandByMode
7 1     ( )( )   if((
7 1.1   ( )( )   rb_Verglasun_ClosedDebounce_mg > 100) 
                    ||(
7 1.2   ( )( )   CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 != 1) 
                      || (
7 1.3   ( )( )   rw_CommandCloseWindowTimout_mg > 6000))
                 {
7 2                uF_SCIFlags_mg . Bit . B4 = 0;
7 3                uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                 }
                 else{}  
7 4     ( )( )   if(
7 4.1   ( )( )   uF_SCIFlags_mg . Bit . B0 == 1)
                 {
7 5                ApplLinInit(0x01);
7 6                uF_SCIFlags_mg . Bit . B0 = 0;                      
                 }
                 else{}
7 7     ( )( )   if(
7 7.1   ( )( )   uF_SCIFlags_mg . Bit . B4 == 1)
                 {
                   {
7 8                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 1;}
7 9                ; 
7 10    ( )( )     if (
7 10.1  ( )( )     rw_CommandCloseWindowTimout_mg > 6000)
                   {
7 11                 uF_ASIC_ControlFlags_g . Bit . B4 = 0;
                   }
                   else
                   {
7 12                 rw_CommandCloseWindowTimout_mg++;
                   }
                 }
                 else
                 {
7 13               rw_CommandCloseWindowTimout_mg = 0;
                   {
7 14               RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainDetected_CEM_LIN1 = 0;}
7 15               ;
                 }
               }
               static void VoltageDetect(void)
               {
                 static byte rb_underVoltageTimer_s;
8 0     ( )    VoltageDetect
8 1     ( )( )   if(
8 1.1   ( )( )   uF_VoltageStatus_g . Bit . B0 == 1)
                 {
8 2     ( )( )     if(
8 2.1   ( )( )     rb_underVoltageTimer_s>249)                       // undervoltagetimer > 249 -> 2500 ms abwarten
                   {
8 3                  uF_VoltageStatus_g . Bit . B7 = 1;
                   }
                   else
                   {
8 4                  rb_underVoltageTimer_s++;                          // increase undervoltagetimer
                   }
                 }
                 else
                 {
8 5                rb_underVoltageTimer_s=0;                            // loesche Timer
8 6                uF_VoltageStatus_g . Bit . B7 = 0;
                 }
                 //if(rbi_UnderVoltage_g == TRUE)
                 //{
                 //  //l_u8_wr_L_Err_State_Volt(rbi_UnderVoltage_g);    //voltage error statue
                 //}
8 7     ( )( )   if(
8 7.1   ( )( )   uF_VoltageStatus_g . Bit . B3 == 1)
                 {
                   {
8 8                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 1;}
8 9                ;  //voltage error statue
                 }
                 else
                 {
                   {
8 10               RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiVoltDetd_CEM_LIN1 = 0;}
8 11               ;
                 }     
               }
               //SWRS4 89031 v4 Rain Sensor Diagnostics [CS Released]
               // 1 (1050mV - (3.6mV x 65))/3300mV  x 256 =63 ===>90
               // 1. (1050mV - (3.6mV x 70))/3300mV  x 256 =62 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1050mV 
               //2 (1140mV - (3.9mV x 65))/2417mV  x 1024 =485 ===>90
               //2. (1140mV - (3.9mV x 70))/2417mV  x 1024 =367 ===>95
               // offset 25 ,because Temperature would be 25 deg C  ---> Temperature sensor voltage should be 1140mV 
               static void TemperatureDetect(void)
               {
                 static unsigned int rb_overTemperatureTimer_s;
                 byte rb_temperateOver_l = 0;
9 0     ( )    TemperatureDetect
9 1     ( )( )   if(((
9 1.1   ( )( )   rb_InternalTemperature_g > 0) && (
9 1.2   ( )( )   rb_InternalTemperature_g < 62)) 
                       || ((
9 1.3   ( )( )   ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (
9 1.4   ( )( )   ras_ASIC_MUX_MeasAD_g[3]. avg < 367)))
                 {
9 2     ( )( )     if(
9 2.1   ( )( )     rb_overTemperatureTimer_s>10000)                       
                   {
9 3                  rb_temperateOver_l = 1;
                   }
                   else
                   {
9 4                  rb_overTemperatureTimer_s++;                          
                   }
                 }
                 else 
9 5     ( )( )     if(((
9 5.1   ( )( )     rb_InternalTemperature_g > 0) && (
9 5.2   ( )( )     rb_InternalTemperature_g< 63)) 
                         || ((
9 5.3   ( )( )     ras_ASIC_MUX_MeasAD_g[3]. avg > 0) && (
9 5.4   ( )( )     ras_ASIC_MUX_MeasAD_g[3]. avg < 485))) 
                 {
9 6     ( )( )       if(
9 6.1   ( )( )       rb_overTemperatureTimer_s>10000)                       
                   {
9 7                    rb_temperateOver_l = 1;//continue on
                   }
                   else
                   {
9 8                    rb_overTemperatureTimer_s=0;                            
9 9                    rb_temperateOver_l = 0;                         
                   }
                 }  
                 else
                 {
9 10                 rb_overTemperatureTimer_s=0;                            
9 11                 rb_temperateOver_l = 0;
                 }
                 // ASIC/MCU temperature detect,when over 95 degree,then set.
                 {
9 12             RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . RainSnsrDiagcRainSnsrHiTDetd_CEM_LIN1 = rb_temperateOver_l;}
9 13             ; 
               }
               static void OutPutHudSendCount(void)
               {
                 static byte rb_HUD_Cnt_s = 0;
                 //cnt count 
10 0    ( )    OutPutHudSendCount
                 {
10 1             RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsCntr_CEM_LIN1 = rb_HUD_Cnt_s;}
10 2             ;
10 3    ( )( )   if(
10 3.1  ( )( )   rb_HUD_Cnt_s < 15)
                 {
10 4               rb_HUD_Cnt_s ++;
                 }
                 else
                 {
10 5               rb_HUD_Cnt_s = 0;
                 }
               }
               static void OutPutHudValue(void)
               {
                 byte rb_hud_Crc8_l;
                 unsigned long rl_hud_Brightness_l;
                 unsigned long rl_hud_AMB_Brightness_l;
                 unsigned long rl_hud_FW_Brightness_l; 
                 unsigned long rl_eeprom_hud_max_l = 0;
                 byte rb_hud_High8Bit_l = 0;
                 unsigned int rw_hud_Low9Bit_l  = 0;
                 /*Get the Real Lux for FW and AMB  Illuminance = FW*6 + AMB*15*/
11 0    ( )    OutPutHudValue
11 1             rl_hud_AMB_Brightness_l = 15*((unsigned long)(get_rw_Amb_light16bit_g()));
11 2             rl_hud_FW_Brightness_l = (unsigned long)((3*((unsigned long)(get_rl_HUD_light32bit_g())))>>1);
                 /*Pre-Process for original value get average for "rl_HUD_AMB_Brightness" and "rl_HUD_FW_Brightness"*/
                 /*100ms average for AMB and FW        1000ms for sum average      */
11 3             GetFiveTableValue_50ms(rl_hud_AMB_Brightness_l,rl_hud_FW_Brightness_l);   
                 /*5000ms for average output*/
11 4             rl_hud_Brightness_l  = CalcHUDMean_1000ms();
                 /*Output to LIN Interface*/
11 5             rl_eeprom_hud_max_l = (unsigned long)((unsigned long)EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Resolution * ((unsigned long)EEPROM_Struct_PD . EEPROMStructPD . HUD_MAX_Value));
11 6    ( )( )   if(
11 6.1  ( )( )   rl_hud_Brightness_l >= rl_eeprom_hud_max_l)
                 {
11 7               rl_hud_Brightness_l = rl_eeprom_hud_max_l;        
                 }
                 else{}
11 8    ( )( )   if(
11 8.1  ( )( )   rl_hud_Brightness_l > 126000)//currnet send data  length is shorter
                 {
11 9               rl_hud_Brightness_l = 126000;
                 } 
                 else{}
11 10            rw_hud_Low9Bit_l = (unsigned int)((rl_hud_Brightness_l&0x1ff));
11 11            rb_hud_High8Bit_l  = (byte)((rl_hud_Brightness_l>>9)&0xFF);
                 {
11 12            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = (rw_hud_Low9Bit_l & 0xff); 
11 13            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((rw_hud_Low9Bit_l >> 8) & 0x1);}
11 14            ;
                 {
11 15            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = rb_hud_High8Bit_l;}
11 16            ;
                 //check crc 
11 17            rb_hud_Crc8_l = GetHudCrcj1850(rl_hud_Brightness_l);
                 {
11 18            RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = rb_hud_Crc8_l;}
11 19            ;
                 /*end hud info relation*/  
               }
               static void OutPutTwliBriValue(void)
               {
12 0    ( )    OutPutTwliBriValue
12 1    ( )( )   if(
12 1.1  ( )( )   (get_rw_Amb_light16bit_g() * 20) < 16382)    
                 {
                   {
12 2               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = ((get_rw_Amb_light16bit_g() * 20) & 0x3F); 
12 3               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = (((get_rw_Amb_light16bit_g() * 20) >> 6) & 0xFF);}
12 4               ;
                 }
                 else
                 {
                   {
12 5               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = (16382 & 0x3F); 
12 6               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((16382 >> 6) & 0xFF);}
12 7               ;
                 } 
               }
               static void OutPutSolarValue(void)
               {
                 unsigned int rw_IrLightforSOSE_Corr1_l;
                 unsigned int rw_IrLightforSOSE_Corr2_l;
                 unsigned int rw_SoSe_SunInt_2D_Le_l;
                 unsigned int rw_SoSe_SunInt_2D_Re_l; 
13 0    ( )    OutPutSolarValue
13 1    ( )( )   if (
13 1.1  ( )( )   (
13 2    ( )( ) 
13 2.1  ( )( )   (EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags & 0x02)>0) == 1)
                 {
13 3    ( )( )     if (
13 3.1  ( )( )     (EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ) > 0)
                   {
13 4                 rw_IrLightforSOSE_Corr1_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor1 ); 
                   }
                   else 
                   {
13 5                 rw_IrLightforSOSE_Corr1_l = 0;  
                   }
13 6    ( )( )     if(
13 6.1  ( )( )     (rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_2_g))
                   {
13 7                 rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr1_l;
                   }
                   else
                   {
13 8                 rw_SoSe_SunInt_2D_Le_l = rw_Solar_light16bit_2_g ;
                   }
13 9    ( )( )     if(
13 9.1  ( )( )     (rw_IrLightforSOSE_Corr1_l) > (rw_Solar_light16bit_1_g))
                   {
13 10                rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr1_l;
                   }
                   else
                   {
13 11                rw_SoSe_SunInt_2D_Re_l = rw_Solar_light16bit_1_g ;
                   }    
13 12   ( )( )     if (
13 12.1 ( )( )     (EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ) > 0)
                   {
13 13                rw_IrLightforSOSE_Corr2_l= get_rw_IR_light16bit_g()/(EEPROM_Struct_AD . EEPROMStructAD . SolarShadowCorrFactor2 ); 
                   }
                   else 
                   {
13 14                rw_IrLightforSOSE_Corr2_l = 0;  
                   }
13 15   ( )( )     if((
13 15.1 ( )( )     rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Le_l) && (
13 15.2 ( )( )     rw_IrLightforSOSE_Corr2_l >= rw_SoSe_SunInt_2D_Re_l)) 
                   {
13 16                rw_SoSe_SunInt_2D_Le_l = rw_IrLightforSOSE_Corr2_l;
13 17                rw_SoSe_SunInt_2D_Re_l = rw_IrLightforSOSE_Corr2_l;
                   }
13 18              rw_SoSe_SunInt_2D_Le_l=(rw_SoSe_SunInt_2D_Le_l>>3)*5;
                   rw_SoSe_SunInt_2D_Le_l=((
13 19   ( )( ) 
13 19.1 ( )( )     rw_SoSe_SunInt_2D_Le_l>240)?240:rw_SoSe_SunInt_2D_Le_l);
                   {
13 20              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Le_l;}
13 21              ;
13 22              rw_SoSe_SunInt_2D_Re_l=(rw_SoSe_SunInt_2D_Re_l>>3)*5;
                   rw_SoSe_SunInt_2D_Re_l=((
13 23   ( )( ) 
13 23.1 ( )( )     rw_SoSe_SunInt_2D_Re_l>240)?240:rw_SoSe_SunInt_2D_Re_l);
                   {
13 24              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = rw_SoSe_SunInt_2D_Re_l;}
13 25              ;       
                 }
                 else{}
13 26   ( )( )   if(
13 26.1 ( )( )   uF_ASIC_ControlFlags_g . Bit . B2 == 0)
                 {
                   {
13 27              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 254;}
13 28              ;
                   {
13 29              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 254;}
13 30              ;
                 }
               }
               static void OutPutBrightnessValue(void)
               {
                 static byte rb_InitLightValCnt_l=100;
14 0    ( )    OutPutBrightnessValue
14 1    ( )( )   if((
14 1.1  ( )( )   uF_ASIC_ControlFlags_g . Bit . B1 == 0)|| (
14 1.2  ( )( )   uF_Main_Flags_g . Bit . B6 == 1))
                 {
14 2    ( )( )     if(
14 2.1  ( )( )     rb_InitLightValCnt_l<100)
                   {
14 3                 rb_InitLightValCnt_l++;
                   }
                   else
                   { 
                     {
14 4                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = (0 & 0xff); 
14 5                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((0 >> 8) & 0x1);}
14 6                 ;
                     {
14 7                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0;}
14 8                 ;
               			{
14 9                 RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = 0xF1;}
14 10                ;
                     {
14 11                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = (0 & 0x3F); 
14 12                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((0 >> 6) & 0xFF);}
14 13                ;
                     {
14 14                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 1;}
14 15                ;
                     {
14 16                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 254;}
14 17                ;        // Init 
                     {
14 18                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 254;}
14 19                ;         // Init
                   }
                 }
                 else
                 {
14 20              rb_InitLightValCnt_l=0;
14 21   ( )( )     if(
14 21.1 ( )( )     rb_Err_State_Light_Sens_mg == 1)                    /*  VDR469   set for error*/
                   {
                     {
14 22                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_0 = (0x1FF & 0xff); 
14 23                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn1_CEM_LIN1_1 = ((0x1FF >> 8) & 0x1);}
14 24                ;
                     {
14 25                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsAmblillmn2_CEM_LIN1 = 0xFF;}
14 26                ;
                     {
14 27                RlsmCem_Lin1Fr02_CEM_LIN1 . rlsmcem_lin1fr02_cem_lin1 . AmbIllmnFwdStsChks_CEM_LIN1 = 0xA3;}
14 28                ;
                     {
14 29                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_0 = (16383 & 0x3F); 
14 30                RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawTwliBriRaw_CEM_LIN1_1 = ((16383 >> 6) & 0xFF);}
14 31                ;
                     {
14 32                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrRiValue_CEM_LIN1 = 0xFF;}
14 33                ;                            /* Init*/
                     {
14 34                RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrLeValue_CEM_LIN1 = 0xFF;}
14 35                ;                             /* Init*/
                   }
                   else
                   {  
14 36                OutPutHudValue(); 
14 37                OutPutTwliBriValue();
14 38                OutPutSolarValue();
                   }
                 } 
               }
               #pragma inline=forced
               static void CheckErrors(void)
               {
                 byte rb_hud_errorParity_l = 0;
15 0    ( )    CheckErrors
15 1             rb_RS_LS_Error1_g = ((uF_Diagnose_pre_Flag . Bit . B1) | 
                                      ((uF_Diagnose_pre_Flag . Bit . B0)<<1) | 
                                        ((uF_Check_lightsensor_g . Bit . B3)<<2) | 
                                          (uF_ASIC_Error_Flags_g . Bit . B3<<3) | 
                                            (uF_ASIC_Ctrl_Error_Flags_g . Bit . B5<<4) | 
                                              (uF_ASIC_Ctrl_Error_Flags_g . Bit . B0<<5) | 
                                                (uF_ASIC_Ctrl_Error_Flags_g . Bit . B1<<6) | 
                                                  (uF_ASIC_Ctrl_Error_Flags_g . Bit . B4<<7));
                 /*VCO_220 VIrefLo/Hi monitoring*/ /*VDR_878*/
15 2             rb_RS_LS_Error2_g = (uF_ASIC_Ctrl_Error_Flags_g . Bit . B3 | 
                                      ((uF_uC_Error_g . Bit . B1)<<1) | 
                                        (uF_ASIC_Error_Flags_g . Bit . B5<<2) |
                                          (uF_ASIC_Error_Flags_g . Bit . B7<<3) |
                                            (uF_ASIC_Error_Flags1_g . Bit . B0<<4));
                 /*VCO_225 RS functionality detection - error when not available*/
15 3             (uF_Diagnose_pre_Flag . Bit . B3) = 0;
15 4             rb_RainS_Error1_g = (RSStatus . Bit . B4 | 
                                      (uF_ASIC_Ctrl_Error_Flags_g . Bit . B2<<1) |
                                        (uF_ASIC_Error_Flags_g . Bit . B6<<2)|
                                          ((uF_Diagnose_pre_Flag . Bit . B3)<<3)|
                                            ((uF_uC_Error_g . Bit . B0)<<4));  
15 5             rb_LightS_Error1_g = ((uF_LightInternalStatus_g . Bit . B5) | 
                                       (rb_ASIC_ALSx_ShortDetected_Error_g<<1) | 
                                         ((uF_Diagnose_pre_Flag . Bit . B2)<<2) | 
                                           (uF_ASIC_Error_Flags_g . Bit . B4<<3)| 
                                             ((uF_Diagnose_pre_Flag . Bit . B4) << 4));
                 {
15 6             RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErrActv_CEM_LIN1 = 1;}
15 7             ;  
                 //15:RLFS 7:RLS
15 8    ( )( )   if((
15 8.1  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 15) || (
15 8.2  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 7))
                 {
                   /* VCO132: SM210 - ASIC Frequency Check (done at startup) - LS,RS_Failure */
                   /* VCO 140: SM150 - ADC test */
                   /* setze Lichtsensor RS-Fehler nach SRS */
                   /*SM240*/
                   {
15 9    ( )( )     RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrRainDetnErr_CEM_LIN1 = (
15 9.1  ( )( )     rb_RS_LS_Error1_g != 0) || (
15 9.2  ( )( )     rb_RS_LS_Error2_g != 0) || (
15 9.3  ( )( )     rb_RainS_Error1_g != 0) || (
15 9.4  ( )( )     uF_E2ConfigErrorFlags_g . Bit . B6 != 0);}
15 10              ;
                 }
15 11   ( )( )   if(((
15 11.1 ( )( )   rb_RS_LS_Error1_g != 0) 
                     || (
15 11.2 ( )( )   rb_RS_LS_Error2_g != 0) 
                       || (
15 11.3 ( )( )   rb_LightS_Error1_g != 0) 
                         || (
15 11.4 ( )( )   uF_E2ConfigErrorFlags_g . Bit . B6 != 0) 
                           || (
15 11.5 ( )( )   uF_LIN_DiagReq2_mg . Bit . B1)))
                 {
15 12              rb_Err_State_Light_Sens_mg = 1;
                   {
15 13              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 0;}
15 14              ;
                   {
15 15              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrErr_CEM_LIN1 = 1;}
15 16              ;
                   {
15 17              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1 = 1;}
15 18              ;
                 }
                 else
                 {
15 19              rb_Err_State_Light_Sens_mg = 0;
                   {
15 20              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . TwliBriRawQf_CEM_LIN1 = 3;}
15 21              ;
                   {
15 22              RlsmCem_Lin1Fr03_CEM_LIN1 . rlsmcem_lin1fr03_cem_lin1 . SolarSnsrErr_CEM_LIN1 = 0;}
15 23              ;
                   {
15 24              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1 = 0;}
15 25              ;
                 }
15 26            rb_hud_errorParity_l = IsByteOddParity(RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrSnsrErr_CEM_LIN1);
                 {
15 27            RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . HudSnsrErrParChk_CEM_LIN1 = rb_hud_errorParity_l;}
15 28            ;
               }
               void ApplLinInit(byte rb_LIN_State_l)
               {
                 byte rb_Index_l; 
                 static const byte LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[4] = {0,0,0,0};/*0x22*/
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[8] = {0,0,0,0,0,0,0,0};/*0x18*/
                 static const byte LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[7] = {0,0,0,0,0,0,0};/*0x20*/
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[8] = {0,14,50,50,0,0,0,0};/*0x02*/
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[8] = {88,2,0,0,0,0,75,80};/*0x2C*/
                 static const byte LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[8] = {0,0,0,1,0,0,0,0};/*0x15*/
16 0    ( )    ApplLinInit
16 1             rb_Index_l = 0;
                 do
                 {
16 2               RlsmCem_SerNrLin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_SerNrLin1Fr01_CEM_LIN1[rb_Index_l];
16 3               RlsmCem_Lin1PartNrFr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr02_CEM_LIN1[rb_Index_l];
16 4               RlsmCem_Lin1PartNrFr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1PartNrFr01_CEM_LIN1[rb_Index_l];
16 5               RlsmCem_Lin1Fr03_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr03_CEM_LIN1[rb_Index_l];
16 6               RlsmCem_Lin1Fr02_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr02_CEM_LIN1[rb_Index_l];
16 7               RlsmCem_Lin1Fr01_CEM_LIN1._c[rb_Index_l] = LinMsgDefault_RlsmCem_Lin1Fr01_CEM_LIN1[rb_Index_l];
16 8               rb_Index_l++;
                 }
16 9    ( )( )      while (
16 9.1  ( )( )     rb_Index_l < 8);
16 10            rw_AfterRSWipeCounter_mg = 50000;
16 11            rw_AfterRSWipeCounterAlt_mg = 50000;
16 12            rw_AfterWWSWipeCounter_mg = 50000;//Direktbitdelay bei Kl15 Aus hochsetzen!
16 13            sci_init(rb_LIN_State_l);
16 14            uF_SCIFlags_mg . Bit . B6 = 1;
16 15            uF_StatusRainsensor_mg . Bit . B7 = 1;
16 16            rb_PotiStageFromBox_g = 3;  
16 17            rw_WipeCommandTimOut_mg = 0; 
16 18            rb_AnyErrorCounterDebounce_mg = 200;  
16 19            rb_WipeWorkStatus_mg = 1;  
               }
               __callt void ApplLinSlavePreCopy(byte rb_MessageID_l)                                     /* callt function faster */
               {
17 0    ( )    ApplLinSlavePreCopy
17 1    ( )( )   if(
17 1.1  ( )( )   rb_MessageID_l == (EEPROM_Struct_PD . EEPROMStructPD . IDRLSs_01 & 0x3F))
                 {
                   {
17 2               RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . ErrRespRLSM_CEM_LIN1 = uF_Communication_mg . Bit . B6;}
17 3               ;
                   //l_u8_wr_L_Signal_Error(rbi_latched_ResponseError_mg);
17 4               uF_Communication_mg . Bit . B6 = 0;
                 } 
                 else{}
               }
               /*HUD Algrithm shenzhen-team 2018-05-05*/
               static void GetFiveTableValue_500ms(unsigned long rl_HUD_Brightness_50ms)
               {
                 static byte rb_k_cycleIn50ms=0;
                 static byte rb_k_cycleIn500ms=0;
18 0    ( )    GetFiveTableValue_500ms
18 1             rb_storeHUDValueEvery500ms[rb_k_cycleIn50ms] = rl_HUD_Brightness_50ms;
18 2             rb_k_cycleIn50ms++;
18 3    ( )( )   if(
18 3.1  ( )( )   rb_k_cycleIn50ms >= 10)
                 {
18 4               rb_k_cycleIn50ms = 0;
18 5               orderHUDValue(10);
18 6               HUDEverageValue[rb_k_cycleIn500ms] = ((rb_storeHUDValueEvery500ms[3] 
                                                          + rb_storeHUDValueEvery500ms[4] 
                                                            + rb_storeHUDValueEvery500ms[5] 
                                                              + rb_storeHUDValueEvery500ms[6] 
                                                                + rb_storeHUDValueEvery500ms[7]) 
                                                                  / 5);
18 7               rb_k_cycleIn500ms++;
18 8    ( )( )     if(
18 8.1  ( )( )     rb_k_cycleIn500ms >= 2)
                   {
18 9                 rb_k_cycleIn500ms=0;  
18 10                rb_hud_data_update = 1;
                   }    
                 }
               }
               static unsigned long AdjustOutHudValue(unsigned long rl_CurrentHud)
               {
                 unsigned int currLevel = 0;
                 unsigned int rw_LastCurrDiff = 0;
                 unsigned long  rl_adjustAfterHud = 0;
19 0    ( )    AdjustOutHudValue
19 1    ( )( )   if(
19 1.1  ( )( )   rl_CurrentHud >= 100)
                 {
19 2               return rl_CurrentHud;
                 }
                 else{}
19 3             currLevel = RW_Amb_Fw_Result_End / 10;  
19 4    ( )( )   if(
19 4.1  ( )( )   rl_CurrentHud >= RW_Amb_Fw_Result_End)
                 {
19 5               rw_LastCurrDiff = rl_CurrentHud - RW_Amb_Fw_Result_End;
                 }
                 else
                 {
19 6               rw_LastCurrDiff = RW_Amb_Fw_Result_End - rl_CurrentHud;
                 }
19 7    ( )( )   if(
19 7.1  ( )( )   rw_LastCurrDiff <= 15)
                 {
19 8               return  rl_CurrentHud;
                 }
                 else{}
19 9    ( )( )   if(
19 9.1  ( )( )   rl_CurrentHud >= RW_Amb_Fw_Result_End)
                 {
19 10              currLevel = currLevel + (rw_LastCurrDiff / 15);
19 11              rw_LastCurrDiff = rw_LastCurrDiff % 3;
19 12   ( )( )     if(
19 12.1 ( )( )     currLevel > 9)
                   {
19 13                rl_adjustAfterHud = 92 + (unsigned long)rw_LastCurrDiff;
                   }
                   else
                   {
19 14                rl_adjustAfterHud = 5 + (currLevel * 10) + (unsigned long)rw_LastCurrDiff;
                   }
                 }
                 else
                 {
19 15   ( )( )     if(
19 15.1 ( )( )     currLevel >= (rw_LastCurrDiff / 15))
                   {
19 16                currLevel = currLevel - (rw_LastCurrDiff / 15);
19 17                rw_LastCurrDiff = rw_LastCurrDiff % 3;
19 18   ( )( )       if(
19 18.1 ( )( )       currLevel > 9)
                     {
19 19                  rl_adjustAfterHud = 92 - (unsigned long)rw_LastCurrDiff;
                     }
                     else
                     {
19 20                  rl_adjustAfterHud = ((5 + (currLevel * 10)) - (unsigned long)rw_LastCurrDiff);
                     }
                   }
                   else
                   {
19 21                rw_LastCurrDiff = rw_LastCurrDiff % 3;
19 22                rl_adjustAfterHud = 5 - (unsigned long)rw_LastCurrDiff;
                   }
                 }
19 23            return  rl_adjustAfterHud;    
               }
               static byte GetUpdateTimeForLightStatus(void)
               {
                 unsigned char  hud_refresh_time = 1;  
                 //1 in tunnel and day for 1s  get data;in night and darkstart for 3s  get data 
                 //2 if in tunnel and speed less 10,then 3s will upate
20 0    ( )    GetUpdateTimeForLightStatus
20 1    ( )( )   if((
20 1.1  ( )( )   (uF_LightInternalStatus_g . Bit . B0) == 1) && (
20 1.2  ( )( )   uF_Main_Flags_g . Bit . B6 == 0))
                 {
20 2    ( )( )     if(
20 2.1  ( )( )     (uF_modi_lightsens_g.AllBit & (byte) 2) > 0)
                   {
20 3                 hud_refresh_time = 3;
                   }
                   else 
20 4    ( )( )       if (
20 4.1  ( )( )       (uF_modi_lightsens_g.AllBit & (byte) 4) > 0)
                   {
20 5    ( )( )         if(
20 5.1  ( )( )         rb_speed_in_kmh_g >= 10)
                     {
20 6                     hud_refresh_time = 1;
                     }
                     else
                     {
20 7                     hud_refresh_time = 3;
                     }   
                   }
                   else 
20 8    ( )( )         if (
20 8.1  ( )( )         (uF_modi_lightsens_g.AllBit & (byte) 1) > 0)
                   {
20 9                     hud_refresh_time = 3;
                   }
                   else
                   {
20 10                    hud_refresh_time = 1;  
                   }
                 }
                 else
                 {
20 11              hud_refresh_time = 1;  
                 }  
20 12            return  hud_refresh_time;
               }
               static unsigned long CalcHUDMean_1000ms(void)
               {  
                 static  unsigned char RW_Update_Time_Count = 0;
                 unsigned long  rl_current_hud_lux = 0;
                 unsigned char  rb_hud_refresh_time = 1;
21 0    ( )    CalcHUDMean_1000ms
21 1    ( )( )   if(
21 1.1  ( )( )   rb_hud_data_update == 1)
                 {
21 2               rb_hud_data_update = 0;
21 3               rb_hud_refresh_time = GetUpdateTimeForLightStatus();
21 4    ( )( )     if(
21 4.1  ( )( )     RW_Update_Time_Count < rb_hud_refresh_time)
                   {
21 5                 RW_Update_Time_Count++;  
                   }
                   else{}
                   //internal data updata time is 1s
                   //Data send to BCM is decided for  RW_Update_Time_Count and rb_hud_refresh_time
                   //if rl_current_hud_lux and RW_Amb_Fw_Result_End  are less than 100, we will get average value
21 6               rl_current_hud_lux = (HUDEverageValue[0] + HUDEverageValue[1])/2; 
21 7    ( )( )     if((
21 7.1  ( )( )     rl_current_hud_lux < 100) && (
21 7.2  ( )( )     RW_Amb_Fw_Result_End < 100))
                   {        
21 8                 rl_current_hud_lux = (RW_Amb_Fw_Result_End +rl_current_hud_lux)/2;
                   }  
21 9    ( )( )     if(
21 9.1  ( )( )     rb_hud_refresh_time <= RW_Update_Time_Count)//refresh time is reached
                   {   
21 10                RW_Update_Time_Count = 0;        
21 11                RW_Amb_Fw_Result_End = AdjustOutHudValue(rl_current_hud_lux);         
                   }
                   else{}    
                 }  
21 12            return RW_Amb_Fw_Result_End;
               }
               /*****Bubble Sort**********/
               static void orderHUDValue(int n)
               {
                 unsigned long rb_temp_l = 0;
                 int i =0;
                 int j = 0;
22 0    ( )    orderHUDValue
22 1    ( )( )   for(i = 0;
22 1.1  ( )( )   i < n;i++)
                 {
22 2    ( )( )     for(j = 1;
22 2.1  ( )( )     j < (n-i);j++)
                   {    
22 3    ( )( )       if(
22 3.1  ( )( )       rb_storeHUDValueEvery500ms[j-1] > rb_storeHUDValueEvery500ms[j])
                     {
22 4                   rb_temp_l = rb_storeHUDValueEvery500ms[j];
22 5                   rb_storeHUDValueEvery500ms[j] = rb_storeHUDValueEvery500ms[j-1];
22 6                   rb_storeHUDValueEvery500ms[j-1] = rb_temp_l ;
                     }
                     else{}
                   }
                 }
               }
               static void GetFiveTableValue_50ms(unsigned long Fw,unsigned long Amb)
               {
                 static unsigned long FW_Average_In_50ms = 0;
                 static unsigned long AMB_Average_In_50ms = 0;
                 static unsigned long FW_Average_In_50ms_Old = 0;
                 static unsigned long AMB_Average_In_50ms_Old = 0;
                 static unsigned long rb_storeFW_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
                 static unsigned long rb_storeAMB_ValueEvery50ms[10]={0,0,0,0,0,0,0,0,0,0};
                 static unsigned char rb_k_cycleIn50ms=0;
                 unsigned char rb_count = 0;
23 0    ( )    GetFiveTableValue_50ms
23 1             rb_storeFW_ValueEvery50ms[rb_k_cycleIn50ms] = Fw;
23 2             rb_storeAMB_ValueEvery50ms[rb_k_cycleIn50ms] = Amb;
23 3             rb_k_cycleIn50ms++;
23 4    ( )( )   if(
23 4.1  ( )( )   rb_k_cycleIn50ms >= 5)
                 {
23 5               rb_k_cycleIn50ms = 0;
23 6               FW_Average_In_50ms = rb_storeFW_ValueEvery50ms[0];
23 7    ( )( )     for(rb_count = 1;
23 7.1  ( )( )     rb_count < 5;rb_count++)
                   {
23 8                 FW_Average_In_50ms =(FW_Average_In_50ms+ rb_storeFW_ValueEvery50ms[rb_count])/2;
                   }
23 9               AMB_Average_In_50ms=rb_storeAMB_ValueEvery50ms[0];
23 10   ( )( )     for(rb_count = 1;
23 10.1 ( )( )     rb_count < 5;rb_count++)
                   {
23 11                AMB_Average_In_50ms =(AMB_Average_In_50ms+ rb_storeAMB_ValueEvery50ms[rb_count])/2;
                   } 
23 12              FW_Average_In_50ms = (FW_Average_In_50ms_Old+FW_Average_In_50ms)/2 ;
23 13              AMB_Average_In_50ms = (AMB_Average_In_50ms_Old +AMB_Average_In_50ms)/2; 
23 14              GetFiveTableValue_500ms(FW_Average_In_50ms + AMB_Average_In_50ms);
23 15              FW_Average_In_50ms_Old = FW_Average_In_50ms;
23 16              AMB_Average_In_50ms_Old = AMB_Average_In_50ms;
                 }  
               }
               /******************************************End*********************************************/
               /*byte resultCrcTest = 0;
               void TestCrcJ1850Info(void)
               {
                   byte buffer[4]={0x00,0x00,0x00,0x00};//0x59
                   byte buffer1[3]={0xF2,0x01,0x83};//0x37
                   byte buffer2[4]={0x0F,0xAA,0x00,0x55};//0x79
                   byte buffer3[4]={0x00,0xFF,0x55,0x11};//0xB8
                   byte buffer4[9]={0x33,0x22,0x55,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};//0xcb
                   byte buffer5[3]={0x92,0x6B,0x55};//0x8C
                   byte buffer6[4]={0xFF,0xFF,0xFF,0xFF};//0x74
                   resultCrcTest =  CRC8SAEJ1850(buffer,4); //ok
                   resultCrcTest =  CRC8SAEJ1850(buffer1,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer2,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer3,4);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer4,9);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer5,3);//ok
                   resultCrcTest =  CRC8SAEJ1850(buffer6,4);//ok
               }*/
               static byte CRC8SAEJ1850(const byte * u8_data,byte u8_len)
               {
                 byte i, j;
                 byte u8_crc8;
                 byte u8_poly;
24 0    ( )    CRC8SAEJ1850
24 1             u8_crc8 = 0xFF;
24 2             u8_poly = 0x1D;
24 3    ( )( )   for (i = 0; 
24 3.1  ( )( )   i < u8_len; i++)
                 {
24 4               u8_crc8 ^= u8_data[i];
24 5    ( )( )     for (j = 0; 
24 5.1  ( )( )     j < 8; j++)
                   {
24 6    ( )( )       if (
24 6.1  ( )( )       (u8_crc8 & 0x80) > 0)
                     {
24 7                   u8_crc8 = (u8_crc8 << 1) ^ u8_poly;
                     }
                     else
                     {
24 8                   u8_crc8 <<= 1;
                     }
                   }
                 }
24 9             u8_crc8 ^= (byte)0xFF;
24 10            return u8_crc8;
               }
               static byte GetOutdBriStsCrcj1850(byte OutdBriSts)
               {  
                 byte buffer[1];
25 0    ( )    GetOutdBriStsCrcj1850
25 1             buffer[0] = OutdBriSts;
                 //TestCrcJ1850Info();
25 2             return CRC8SAEJ1850(buffer,1);  
               }
               static byte GetHudCrcj1850(unsigned long hudSrc)
               {     
                 //byte buffer[2];
                 //buffer[0] = hudSrc&0xFF;
                 //buffer[1] = (hudSrc>>8)&0xFF;      
                 //return CRC8SAEJ1850(buffer,2);
                 /**********Zhiyuan HU 20190313**************/
                 byte buffer[3];
26 0    ( )    GetHudCrcj1850
26 1             buffer[0] = hudSrc&0xFF;
26 2             buffer[1] = (hudSrc>>8)&0xFF;
26 3             buffer[2] = (hudSrc>>16)&0xFF;
26 4             return CRC8SAEJ1850(buffer,3);
                 /**********Zhiyuan HU 20190313**************/
               }
               static void GetLightTransmission(byte trans_550nm,byte trans_880nm)
               {
                 byte rb_880nm_Transmission_local_Coding = 0;
                 byte rb_550nm_Transmission_local_Coding = 0;
                 //byte rb_550nm_Transmission_local_Coding_outOfRangeFlag = 0;
                 //byte rb_880nm_Transmission_local_Coding_outOfRangeFlag = 0;
27 0    ( )    GetLightTransmission
                 {
27 1             RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErr_CEM_LIN1 = 0;}
27 2             ;
27 3    ( )( )   if(((
27 3.1  ( )( )   trans_550nm >= 15) && (
27 3.2  ( )( )   trans_550nm <= 90)) && ((
27 3.3  ( )( )   trans_880nm >= 15) && (
27 3.4  ( )( )   trans_880nm <= 90)))
                 {
27 4               rb_550nm_Transmission_local_Coding = ((trans_550nm - 15 ) + 2) / 5;
27 5               rb_880nm_Transmission_local_Coding = ((trans_880nm - 15 ) + 2) / 5;
27 6    ( )( )     if((
27 6.1  ( )( )     EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte2_g != ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding)) 
                      && ((
27 6.2  ( )( )     uF_Main_Flags_g . Bit . B2 == 0)||(
27 6.3  ( )( )     uF_Main_Flags_g . Bit . B1 == 1)))
                   {
27 7                 rab_EEPROM_Bytes_toWrite_g[0] = ((rb_880nm_Transmission_local_Coding << 4) | rb_550nm_Transmission_local_Coding);
27 8                 rw_EEPROM_Address_to_Write_g = (268); /*set adress to write*/
27 9                 rb_I2C_EEPROM_bytesToWrite_g = 1;         /*set number of bytes to 1*/
27 10                uF_Main_Flags_g . Bit . B2 = 1;
27 11                uF_Main_Flags_g . Bit . B1 = 0;
                   }
                 }
               }
               static void Set_BCMLightOffset(byte offset)
               {
                 static byte rb_lightValueDebounce = 0;
                 byte rb_OldSensorLs ;
                 byte rb_Kodierbyte0_Update_g; 
28 0    ( )    Set_BCMLightOffset
28 1    ( )( )   if(
28 1.1  ( )( )   rb_lightValueDebounce < 20)//if 100MS run once ,2s delay check
                 {
28 2               rb_lightValueDebounce ++;
28 3               return ;
                 }
                 /*check if the E2PROM data has been loaded*/
28 4    ( )( )   if(
28 4.1  ( )( )   uF_Main_Flags_g . Bit . B6 == 1)
                 {
28 5               return ;
                 }
28 6             rb_OldSensorLs = (EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g& 0x38)>>3;
28 7             rb_Kodierbyte0_Update_g = EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g; 
28 8    ( )( )   if((
28 8.1  ( )( )   offset < 8) 
                    && (
28 8.2  ( )( )   rb_OldSensorLs != offset) 
                      && ((
28 8.3  ( )( )   uF_Main_Flags_g . Bit . B2 == 0)||(
28 8.4  ( )( )   uF_Main_Flags_g . Bit . B1 == 1)))
                 {
28 9               rb_Kodierbyte0_Update_g &=0xC7; 
28 10              rb_Kodierbyte0_Update_g |=(offset << 3); 
28 11              rab_EEPROM_Bytes_toWrite_g[0] = rb_Kodierbyte0_Update_g;
28 12              rw_EEPROM_Address_to_Write_g = (268)+2; 
28 13              rb_I2C_EEPROM_bytesToWrite_g = 1;         
28 14              uF_Main_Flags_g . Bit . B2 = 1;
28 15              uF_Main_Flags_g . Bit . B1 = 0;
                 }
               }
               static void SendRLSSerNo(void)
               {
                 unsigned long d = 0;
                 byte a,b,c,e,f,g,h;
29 0    ( )    SendRLSSerNo
29 1             a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(0)]));
29 2             b = a / 16;
29 3             c = a % 16;
29 4             d = (b * 10000000) + (c * 1000000);
29 5             a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(1)]));
29 6             b = a / 16;
29 7             c = a % 16;
29 8             d = (b * 100000) + (c * 10000) + d;
29 9             a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(2)]));
29 10            b = a / 16;
29 11            c = a % 16;
29 12            d = (b * 1000) + (c * 100) + d;
29 13            a = ((EEPROM_Struct_PD . EEPROMStructPD . Produktionsdaten[(3)]));
29 14            b = a / 16;
29 15            c = a % 16;
29 16            d = (b * 10) + (c * 1) + d;
29 17            e = (d >> 0) & 0xff;
29 18            f = (d >> 8) & 0xff;
29 19            g = (d >> 16) & 0xff;
29 20            h = (d >> 24) & 0xff;
                 {
29 21            RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr1_CEM_LIN1 = h;}
29 22            ;
                 {
29 23            RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr2_CEM_LIN1 = g;}
29 24            ;
                 {
29 25            RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr3_CEM_LIN1 = f;}
29 26            ;
                 {
29 27            RlsmCem_SerNrLin1Fr01_CEM_LIN1 . rlsmcem_sernrlin1fr01_cem_lin1 . RLSMSerNoNr4_CEM_LIN1 = e;}
29 28            ;
               }
               static void SendRLSMPartNo(void)
               {
30 0    ( )    SendRLSMPartNo
                 {
30 1             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr1_CEM_LIN1 = 0;}
30 2             ;
                 {
30 3             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr2_CEM_LIN1 = 0;}
30 4             ;
                 {
30 5             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr3_CEM_LIN1 = 0;}
30 6             ;
                 {
30 7             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoNr4_CEM_LIN1 = 0;}
30 8             ;
                 {
30 9             RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn1_CEM_LIN1 = 0x20;}
30 10            ;
                 {
30 11            RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn2_CEM_LIN1 = 0x20;}
30 12            ;
                 {
30 13            RlsmCem_Lin1PartNrFr01_CEM_LIN1 . rlsmcem_lin1partnrfr01_cem_lin1 . RLSMPartNoEndSgn3_CEM_LIN1 = 0x20;}
30 14            ;
               }
               static void SendRLSMPartNo10(void)
               {
31 0    ( )    SendRLSMPartNo10
31 1    ( )( )   if(
31 1.1  ( )( )   EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 15)
                 {
                   //15:RLFS
                   {
31 2               RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;}
31 3               ;
                   {
31 4               RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x89;}
31 5               ;
                   {
31 6               RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x07;}
31 7               ;
                   {
31 8               RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x24;}
31 9               ;
                   {
31 10              RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x28;}
31 11              ;
                   {
31 12              RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;}
31 13              ;
                   {
31 14              RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;}
31 15              ;
                   {
31 16              RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 0x46;}
31 17              ;
                 }
                 else 
31 18   ( )( )     if(
31 18.1 ( )( )     EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 7)
                 {
                   //7:RLS
                   {
31 19                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;}
31 20                ;
                   {
31 21                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x88;}
31 22                ;
                   {
31 23                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x99;}
31 24                ;
                   {
31 25                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x81;}
31 26                ;
                   {
31 27                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x20;}
31 28                ;
                   {
31 29                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;}
31 30                ;
                   {
31 31                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;}
31 32                ;
                   {
31 33                RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 66;}
31 34                ;
                 }
                 else 
31 35   ( )( )       if(
31 35.1 ( )( )       EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 14)
                 {
                   //14:LFS
                   {
31 36                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;}
31 37                  ;
                   {
31 38                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x88;}
31 39                  ;
                   {
31 40                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x99;}
31 41                  ;
                   {
31 42                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x81;}
31 43                  ;
                   {
31 44                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x23;}
31 45                  ;
                   {
31 46                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;}
31 47                  ;
                   {
31 48                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;}
31 49                  ;
                   {
31 50                  RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 66;}
31 51                  ;
                 }
                 else 
31 52   ( )( )         if(
31 52.1 ( )( )         EEPROM_Struct_PD . EEPROMStructPD . RSControlFlags == 6)
                 {
                   //6:LS
                   {
31 53                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr1_CEM_LIN1 = 0x88;}
31 54                    ;
                   {
31 55                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr2_CEM_LIN1 = 0x88;}
31 56                    ;
                   {
31 57                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr3_CEM_LIN1 = 0x99;}
31 58                    ;
                   {
31 59                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr4_CEM_LIN1 = 0x81;}
31 60                    ;
                   {
31 61                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10Nr5_CEM_LIN1 = 0x13;}
31 62                    ;
                   {
31 63                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn1_CEM_LIN1 = 0x20;}
31 64                    ;
                   {
31 65                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn2_CEM_LIN1 = 0x20;}
31 66                    ;
                   {
31 67                    RlsmCem_Lin1PartNrFr02_CEM_LIN1 . rlsmcem_lin1partnrfr02_cem_lin1 . RLSMPartNo10EndSgn3_CEM_LIN1 = 66;}
31 68                    ;
                 }
                 else{}
               }
               /*T < 0 degree and Speed is under 5KM/H.*/
               static void WipeWinterModeCheck(void)
               {  
32 0    ( )    WipeWinterModeCheck
32 1    ( )( )   if(
32 1.1  ( )( )   rb_speed_in_kmh_g > 5)
                 {
32 2               Vehicle_Speed_Decision_Flag = 1;
                 }
32 3    ( )( )   if((
32 3.1  ( )( )   Vehicle_Speed_Decision_Flag == 0) && (
32 3.2  ( )( )   rb_OutsideTemp_mg < 80))
                 {
32 4               rb_WipeWorkStatus_mg = 2;
                 }
                 else
                 {
32 5               rb_WipeWorkStatus_mg = 1;
                 } 
               }
               static byte IsByteOddParity(byte data)
               {
                 byte parity = 0;
33 0    ( )    IsByteOddParity
33 1    ( )( )   while (
33 1.1  ( )( )   data != 0)
                 {
33 2    ( )( )     parity = !
33 2.1  ( )( )     parity;
33 3               data = 0;
                 }
33 4    ( )( )   return (!
33 4.1  ( )( )   parity);
               }
               static void Rain_sensitivity(void)
               { 
34 0    ( )    Rain_sensitivity
34 1    ( )( )   if(
34 1.1  ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty0_CEM_LIN1 == 0)
                 {
34 2               rb_RLS_Sensitivity_Array_l[0] = 1;
                 }
                 else
                 {
34 3               rb_RLS_Sensitivity_Array_l[0] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty0_CEM_LIN1*2;
                 }
34 4    ( )( )   if(
34 4.1  ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty1_CEM_LIN1 == 0)
                 {
34 5               rb_RLS_Sensitivity_Array_l[1] = 1;
                 }
                 else
                 {
34 6               rb_RLS_Sensitivity_Array_l[1] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty1_CEM_LIN1*2; 
                 }
34 7    ( )( )   if(
34 7.1  ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty2_CEM_LIN1 == 0)
                 {
34 8               rb_RLS_Sensitivity_Array_l[2] = 1;
                 }
                 else
                 {
34 9               rb_RLS_Sensitivity_Array_l[2] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty2_CEM_LIN1*2;
                 }
34 10   ( )( )   if(
34 10.1 ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty3_CEM_LIN1 == 0)
                 {
34 11              rb_RLS_Sensitivity_Array_l[3] = 1;
                 }
                 else
                 {
34 12              rb_RLS_Sensitivity_Array_l[3] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty3_CEM_LIN1*2; 
                 }
34 13   ( )( )   if(
34 13.1 ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty4_CEM_LIN1 == 0)
                 {
34 14              rb_RLS_Sensitivity_Array_l[4] = 1;
                 }
                 else
                 {
34 15              rb_RLS_Sensitivity_Array_l[4] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty4_CEM_LIN1*2;
                 }
34 16   ( )( )   if(
34 16.1 ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty5_CEM_LIN1 == 0)
                 {
34 17              rb_RLS_Sensitivity_Array_l[5] = 1;
                 }
                 else
                 {
34 18              rb_RLS_Sensitivity_Array_l[5] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty5_CEM_LIN1*2;
                 }
34 19   ( )( )   if(
34 19.1 ( )( )   CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty6_CEM_LIN1 == 0)
                 {
34 20              rb_RLS_Sensitivity_Array_l[6] = 1;
                 }
                 else
                 {
34 21              rb_RLS_Sensitivity_Array_l[6] = CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . RainSnsrSnvtyForUsrSnvty6_CEM_LIN1*2;
                 }      
34 22            Rain_Sensitivity_Judge();
               }
               static void Get_Lin_Signal_From_GetLeWWS(void)
               {  
35 0    ( )    Get_Lin_Signal_From_GetLeWWS
35 1    ( )( )   if((
35 1.1  ( )( )   uLinIndicationFlags . w[0]. b5 != 0))
                 {
                   {
35 2               uLinIndicationFlags . w[0]. b5 = 0;}
35 3               ;
35 4               uF_SCIFlags_mg . Bit . B1 = 1;
35 5    ( )( )     if(
35 5.1  ( )( )     CemCem_Lin1Fr02_CEM_LIN1 . cemcem_lin1fr02_cem_lin1 . AmbTForVisy_CEM_LIN1 != 255)
                   {
35 6                 rb_OutsideTemp_mg = CemCem_Lin1Fr02_CEM_LIN1 . cemcem_lin1fr02_cem_lin1 . AmbTForVisy_CEM_LIN1;
                   }
35 7               WipeWinterModeCheck(); 
                 }
35 8    ( )( )   if((
35 8.1  ( )( )   uLinIndicationFlags . w[0]. b4 != 0))
                 {
                   {
35 9               uLinIndicationFlags . w[0]. b4 = 0;}
35 10              ;
35 11              uF_SCIFlags_mg . Bit . B1 = 1;
                   {
35 12              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . RainSnsrErrCalErrActv_CEM_LIN1 = 1;}
35 13              ;     
                   //Get_BCMVehType(l_u8_rd_VehTyp_CEM_LIN1());
35 14              GetLightTransmission(CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValFrnt_CEM_LIN1,CemCem_Lin1Fr03_CEM_LIN1 . cemcem_lin1fr03_cem_lin1 . WindCorrnValAmb_CEM_LIN1);
35 15              Rain_sensitivity();
                 }
35 16   ( )( )   if((
35 16.1 ( )( )   uLinIndicationFlags . w[0]. b3 != 0))
                 {
                   {
35 17              uLinIndicationFlags . w[0]. b3 = 0;}
35 18              ;
35 19              uF_SCIFlags_mg . Bit . B1 = 1;
35 20              Set_BCMLightOffset(CemCem_Lin1Fr04_CEM_LIN1 . cemcem_lin1fr04_cem_lin1 . RainSnsrLiThd_CEM_LIN1);
                 }
35 21   ( )( )   if((
35 21.1 ( )( )   uLinIndicationFlags . w[0]. b2 != 0))
                 {
                   {
35 22              uLinIndicationFlags . w[0]. b2 = 0;}
35 23              ;
35 24              uF_SCIFlags_mg . Bit . B1 = 1;
                 }
35 25   ( )( )   if((
35 25.1 ( )( )   uLinIndicationFlags . w[0]. b1 != 0))
                 { 
                   {
35 26              uLinIndicationFlags . w[0]. b1 = 0;}
35 27              ;
35 28              uF_SCIFlags_mg . Bit . B1 = 1;
35 29   ( )( )     uF_SCIFlags_mg . Bit . B6 = !(
35 29.1 ( )( )     CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WiprInWipgAr_CEM_LIN1);        // wiper position
35 30   ( )( )     if (
35 30.1 ( )( )     CemCem_Lin1Fr06_CEM_LIN1 . cemcem_lin1fr06_cem_lin1 . WshngCycActv_CEM_LIN1 == 1)                                 /* Washpump activ? 0x5:Front washing*/
                   {
35 31                RSStatus . Bit . B1 = 1;                                       /* set Washing activ bit */
                   }
                   else 
35 32   ( )( )       if (
35 32.1 ( )( )       uF_StatusRainsensor_mg . Bit . B7 == 1)                                /* In Parkposition ? */
                   {
35 33                  RSStatus . Bit . B1 = 0;                                      /* Clear Washing active bit */
                   }
                   else{}                                                              /*Do nothing, Dummy-else for Misra Check*/
                 }  
               }
               static void Light_Sensitivity_In_GetLeWWS(void)
               {
                 static const byte cab_PotistageMapping_mg[8] = {4,5,6,7,3,2,1,0}; /*mapping for potistages!*/  
                 byte rb_Empfindlichkeit_LS_l;
36 0    ( )    Light_Sensitivity_In_GetLeWWS
36 1             rb_Empfindlichkeit_LS_l = 3;
36 2    ( )( )   if(
36 2.1  ( )( )   (cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)>3)
                 {
36 3               rb_LSPotiStage_g = (cab_PotistageMapping_mg[((EEPROM_Struct_PD . EEPROMStructPD . EEKodierbyte0_g & 0x38)>>3)]+rb_Empfindlichkeit_LS_l)-3;
36 4    ( )( )     if(
36 4.1  ( )( )     rb_LSPotiStage_g>7)
                   {
36 5                 rb_LSPotiStage_g=7;
                   }
                 }
                 else
                 {
36 6               rb_LSPotiStage_g = 0;
                 }
36 7    ( )( )   if (
36 7.1  ( )( )   rb_AfterResetCounter_l<250)
                 {
36 8               rb_AfterResetCounter_l++;
                 }
                 else{}
36 9    ( )( )   if(
36 9.1  ( )( )   rw_IgnitionOffDelay_mg < 1000)                                     /* 10sec delay */
                 {
36 10              rw_IgnitionOffDelay_mg++;
                 }
                 else
                 {
36 11              rb_Release_IntervalMarker_Update_g |= 0xA0;
36 12              uF_StatusRainsensor2_mg . Bit . B2 = 0;
                 }
               }
               static void Wiper_and_Park(void)
               {
                 static byte rb_OutOffParkCounter_mg;
37 0    ( )    Wiper_and_Park
37 1    ( )( )   if(
37 1.1  ( )( )   CemCem_Lin1Fr01_CEM_LIN1 . cemcem_lin1fr01_cem_lin1 . RainSensActvn_CEM_LIN1 == 0)
                 {
37 2               rw_AfterRSWipeCounter_mg = 50000;
37 3               rw_AfterWWSWipeCounter_mg = 50000;
37 4               rw_WipeCommandTimOut_mg = 0;
                 }
                 else{}
37 5    ( )( )   if(
37 5.1  ( )( )   uF_SCIFlags_mg . Bit . B6 == 0)     
                 {
37 6    ( )( )     if (
37 6.1  ( )( )     rb_OutOffParkCounter_mg > 18) 
                   {
37 7                 rw_AfterWWSWipeCounter_mg = 0;
                   }
                   else
                   {
37 8                 rb_OutOffParkCounter_mg ++;
                   }
                 }
                 else
                 {                                            //wiper in park position
37 9               rb_OutOffParkCounter_mg = 0;
37 10   ( )( )     if (
37 10.1 ( )( )     rw_AfterWWSWipeCounter_mg < 50000)
                   {
37 11                rw_AfterWWSWipeCounter_mg++;
                   }
                 }
37 12   ( )( )   if (
37 12.1 ( )( )   rw_AfterRSWipeCounter_mg < 50000)        //Delay for Tunnel wipe function
                 {
37 13              rw_AfterRSWipeCounter_mg++;   
                 }  
               }
               static void Tunnel_Wipe_Decision(void)
               {
38 0    ( )    Tunnel_Wipe_Decision
38 1    ( )( )   if((
38 1.1  ( )( )   rw_AfterRSWipeCounterAlt_mg <= (((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv>>4))*100))
                    &&(
38 1.2  ( )( )   rb_speed_in_kmh_g > 29)
                      &&(
38 1.3  ( )( )   uF_modi_lightsens_g . Bit . B2 == 1)
                        &&(
38 1.4  ( )( )   rub_RSIntermDelayInit == 0xFF))
                 {
38 2    ( )( )     if ((
38 2.1  ( )( )     uF_Communication_mg . Bit . B4 == 0) && (
38 2.2  ( )( )     rw_AfterRSWipeCounter_mg < (((unsigned int)(EEPROM_Struct_AD . EEPROMStructAD . TunWischVerzAktiv&0x0F))*100)))
                   {
38 3                 rb_tunnelWipeActive_g = 1;
                   }
                 }
                 else
                 {
38 4               rb_tunnelWipeActive_g = 0;
                 }  
               }
               static void Exit_Wipe(void)
               {
39 0    ( )    Exit_Wipe
39 1    ( )( )   if(
39 1.1  ( )( )   uF_SCIFlags_mg . Bit . B6 == 0)
                 {
                 }
                 else
                 {
39 2    ( )( )     if(
39 2.1  ( )( )     rw_AfterWWSWipeCounter_mg > 3000)
                   {
39 3    ( )( )       if(
39 3.1  ( )( )       RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 > 0)
                     {
                       {
39 4                   RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;}
39 5                   ;
                     }
                   }
                   else 
39 6    ( )( )       if(
39 6.1  ( )( )       rw_AfterWWSWipeCounter_mg > 500)
                   {
39 7    ( )( )         if(
39 7.1  ( )( )         RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 > 1)
                     {
                       {
39 8                     RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 1;}
39 9                     ;
                     }
                   }
                   else
                   {
39 10   ( )( )         if(
39 10.1 ( )( )         RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 > 2)
                     {
                       {
39 11                    RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 2;}
39 12                    ;
                     }
                   }
                 }
39 13   ( )( )   if(
39 13.1 ( )( )   uF_StatusRainsensor_mg . Bit . B0 == 0)
                 {
                   {
39 14              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;}
39 15              ;
                 }
                 {
39 16            RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;}
39 17            ;
39 18   ( )( )   if(
39 18.1 ( )( )   rb_WipeWorkStatus_mg == 2)
                 {
                   {
39 19              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . AutWinWipgCmd_CEM_LIN1 = 0;}
39 20              ;
                   {
39 21              RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . WipgAutFrntMod_CEM_LIN1 = 0;}
39 22              ;
                 }
               }
               static void Rain_Sensitivity_Judge(void)
               {
                 byte rb_Loop_Counter = 0;
40 0    ( )    Rain_Sensitivity_Judge
40 1    ( )( )   if((
40 1.1  ( )( )   rb_RLS_Sensitivity_Array_l[0] < rb_RLS_Sensitivity_Array_l[1]) 
                      && (
40 1.2  ( )( )   rb_RLS_Sensitivity_Array_l[1] < rb_RLS_Sensitivity_Array_l[2]) 
                        && (
40 1.3  ( )( )   rb_RLS_Sensitivity_Array_l[2] < rb_RLS_Sensitivity_Array_l[3]) 
                          && (
40 1.4  ( )( )   rb_RLS_Sensitivity_Array_l[3] < rb_RLS_Sensitivity_Array_l[4])
                            && (
40 1.5  ( )( )   rb_RLS_Sensitivity_Array_l[4] < rb_RLS_Sensitivity_Array_l[5]) 
                              && (
40 1.6  ( )( )   rb_RLS_Sensitivity_Array_l[5] < rb_RLS_Sensitivity_Array_l[6]))
                 {
40 2    ( )( )     if((
40 2.1  ( )( )     rb_RLS_Sensitivity_Array_l[0] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[0]) 
                       || (
40 2.2  ( )( )     rb_RLS_Sensitivity_Array_l[1] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[1]) 
                         || (
40 2.3  ( )( )     rb_RLS_Sensitivity_Array_l[2] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[2]) 
                           || (
40 2.4  ( )( )     rb_RLS_Sensitivity_Array_l[3] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[3]) 
                             || (
40 2.5  ( )( )     rb_RLS_Sensitivity_Array_l[4] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[4]))
                   {
40 3    ( )( )       if((
40 3.1  ( )( )       uF_Main_Flags_g . Bit . B1 == 1) || (
40 3.2  ( )( )       uF_Main_Flags_g . Bit . B2 == 0))
                     {
40 4    ( )( )         for(rb_Loop_Counter = 0;
40 4.1  ( )( )         rb_Loop_Counter < 5;rb_Loop_Counter++)
                       {
40 5                     rab_EEPROM_Bytes_toWrite_g[rb_Loop_Counter] = rb_RLS_Sensitivity_Array_l[rb_Loop_Counter];
                       }  
40 6                   rw_EEPROM_Address_to_Write_g = 597;
40 7                   rb_I2C_EEPROM_bytesToWrite_g = 5;         /*set number of bytes to 5*/
40 8                   uF_Main_Flags_g . Bit . B2 = 1;    //set flag for bytes to write
40 9                   uF_Main_Flags_g . Bit . B1 = 0;   //clear bytes written (reset EEPROM bytes Written!)          
                     }
                     else{}
                   }
                   else{}
40 10   ( )( )     if((
40 10.1 ( )( )     rb_RLS_Sensitivity_Array_l[5] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[5]) 
                      || (
40 10.2 ( )( )     rb_RLS_Sensitivity_Array_l[6] != EEPROM_Struct_AD . EEPROMStructAD . RS_Sensitivity[6])) 
                   {
40 11   ( )( )       if((
40 11.1 ( )( )       uF_Main_Flags_g . Bit . B1 == 1) || (
40 11.2 ( )( )       uF_Main_Flags_g . Bit . B2 == 0))
                     {
40 12   ( )( )         for(rb_Loop_Counter = 0;
40 12.1 ( )( )         rb_Loop_Counter < 2;rb_Loop_Counter++)
                       {
40 13                    rab_EEPROM_Bytes_toWrite_g[rb_Loop_Counter] = rb_RLS_Sensitivity_Array_l[rb_Loop_Counter + 5];
                       }  
40 14                  rw_EEPROM_Address_to_Write_g = 602;
40 15                  rb_I2C_EEPROM_bytesToWrite_g = 2;         /*set number of bytes to 4*/
40 16                  uF_Main_Flags_g . Bit . B2 = 1;    //set flag for bytes to write
40 17                  uF_Main_Flags_g . Bit . B1 = 0;   //clear bytes written (reset EEPROM bytes Written!)      
                     }
                     else{}
                   }
                   else{}
                 }
                 else{}
               }
               static void Standby_Judge(void)
               {
41 0    ( )    Standby_Judge
41 1    ( )( )   if (
41 1.1  ( )( )   CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 1)
                 {
41 2    ( )( )     if (
41 2.1  ( )( )     rb_Verglasun_offenDebounce_mg < 0xff)
                   {
41 3                 rb_Verglasun_offenDebounce_mg ++;
                   }
41 4               rb_Verglasun_ClosedDebounce_mg = 0;
                 }
                 else 
41 5    ( )( )     if(
41 5.1  ( )( )     CemCem_Lin1Fr05_CEM_LIN1 . cemcem_lin1fr05_cem_lin1 . EnaOfflineMonitor_CEM_LIN1 == 0)
                 {
41 6                 rw_StandbyTimeOutCnt_g = 0;
41 7    ( )( )       if (
41 7.1  ( )( )       rb_Verglasun_ClosedDebounce_mg < 0xff)
                   {
41 8                   rb_Verglasun_ClosedDebounce_mg ++;
                   }
41 9                 rb_Verglasun_offenDebounce_mg = 0;
                 }
                 else{}
               }
               static void OutdBriCntr_Counter(void)
               {
                 static byte rb_Cnt_l = 0;
42 0    ( )    OutdBriCntr_Counter
                 {
42 1             RlsmCem_Lin1Fr01_CEM_LIN1 . rlsmcem_lin1fr01_cem_lin1 . OutdBriCntr_CEM_LIN1 = rb_Cnt_l;}
42 2             ;
42 3    ( )( )   if(
42 3.1  ( )( )   rb_Cnt_l < 15)
                 {
42 4               rb_Cnt_l ++;
                 }
                 else
                 {
42 5               rb_Cnt_l = 0;
                 }
               }
